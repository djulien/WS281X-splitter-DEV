        = ;
    0 = 0;
        0 = spi1_configuration[spi1UniqueConfiguration].operation;
    ANSELA = 0x00;
    bool status = PIR4bits.TMR2IF;
    CLC1CON = 0x82;
    CLC1GLS0 = 0x02;
    CLC1GLS1 = 0x00;
    CLC1GLS2 = 0x00;
    CLC1GLS3 = 0x00;
    CLC1POL = 0x0E;
    CLC1SEL0 = 0x03;
    CLC1SEL1 = 0x00;
    CLC1SEL2 = 0x00;
    CLC1SEL3 = 0x00;
    CLC2CON = 0x80;
    CLC2GLS0 = 0x02;
    CLC2GLS1 = 0x08;
    CLC2GLS2 = 0x02;
    CLC2GLS3 = 0x18;
    CLC2POL = 0x08;
    CLC2SEL0 = 0x23;
    CLC2SEL1 = 0x22;
    CLC2SEL2 = 0x11;
    CLC2SEL3 = 0x00;
//con1 == SSPxCON1, stat == SSPxSTAT, add == SSPxADD, operation == Master/Slave
        *data++ = SPI1_ExchangeByte(0);
        *data++ = SSP1BUF;
    if(PIE0bits.TMR0IE == 1 && PIR0bits.TMR0IF == 1)
    if (T1CONbits.nT1SYNC == 1)
    INLVLA = 0x3F;
    LATA = 0x00;
    ODCONA = 0x00;
    OSCCON1 = 0x60;
    OSCCON3 = 0x00;
    OSCEN = 0x00;
    OSCFRQ = 0x05;
    OSCSTAT = 0x00;
    OSCTUNE = 0x00;
    PIE0bits.TMR0IE = 1;
    PIR0bits.TMR0IF = 0;
    PIR0bits.TMR0IF = 0;
        PIR3bits.SSP1IF = 0;
    PIR3bits.SSP1IF = 0;
    PIR4bits.TMR1IF = 0;
        PIR4bits.TMR2IF = 0;
    PIR4bits.TMR2IF = 0;
    PMD0 = 0x00;
    PMD1 = 0x00;
    PMD2 = 0x00;
    PMD3 = 0x00;
    PMD4 = 0x00;
    PMD5 = 0x00;
   PR2 = periodVal;
#pragma config BBEN = OFF    // Boot Block Enable bit->Boot Block disabled
#pragma config BBSIZE = BB512    // Boot Block Size Selection bits->512 words boot block size
#pragma config BOREN = ON    // Brown-out reset enable bits->Brown-out Reset Enabled, SBOREN bit is ignored
#pragma config BORV = LO    // Brown-out Reset Voltage Selection->Brown-out Reset Voltage (VBOR) set to 1.9V on LF, and 2.45V on F Devices
#pragma config CLKOUTEN = OFF    // Clock Out Enable bit->CLKOUT function is disabled; i/o or oscillator function on OSC2
#pragma config CP = OFF    // UserNVM Program memory code protection bit->UserNVM code protection disabled
#pragma config CSWEN = ON    // Clock Switch Enable bit->Writing to NOSC and NDIV is allowed
#pragma config FCMEN = ON    // Fail-Safe Clock Monitor Enable bit->FSCM timer enabled
#pragma config FEXTOSC = OFF    // External Oscillator mode selection bits->Oscillator not enabled
#pragma config LPBOREN = OFF    // Low-Power BOR enable bit->ULPBOR disabled
#pragma config LVP = OFF    // Low Voltage Programming Enable bit->High Voltage on MCLR/Vpp must be used for programming
#pragma config MCLRE = ON    // Master Clear Enable bit->MCLR pin is Master Clear function
#pragma config PPS1WAY = ON    // Peripheral Pin Select one-way control->The PPSLOCK bit can be cleared and set only once in software
#pragma config PWRTE = OFF    // Power-up Timer Enable bit->PWRT disabled
#pragma config RSTOSC = HFINT1    // Power-up default value for COSC bits->HFINTOSC (1MHz)
#pragma config SAFEN = OFF    // SAF Enable bit->SAF disabled
#pragma config STVREN = ON    // Stack Overflow/Underflow Reset Enable bit->Stack Overflow or Underflow will cause a reset
#pragma config WDTCCS = SC    // WDT input clock selector->Software Control
#pragma config WDTCPS = WDTCPS_31    // WDT Period Select bits->Divider ratio 1:65536; software control of WDTPS
#pragma config WDTCWS = WDTCWS_7    // WDT Window Select bits->window always open (100%); software control; keyed access not required
#pragma config WDTE = OFF    // WDT operating mode->WDT Disabled, SWDTEN is ignored
#pragma config WRTAPP = OFF    // Application Block Write Protection bit->Application Block not write protected
#pragma config WRTB = OFF    // Boot Block Write Protection bit->Boot Block not write protected
#pragma config WRTC = OFF    // Configuration Register Write Protection bit->Configuration Register not write protected
#pragma config WRTSAF = OFF    // Storage Area Flash Write Protection bit->SAF not write protected
#pragma config ZCD = OFF    // Zero-cross detect disable->Zero-cross detect circuit is disabled at POR.
    PWM3CON = 0x80;   
    PWM3DCH = 0x00;   
     PWM3DCH = (dutyValue & 0x03FC)>>2;
    PWM3DCL = 0xC0;   
     PWM3DCL = (dutyValue & 0x0003)<<6;
    RA0PPS = 0x02;   //RA0->CLC2:CLC2OUT;    
    RA1PPS = 0x01;   //RA1->CLC1:CLC1OUT;    
    RA2PPS = 0x01;   //RA2->CLC1:CLC1OUT;    
    RA4PPS = 0x01;   //RA4->CLC1:CLC1OUT;    
    RA5PPS = 0x01;   //RA5->CLC1:CLC1OUT;    
    readValHigh = TMR1H;
    readValLow = TMR1L;
    readVal = TMR0L;
    readVal = TMR2;
    readVal = ((uint16_t)readValHigh << 8) | readValLow;
    SLRCONA = 0x37;
    SSP1ADD = 0x01;
        SSP1ADD  = spi1_configuration[spi1UniqueConfiguration].add;
    SSP1BUF = byte;
        SSP1BUF = *data;
    SSP1BUF = data;
    SSP1CLKPPS = 16;
    SSP1CON1 = 0x20;
    SSP1CON1bits.SSPEN = 0;
    SSP1CON1bits.SSPEN = 0;
        SSP1CON1bits.SSPEN = 1;
        SSP1CON1 = spi1_configuration[spi1UniqueConfiguration].con1;
        SSP1CON2 = 0x00;
    SSP1DATPPS = 17;
    SSP1STAT = 0x40;
        SSP1STAT = spi1_configuration[spi1UniqueConfiguration].stat;
static const spi1_configuration_t spi1_configuration[] = {   
    T0CON0 = 0x80;
    T0CON0bits.T0EN = 0;
    T0CON0bits.T0EN = 1;
    T0CON1 = 0x42;
    T1CLK = 0x02;
    T1CON = 0x01;
    T1CONbits.T1RD16 = 1;
        T1CONbits.TMR1ON = 0;
    T1CONbits.TMR1ON = 0;
        T1CONbits.TMR1ON =1;
    T1CONbits.TMR1ON = 1;
    T1GATE = 0x0D;
    T1GCON = 0xD0;
    T1GCONbits.T1GGO = 1;
    T2CLKCON = 0x01;
    T2CON = 0x80;
    T2CONbits.TMR2ON = 0;
    T2CONbits.TMR2ON = 1;
    T2HLT = 0xA0;
    T2HLTbits.MODE = mode;
    T2PR = 0x04;
    T2RST = 0x00;
    T2RSTbits.RSEL = reset;
    T2TMR = 0x00;
    timer1ReloadVal=(uint16_t)((TMR1H << 8) | TMR1L);
    TMR0H = 0x31;
   TMR0H = periodVal;
    TMR0_InterruptHandler = InterruptHandler;
    TMR0L = 0x00;
    TMR0L = timerVal;
    TMR1H = 0xFF;
        TMR1H = (uint8_t)(timerVal >> 8);
        TMR1H = (uint8_t)(timerVal >> 8);
    TMR1L = 0xFF;
        TMR1L = (uint8_t)timerVal;
        TMR1L = (uint8_t)timerVal;
    TMR2 = timerVal;
    TRISA = 0x00;
    uint8_t *data = block;
    uint8_t *data = block;
    uint8_t *data = block;
    WPUA = 0x08;
