MPASM 5.87  /HOME/DJ/MPLABXPROJECTS/WSSPLITT   12-5-2021  23:02:33         PAGE  1


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00001     title  "WS281X-Splitter - WS281X segment splitter/breakout/debug for Microchip PIC"
                      00002 ;================================================================================
                      00003 ; File:     wssplitter.asm
                      00004 ; Date:     8/11/2021
                      00005 ; Version:  0.21.10
                      00006 ; Author:   djulien@thejuliens.net, (c)2021 djulien@thejuliens.net
                      00007 ; Device:   PIC16F15313 (midrange Microchip 8-pin PIC) or equivalent running @8 MIPS
                      00008 ; Peripherals used: Timer0, Timer1 (gated), Timer2, no-MSSP, EUSART, no-PWM, CLC
                      00009 ; Compiler: mpasmx(v5.35), NOT pic-as; NOTE: custom build line is used for source code fixups
                      00010 ; IDE:      MPLABX v5.35 (last one to include mpasm)
                      00011 ; Description:
                      00012 ;   WS281X-Splitter can be used for the following purposes:
                      00013 ;   1. split a single WS281X data stream into <= 4 separate segments; 
                      00014 ;     creates a virtual daisy chain of LED strings instead of using null pixels between
                      00015 ;   2. debugger or signal integrity checker; show 24-bit WS pixel data at end of string
                      00016 ;   3. timing checker; display frame rate (FPS received); alternating color is used as heartbeat
                      00017 ; Build instructions:
                      00018 ;no   ?Add this line in the project properties box, pic-as Global Options -> Additional options:
                      00019 ;no   -Wa,-a -Wl,-pPor_Vec=0h,-pIsr_Vec=4h
                      00020 ;   - use PICKit2 or 3 or equivalent programmer (PICKit2 requires PICKitPlus for newer PICs)
                      00021 ; Wiring:
                      00022 ;  RA0 = debug output (32 px WS281X):
                      00023 ;        - first 24 px shows segment 1/2/3 quad px length (0 = 1K)
                      00024 ;        - next 8 px = FPS (255 max), msb first
                      00025 ;  RA1 = output segment 1
                      00026 ;  RA2 = output segment 2
                      00027 ;  RA3 = WS281X input stream
                      00028 ;        - first/second/third byte = segment 1/2/3 quad pixel length
                      00029 ;        - first segment data follows immediately
                      00030 ;  RA4 = output segment 4; receives anything after segment 1/2/3
                      00031 ;  RA5 = output segment 3
                      00032 ; TODO:
                      00033 ;  - use PPS to set RA3 as segment 3 out and RA5 as WS input?
                      00034 ;  - uart bootloader; ground segment 0 out to enable? auto-baud detect; verify
                      00035 ;  - custom pixel dup/skip, enforce max brightness limit?
                      00036 ;================================================================================
Message[301]: MESSAGE: (hoist 0: generic pic/asm helpers @3219)
Message[301]: MESSAGE: (TODO: fix this ^^^ vvv)
Message[301]: MESSAGE: (end of hoist 0 @3737)
Message[301]: MESSAGE: (no hoist, app config/defs @__LINE__)
                          M         exitm
                      00050 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                      00051 
                      00052 ;//compile-time options:
                      00053 ;#define BITBANG; //dev/test only
                      00054 ;;#define SPI_TEST
                      00055 #define WANT_DEBUG; //DEV/TEST ONLY!
                      00056 ;#define WANT_ISR; //ISR not used; uncomment to reserve space for ISR (or jump to)
                      00057 #define WSBIT_FREQ  (800 KHz); //WS281X "high" speed
                      00058 #define WSLATCH  (50 -20 usec); //end-of-frame latch time; "cheat" by using shorter interval and use the
                             extra time for processing overhead
MPASM 5.87  /HOME/DJ/MPLABXPROJECTS/WSSPLITT   12-5-2021  23:02:33         PAGE  2
WS281X-Splitter - WS281X segment splitter/breakout/debug for Microchip PIC

LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00059 ;#define MAX_THREADS  2; //anim xmit or frame rcv, breakout xmit
                      00060 #define FOSC_FREQ  (32 MHz); //max speed; NOTE: SPI 3x requires max speed, otherwise lower speed might w
                            ork
                      00061 
                      00062 ;//pin assignments:
                      00063 #define WSDI  RA3; //RA3 = WS input stream (from controller or previous WS281X pixels)
                      00064 #define BREAKOUT  RA0; //RA0 = WS breakout pixels, or simple LED for dev/debug
                      00065 #define LEDOUT  IIFDEBUG(SEG4OUT, -1); //RA5 = simple LED output; ONLY FOR DEV/DEBUG
                      00066 ;#define WSCLK  4-2; //RA4 = WS input clock (recovered from WS input data signal); EUSART sync rcv clock
                             needs a real I/O pin?
                      00067 #define SEG1OUT  RA1; //RA1 = WS output segment 1
                      00068 #define SEG2OUT  RA2; //RA2 = WS output segment 2
                      00069 #define SEG3OUT  RA#v(3+2); //RA5 = WS output segment 3; RA3 is input-only, use alternate pin for segmen
                            t 3
                      00070 #define SEG4OUT  RA4; //RA4 = WS output segment 4
                      00071 ;#define RGSWAP  0x321; //3 = R, 2 = G, 1 = B; default = 0x321 = RGB
                      00072 #define RGSWAP  0x231; //3 = R, 2 = G, 1 = B; default = 0x321 = RGB
                      00073 ;//             default    test strip
                      00074 ;//order 0x123: RGBYMCW => BRGMCYW
                      00075 ;//order 0x132: RGBYMCW => RBGMYCW
                      00076 ;//order 0x213: RGBYMCW => BGRCMYW
                      00077 ;//order 0x231: RGBYMCW => RGBYMCW ==
                      00078 ;//order 0x312: RGBYMCW => GBRCYMW
                      00079 ;//order 0x321: RGBYMCW => GRBYCMW
Message[301]: MESSAGE: ([TODO] R is sending blue(3rd byte), G is sending red(first byte), B is sending green(second byte))
                      00080  messg [TODO] R is sending blue(3rd byte), G is sending red(first byte), B is sending green(second byte)
                      00081 ;test strip is GRB order
                      00082 
Message[301]: MESSAGE: (end of !hoist @__LINE__)
Message[301]: MESSAGE: (hoist 1: custom opc @1761)
Message[301]: MESSAGE: ([INFO] COMPILED FOR DEV/DEBUG! @1775)
  80000000                M ASM_MSB EQU -2147483648
0000                      M     ORG 0
                          M     nop_multi 1
0000   0000               M     nop
Message[301]: MESSAGE: (end of hoist 1 @3215)
Message[301]: MESSAGE: (hoist 2: cooperative multi-tasking ukernel @1241)
0001                      M     ORG ctx_addr_1
                          M     clrf_tracker PCLATH
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK PCLATH
0001   018A               M     clrf PCLATH
0002   2807               M     goto init_2
0007                      M     ORG ctx_addr_2
0007                      M init_2:
                      01667     iopin_init;
                          M     mov8 ANSELA, LITERAL(0); ; //all digital; CAUTION: do this before pin I/O
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND  ;reduce clutter
                          M ;    if (SRC == DEST) && ((srcbytes) == (destbytes)) && !(reverse)  ;nothing to do
  0000                    M     LOCAL SRC = (ASM_MSB | (0)) ;kludge; force eval (avoids "missing operand" and "missing argument" errors/MPASM bugs); also helps avoid "line too long" messages (MPASM li
  1F38                    M     LOCAL DEST = ANSELA ;kludge; force eval (avoids "missing operand" and "missing argument" errors/MPASM bugs); also helps avoid "line too long" messages (MPASM limit 200)
                          M     WARNIF(DEST == SRC, [WARNING] useless mov8 from ANSELA to (ASM_MSB | (0)) @2201);;
                          M ;    messg "mov8", #v(DEST), #v(SRC), #v(ISLIT(SRC)), #v(LIT2VAL(SRC)) @2202
                          M ;    messg src, dest @2203;
                          M     if ISLIT(SRC)  ;unpack SRC bytes
                          M ; messg dest, #v(!LIT2VAL(SRC)), #v(DEST != WREG), #v(!(DEST & INDF0_special)), #v(!(DEST & INDF1_special)) @2205
                          M         if !LIT2VAL(SRC) && (DEST != WREG) && !(DEST & INDF0_special) && !(DEST & INDF1_special)
                          M ;           BANKCHK dest;
                          M ;           BANKSAFE clrf dest; special case
                          M ;           EMIT CLRF dest;
                          M             CLRF ANSELA;
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK ANSELA
0007   017E               M     banksel ANSELA
0008   01B8               M     clrf ANSELA
0009   3008               M     movlw (((ASM_MSB | ((1 << (RA3))))) & ~ASM_MSB)
000A   00B9               M     movwf WPUA
000B   0140               M     banksel LATA
000C   0198               M     clrf LATA
000D   0092               M     movwf TRISA
000E   0151               M     banksel OSCCON3
                          M     withbit_7 bcf OSCCON3
000F   138F               M     bcf OSCCON3, 7
0010   3060               M     movlw (((ASM_MSB | (b'110' << NOSC0 | 0 << NDIV0))) & ~ASM_MSB)
0011   008D               M     movwf OSCCON1
0012   3006               M     movlw (((ASM_MSB | (HFFRQ_32000000))) & ~ASM_MSB)
0013   0093               M     movwf OSCFRQ
0014   307F               M     movlw (((ASM_MSB | (0xFF ^ (1 << (SYSCMD))))) & ~ASM_MSB)
0015   014F               M     banksel PMD0
0016   0096               M     movwf PMD0
0017   30F8               M     movlw (((ASM_MSB | (0xFF ^ (1 << (TMR2MD)) ^ (1 << (TMR1MD)) ^ (1 << (TMR0MD))))) & ~ASM_MSB)
0018   0097               M     movwf PMD1
0019   30FF               M     movlw (((ASM_MSB | (0xFF))) & ~ASM_MSB)
001A   0098               M     movwf PMD2
001B   0099               M     movwf PMD3
001C   30BF               M     movlw (((ASM_MSB | (0xFF ^ (1 << (UART1MD))))) & ~ASM_MSB)
001D   009A               M     movwf PMD4
001E   019B               M     clrf PMD5
Message[301]: MESSAGE: ([TODO] use RSTOSC HFINT 1MHz? @1707)
Message[301]: MESSAGE: ([TODO] boot loader + LVP? @1726)
8007   178C           01738     __config _CONFIG1, MY_CONFIG1
8008   2FFE           01739     __config _CONFIG2, MY_CONFIG2
8009   3F9F           01740     __config _CONFIG3, MY_CONFIG3
800A   1FFF           01741     __config _CONFIG4, MY_CONFIG4
800B   3FFF           01742     __config _CONFIG5, MY_CONFIG5
Message[301]: MESSAGE: (end of hoist 2 @1757)
Message[301]: MESSAGE: (hoist 3: app helpers @643)
Message[301]: MESSAGE: ([INFO] uart 16-bit brg ((32 * 1000000) / (2400 * 1000) / 4 - 1)) = 2 @769)
Message[301]: MESSAGE: ([DEBUG] rgb order 0x231, R = 1, G = 2, B = 0 @819)
Message[301]: MESSAGE: ([INFO] reversing breakout bit order (EUSART sends lsb first) @934)
Message[301]: MESSAGE: (end of hoist 3 @1237)
Message[301]: MESSAGE: (hoist 5: brkout render thread @401)
                          M         exitm
                      00404 ;; breakout render thread ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                      00405     
                      00406 ;RGB color indexes:
                      00407 ;3 lsb control R/G/B on/off (for easier color combinations/debug):
                      00408 ;4th bit is brightness
  0004                00409     CONSTANT RED_RGBINX = 4;
  0002                00410     CONSTANT GREEN_RGBINX = 2;
  0001                00411     CONSTANT BLUE_RGBINX = 1;
                      00412 #define BRIGHT(rgb)  ((rgb) + 8); brighter variant
  0006                00413     CONSTANT YELLOW_RGBINX = RED_RGBINX | GREEN_RGBINX;
  0003                00414     CONSTANT CYAN_RGBINX = GREEN_RGBINX | BLUE_RGBINX;
  0005                00415     CONSTANT MAGENTA_RGBINX = RED_RGBINX | BLUE_RGBINX;
  0005                00416     CONSTANT PINK_RGBINX = MAGENTA_RGBINX; easier to spell :P
  0007                00417     CONSTANT WHITE_RGBINX = RED_RGBINX | GREEN_RGBINX | BLUE_RGBINX;
  0000                00418     CONSTANT OFF_RGBINX = 0; "black"
  0008                00419     CONSTANT CUSTOM_RGBINX = BRIGHT(0); ; caller-defined palette entry
                      00420 ;0, B, G, C, R, M, Y, W
                      00421 
                      00422 ;indexed color palette:
                      00423 ;palette consists of 15 hard-coded colors + 1 caller-defined custom color
                      00424     nbDCL24 ccolor; caller-defined custom color
                          M     CBLOCK NEXT_RAM9999; BOOL2INT(banked))  ;continue where we left off last time
  00000070                M         ccolor :3
                          M     ENDC  ;can't span macros
  0071                    M     CONSTANT ccolor0mid = ccolor + 1
  0072                    M     CONSTANT ccolor0hi = ccolor + 2
                      00425 ;use EQU to show 32 bit values in .LST
                      00426 ;primary colors (dim):
  80000000            00427 PALETTE_0              EQU LITERAL(0); ; off
  80020000            00428 PALETTE_4              EQU LITERAL(0x020000); ; red dim
  80000200            00429 PALETTE_2                EQU LITERAL(0x000200); ; green dim
  80010100            00430 PALETTE_6                 EQU LITERAL(0x010100); ; yellow dim; try to keep consistent brightness with single colors
  80000002            00431 PALETTE_1               EQU LITERAL(0x000002); ; blue dim
  80010001            00432 PALETTE_5                  EQU LITERAL(0x010001); ; magenta dim; try to keep consistent brightness with single colors
  80000101            00433 PALETTE_3               EQU LITERAL(0x000101); ; cyan dim; try to keep consistent brightness with single colors
  80010101            00434 PALETTE_7                EQU LITERAL(0x010101); ; white dim; try to keep consistent brightness with single colors
                      00435 ;primary colors (bright):
  80FF0000            00436 PALETTE_12                     EQU LITERAL(0xFF0000); ; red bright
  8000FF00            00437 PALETTE_10                       EQU LITERAL(0x00FF00); ; green bright
  80808000            00438 PALETTE_14                        EQU LITERAL(0x808000); ; yellow bright; try to keep consistent brightness with single colors
  800000FF            00439 PALETTE_9                       EQU LITERAL(0x0000FF); ; blue bright
  80800080            00440 PALETTE_13                         EQU LITERAL(0x800080); ; magenta bright; try to keep consistent brightness with single colors
  80008080            00441 PALETTE_11                      EQU LITERAL(0x008080); ; cyan bright; try to keep consistent brightness with single colors
  80555555            00442 PALETTE_15                       EQU LITERAL(0x555555); ; white dim; try to keep consistent brightness with single colors
  00000070            00443 PALETTE_8                 EQU ccolor; caller-defined palette entry
                      00444 
                      00445 
                      00446 ;display buffer:
                      00447 ;#define NUMPX  #v(24 + 8); 24 px for first wspixel received + 8 px for fps
                      00448 ;    b0DCL brkoutpx:#v(NUMPX/2); 1 nibble per pixel (color indexed); FSR# handles banking
                      00449     b0DCL brkoutpx,:(24 + 8) / 1; 1/2 byte per pixel (color indexed): 24px for first rcv pixel + 8 px for fps; FSR# handles banking
                          M     CBLOCK NEXT_RAM0; BOOL2INT(banked))  ;continue where we left off last time
  00000020                M         brkoutpx :(24 + 8) / 1
                          M     ENDC  ;can't span macros
                      00450     find_msb ENDOF(brkoutpx);;
                          M             exitm
                      00451 ;    messg #v(FOUND_MSB), #v(ENDOF(brkoutpx)) @451
                      00452 ;TODO? 4 bpp, 2 px/byte
                      00453 ;TODO? linear addr?
                      00454 ;check if fsr is at breakout eof:
                      00455 ;CAUTION: uses linear addr + assumes power of 2
                      00456 ;#define END_DETECT  SIZEOF(brkoutpx); (0x20 + 24+8); 0X40; BIT(5); CAUTION: only works with power of 2
                      00457     if ENDOF(brkoutpx) == FOUND_MSB; can use single-bit check
                      00458 #define breakout_eof(yesno)  log2(ENDOF(brkoutpx)), IIF(brkoutpx & ENDOF(brkoutpx), !(yesno), yesno); BOOL2INT(brkoutpx & ENDOF(brkoutpx)) ^ BOOL2INT(yesno)
Message[301]: MESSAGE: ([INFO] #brkout pxbuf 32 @32, eof@ 64, detect& 0 @459)
                      00459     messg [INFO] #brkout pxbuf 32                   @32,           eof@ 64,                  detect& 0                              @459
                      00460 ;    ERRIF((ENDOF(brkoutpx) - 1) & END_DETECT == ENDOF(brkoutpx) & END_DETECT, [ERROR] pixelbuf end detect broken, !span #v(END_DETECT): #v(brkoutpx) @460)
                      00461 ;    messg ENDOF(brkoutpx) #v(ENDOF(brkoutpx))
                      00462 ;    messg log2(ENDOF(brkoutpx)) #v(log2(ENDOF(brkoutpx)))
                      00463 ;    messg ENDOF(brkoutpx), #v(ENDOF(brkoutpx))
                      00464     ERRIF(!log2(ENDOF(brkoutpx)), [ERROR] breakout pxbuf end detect !power of 2: 64","                  simple bit test won''t work @464)
                      00465 #else
                      00466     error TODO: brkoupx eof check: 64                  @466
                      00467 #endif
                      00468 
                      00469 ;#define render_busy(yesno)  mov16 FSR0, LITERAL(IIF(yesno, brkoutpx, ENDOF(brkoutpx)))
                      00470 render_busy macro yesno
                      00471     if !(yesno) && (ENDOF(brkoutpx) == FOUND_MSB); use single-bit check
                      00472         setbit FSR0L, breakout_eof(TRUE); just set eof bit (faster than setting entire FSR0)
                      00473         exitm
                      00474     endif
                      00475     mov16 FSR0, LITERAL(IIF(yesno, brkoutpx, ENDOF(brkoutpx)))
                      00476     endm
                      00477 
                      00478 wait2render macro idler, idler2
                      00480 ;    ifbit FSR0L, breakout_eof(TRUE), idler; goto brkout_wait; log2(64), !((brkoutpx + 32) & 64), goto brkout_loop; nothing to send
                      00481     idler; assume not ready yet, let other threads run
                      00482     ifbit FSR0L, breakout_eof(TRUE), idler2; goto brkout_wait; log2(64), !((brkoutpx + 32) & 64), goto brkout_loop; nothing to send
                      00484     endm
                      00485 
                      00486 ;swap a pair of pixels:
                      00487 swap_pair macro ofs
                      00488     swapreg brkoutpx + ofs, brkoutpx + (ofs ^ 1)
                      00489     endm
                      00490 
                      00491 ;brkoutpx initial state:
                      00492 ;    more_init TRUE;
                      00493 ;    mov16 FSR0, LITERAL(brkoutpx);
                      00494 ;    movlw OFF_RGBINX;
                      00495 ;brkout_initloop:
                      00496 ;    mov8 INDF0_postinc, WREG;
                      00497 ;    ifbit FSR0L, breakout_eof(FALSE), goto brkout_initloop;
                      00498 ;    more_init FALSE
                      00499 
                      00500 ;breakout byte pixel colors:
                      00501 ;#define FPS_RGBINX  CYAN_RGBINX
                      00502 ;    CONSTANT BRKOUT#v(0)_RGBINX  RED_RGBINX; first byte
                      00503 ;    CONSTANT BRKOUT#v(1)_RGBINX  GREEN_RGBINX; second byte
                      00504 ;    CONSTANT BRKOUT#v(2)_RGBINX  BLUE_RGBINX; third byte
                      00505 ;    CONSTANT BRKOUT#v(3)_RGBINX  CYAN_RGBINX; FPS
                      00506 ;    CONSTANT BRKOUT#v(4)_RGBINX  MAGENTA_RGBINX; alternate FPS (heartbeat)
                      00507 
                      00508     
                      00509     THREAD_DEF brkout_render, 4
                          M     CBLOCK NEXT_RAM9999; BOOL2INT(banked))  ;continue where we left off last time
  00000073                M         stkptr_0 
                          M     ENDC  ;can't span macros
Message[301]: MESSAGE: (creating brkout_render thread# 0 @32, stack size 4, host stack remaining: 12 @1294)
0020   017F               M     banksel STKPTR
                          M     withdest_0 movf STKPTR
0021   086D               M     movf STKPTR, W;
0022   00F3               M     movwf stkptr_0
0026   0008               M     return
001F                      M     ORG ctx_addr_3
001F   2827               M     goto init_3
0027                      M     ORG ctx_addr_5
0027                      M init_3:
0027   202A               M     call stack_alloc_0
0028   2030               M     call brkout_render
0029   2823               M     goto yield_again
002A   017F               M     banksel STKPTR
                          M     withdest_0 movf STKPTR
002B   086D               M     movf STKPTR, W;
002C   00F3               M     movwf stkptr_0
002D   3003               M     movlw 4 - 1
                          M     withdest_1 addwf STKPTR
002E   07ED               M     addwf STKPTR, F;
Message[301]: MESSAGE: ([DEBUG] 8173 @1386)
                      00510 
                      00511 #if 0; uses a lot of prog space
                      00512 ;send palette entry to next WS pixel:
                      00513     VARIABLE palinx = 0;
                      00514     while palinx < 16
                      00515 ws_send_pal0:          DROP_CONTEXT;
                      00516         ws_send_px PALETTE_0,          TRUE, YIELD, YIELD_AGAIN; 3x3 bytes
                      00517         return;
                      00518 palinx += 1;
                      00519     endw
                      00520 ;in: WREG contains color index (4-bit value); caller can pack 2/byte if desired
                      00521 ws_send_palette: DROP_CONTEXT
                      00522     andlw 0x0F;
                      00523     brw;
                      00524     while palinx < 16+16
                      00525         goto ws_send_pal0; 3x3 bytes
                      00526 palinx += 1;
                      00527     endw
                      00528 #endif
                      00529 ;want expand to:
                      00530 ;repeat:
                      00531 ;;    ifbit xmit_ready(TRUE), goto around
                      00532 ;;    YIELD;
                      00533 ;;    ifbit xmit_ready(FALSE), YIELD_AGAIN; more efficient than goto $-3 + call
                      00534 ;;    dont-goto repeat
                      00535 ;;around:
                      00536 ;    ifbit xmit_ready(FALSE), YIELD;
                      00537 ;    ifbit xmit_ready(FALSE), YIELD_AGAIN; more efficient than goto $-3 + call
                      00538     
                      00539 ;in: WREG = palinx
                      00540 ;piece:
                      00541 ;  1, 2, 3 to get entire byte
                      00542 ;or 1/3, 2/3, 3/3 to get SPI3x-encoded piece of byte
                      00543 ;unneeded: get_palent_byte macro piece
                      00544 ;    andlw 0x0F;
                      00545 ;    brw
                      00546 ;    LOCAL WHICH = SPI3x_detect(piece); 1, 2, 4 (SPI3x pieces) or 3, 6, 12 (bytes)
                      00547 ;    LOCAL palinx = 0
                      00548 ;    while palinx < 15
                      00549 ;       if !(WHICH % 3); whole byte
                      00550 ;           retlw BYTEOF(PALETTE_#v(palinx), (piece) - 1);
                      00551 ;       else; partial byte
                      00552 ;           ws_encbyte BYTE, 2/3; before wait so it's ready
                      00553 ;    messg TODO: ^^^ needs work @553
                      00554 ;           return;
                      00555 ;       endif
                      00556 ;    endm
                      00557 
                      00558 ;    init_more TRUE
                      00559 ;    ws_breakout_setup;
                      00560 ;    init_more FALSE;
                      00561 
                      00562 brkout_fill macro color
                      00563     mov16 FSR1, LITERAL(brkoutpx);
                      00564     MOVLW color;
                      00565     whilebit FSR1L, breakout_eof(FALSE), MOVWF INDF1_postinc;
                      00566     endm
                      00567 
                      00568 ;use FSR0 to send breakout, leave FSR1 for caller to use for animation or render
                      00569 brkout_render: DROP_CONTEXT;
                      00570     ws_breakout_setup; eusart init @SPI 3x (2.4 Mbps)
0030   3010               M     movlw (((ASM_MSB | (0x10))) & ~ASM_MSB)
0031   017E               M     banksel RA0PPS
0032   0090               M     movwf RA0PPS
0033   017D               M     banksel RX1DTPPS
0034   01CB               M     clrf RX1DTPPS
0035   3003               M     movlw (((ASM_MSB | (RA3))) & ~ASM_MSB)
0036   00CC               M     movwf TX1CKPPS
Message[301]: MESSAGE: (TODO: ^^^ are these 2 needed?)
0037   0140               M     banksel TRISA
                          M     withbit_0 bsf TRISA
0038   1412               M     bsf TRISA, 0;
0039   301A               M     movlw (((ASM_MSB | (0x20 * 10/12))) & ~ASM_MSB)
003A   0151               M     banksel OSCTUNE
003B   0092               M     movwf OSCTUNE
003C   0142               M     banksel RC1STA
003D   019D               M     clrf RC1STA
003E   30B4               M     movlw (((ASM_MSB | ((1 << (CSRC)) | 0 | (1 << (TXEN)) | (1 << (SYNC_TXSTA)) | (1 << (BRGH))))) & ~ASM_MSB)
003F   009E               M     movwf TX1STA
0040   3008               M     movlw (((ASM_MSB | (0 | (1 << (BRG16))))) & ~ASM_MSB)
0041   009F               M     movwf BAUD1CON
0042   3002               M     movlw (((ASM_MSB | (_830SRC & 0xFF))) & ~ASM_MSB)
0043   009B               M     movwf SP1BRG
0044   019C               M     clrf SP1BRG0hi
                          M     withbit_7 bsf RC1STA
0045   179D               M     bsf RC1STA, 7
                      00571     render_busy(FALSE); ; set empty outbuf
                          M     withbit_6 bsf FSR0L
0046   1704               M     bsf FSR0L, 6
                          M         exitm
                      00572 ;    mov16 FSR0, LITERAL(ENDOF(brkoutpx)); set empty outbuf
                      00573 brkout_loop: DROP_CONTEXT;
                      00574 ;    setbit LATA, BREAKOUT, TRUE;
                      00575 ;    wait4frame YIELD, YIELD_AGAIN; 1 sec
                      00576 ;    NOP 16
                      00577 ;    setbit LATA, BREAKOUT, FALSE;
                      00578 ;    wait4frame YIELD, YIELD_AGAIN; 1 sec
                      00579 ;    NOP 16
                      00580 ;    ifbit FSR0L, breakout_eof(TRUE), YIELD; goto brkout_wait; log2(64), !((brkoutpx + 32) & 64), goto brkout_loop; nothing to send
                      00581 ;    ifbit FSR0L, breakout_eof(TRUE), YIELD_AGAIN; goto brkout_wait; log2(64), !((brkoutpx + 32) & 64), goto brkout_loop; nothing to send
                      00582     wait2render YIELD, YIELD_AGAIN; only yield 1x/breakout px; this prevents unexpected gaps during WS xmit (better tolerated *between* WS px); breakout px only needs to be
0047   2020               M     call yield
                          M     goto_pagesafe yield_again
                          M ;    EXPAND_PUSH FALSE
                          M ; messg here1 @3079
                          M     ERRIF(LITPAGEOF(yield_again), [ERROR] "dest" yield_again 35 !on page 0: 0           @3080)
                          M ; messg here2 @3081
                          M ;PAGESEL_DROP += 1
                          M ;    messg goto dest, page tracker #v(PAGE_TRACKER), need page sel? #v(LITPAGEOF(dest)) != #v(LITPAGEOF(PAGE_TRACKER))? #v(LITPAGEOF(dest) != LITPAGEOF(PAGE_TRACKER))
                          M     if LITPAGEOF(yield_again) != LITPAGEOF(PAGE_TRACKER)
                          M         EMIT CLRF PCLATH; PAGESEL dest; kludge: mpasm doesn't want to pagesel
                          M PAGESEL_KEEP += 1
                          M     else
  00000006                M PAGESEL_DROP += 1
                          M     endif
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M ; messg here3 @3091
                          M     EMIT goto yield_again; PROGDCL 0x2000 | (dest); call dest
0049   2823               M     goto yield_again
  00000023                M PAGE_TRACKER = yield_again;
                          M ; messg here4 @3094
                          M ;    NOEXPAND
                          M ;not needed: fall-thru would be handled by earlier code    DROP_CONTEXT; BSR and WREG unknown here if dest falls through
                          M ;    EXPAND_POP
0048                      M     ORG ctx_addr_7
004A                      M     ORG ctx_addr_8
  0000                00583     VARIABLE pxpiece = 0;
                      00584     while pxpiece < 3*3; each px takes 9 bytes (3 rgb bytes * 3 SPI bytes)
                      00585 ;        wait2xmit YIELD, YIELD_AGAIN; wait before loading WREG to avoid save/restore
                      00586         mov8 WREG, IIF(pxpiece == 9-1, INDF0_postinc, INDF0);;
                          M     withdest_0 movf (INDF0)
004A   0800               M     movf (INDF0), W;
                      00587         CALL get_palent_encpiece_0;
004B   208A               M     call get_palent_encpiece_0
                      00588 ;        ws_send_byte WREG, TRUE, YIELD, YIELD_AGAIN;
                      00589 ;       ws_encbyte BYTE, 2/3; after wait to protect WREG, but might cause latency
                      00590         whilebit xmit_ready(FALSE), NULL_STMT; CAUTION: TX1IF !valid until 2 instr after TX1REG; do next byte prep first
004C                      M _975loop:
004C   014E               M     banksel PIR3
004F                      M     ORG $
004D                      M     ORG ctx_addr_9
                          M     goto_pagesafe _975before_idler
                          M ;    EXPAND_PUSH FALSE
                          M ; messg here1 @3079
                          M     ERRIF(LITPAGEOF(_975before_idler), [ERROR] "dest" _975before_idler 77 !on page 0: 0 @3080)
                          M ; messg here2 @3081
                          M ;PAGESEL_DROP += 1
                          M ;    messg goto dest, page tracker #v(PAGE_TRACKER), need page sel? #v(LITPAGEOF(dest)) != #v(LITPAGEOF(PAGE_TRACKER))? #v(LITPAGEOF(dest) != LITPAGEOF(PAGE_TRACKER))
                          M     if LITPAGEOF(_975before_idler) != LITPAGEOF(PAGE_TRACKER)
                          M         EMIT CLRF PCLATH; PAGESEL dest; kludge: mpasm doesn't want to pagesel
                          M PAGESEL_KEEP += 1
                          M     else
  00000008                M PAGESEL_DROP += 1
                          M     endif
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M ; messg here3 @3091
                          M     EMIT goto _975before_idler; PROGDCL 0x2000 | (dest); call dest
004E   284D               M     goto _975before_idler
  0000004D                M PAGE_TRACKER = _975before_idler;
                          M ; messg here4 @3094
                          M ;    NOEXPAND
                          M ;not needed: fall-thru would be handled by earlier code    DROP_CONTEXT; BSR and WREG unknown here if dest falls through
                          M ;    EXPAND_POP
004D                      M     ORG ctx_addr_11
004F                      M     ORG ctx_addr_12
004F                      M _975around:
                      00591         mov8 TX1REG, WREG; start xmit
004F   0142               M     banksel TX1REG
0050   009A               M     movwf TX1REG
  00000001            00592 pxpiece += 1
                      00585 ;        wait2xmit YIELD, YIELD_AGAIN; wait before loading WREG to avoid save/restore
                      00586         mov8 WREG, IIF(pxpiece == 9-1, INDF0_postinc, INDF0);;
                          M     withdest_0 movf (INDF0)
0051   0800               M     movf (INDF0), W;
                      00587         CALL get_palent_encpiece_1;
0052   20A4               M     call get_palent_encpiece_1
                      00588 ;        ws_send_byte WREG, TRUE, YIELD, YIELD_AGAIN;
                      00589 ;       ws_encbyte BYTE, 2/3; after wait to protect WREG, but might cause latency
                      00590         whilebit xmit_ready(FALSE), NULL_STMT; CAUTION: TX1IF !valid until 2 instr after TX1REG; do next byte prep first
0053                      M _1092loop:
0053   014E               M     banksel PIR3
0056                      M     ORG $
0054                      M     ORG ctx_addr_13
                          M     goto_pagesafe _1092before_idler
                          M ;    EXPAND_PUSH FALSE
                          M ; messg here1 @3079
                          M     ERRIF(LITPAGEOF(_1092before_idler), [ERROR] "dest" _1092before_idler 84 !on page 0: 0 @3080)
                          M ; messg here2 @3081
                          M ;PAGESEL_DROP += 1
                          M ;    messg goto dest, page tracker #v(PAGE_TRACKER), need page sel? #v(LITPAGEOF(dest)) != #v(LITPAGEOF(PAGE_TRACKER))? #v(LITPAGEOF(dest) != LITPAGEOF(PAGE_TRACKER))
                          M     if LITPAGEOF(_1092before_idler) != LITPAGEOF(PAGE_TRACKER)
                          M         EMIT CLRF PCLATH; PAGESEL dest; kludge: mpasm doesn't want to pagesel
                          M PAGESEL_KEEP += 1
                          M     else
  0000000A                M PAGESEL_DROP += 1
                          M     endif
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M ; messg here3 @3091
                          M     EMIT goto _1092before_idler; PROGDCL 0x2000 | (dest); call dest
0055   2854               M     goto _1092before_idler
  00000054                M PAGE_TRACKER = _1092before_idler;
                          M ; messg here4 @3094
                          M ;    NOEXPAND
                          M ;not needed: fall-thru would be handled by earlier code    DROP_CONTEXT; BSR and WREG unknown here if dest falls through
                          M ;    EXPAND_POP
0054                      M     ORG ctx_addr_15
0056                      M     ORG ctx_addr_16
0056                      M _1092around:
                      00591         mov8 TX1REG, WREG; start xmit
0056   0142               M     banksel TX1REG
0057   009A               M     movwf TX1REG
  00000002            00592 pxpiece += 1
                      00585 ;        wait2xmit YIELD, YIELD_AGAIN; wait before loading WREG to avoid save/restore
                      00586         mov8 WREG, IIF(pxpiece == 9-1, INDF0_postinc, INDF0);;
                          M     withdest_0 movf (INDF0)
0058   0800               M     movf (INDF0), W;
                      00587         CALL get_palent_encpiece_2;
0059   20BC               M     call get_palent_encpiece_2
                      00588 ;        ws_send_byte WREG, TRUE, YIELD, YIELD_AGAIN;
                      00589 ;       ws_encbyte BYTE, 2/3; after wait to protect WREG, but might cause latency
                      00590         whilebit xmit_ready(FALSE), NULL_STMT; CAUTION: TX1IF !valid until 2 instr after TX1REG; do next byte prep first
005A                      M _1209loop:
005A   014E               M     banksel PIR3
005D                      M     ORG $
005B                      M     ORG ctx_addr_17
                          M     goto_pagesafe _1209before_idler
                          M ;    EXPAND_PUSH FALSE
                          M ; messg here1 @3079
                          M     ERRIF(LITPAGEOF(_1209before_idler), [ERROR] "dest" _1209before_idler 91 !on page 0: 0 @3080)
                          M ; messg here2 @3081
                          M ;PAGESEL_DROP += 1
                          M ;    messg goto dest, page tracker #v(PAGE_TRACKER), need page sel? #v(LITPAGEOF(dest)) != #v(LITPAGEOF(PAGE_TRACKER))? #v(LITPAGEOF(dest) != LITPAGEOF(PAGE_TRACKER))
                          M     if LITPAGEOF(_1209before_idler) != LITPAGEOF(PAGE_TRACKER)
                          M         EMIT CLRF PCLATH; PAGESEL dest; kludge: mpasm doesn't want to pagesel
                          M PAGESEL_KEEP += 1
                          M     else
  0000000C                M PAGESEL_DROP += 1
                          M     endif
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M ; messg here3 @3091
                          M     EMIT goto _1209before_idler; PROGDCL 0x2000 | (dest); call dest
005C   285B               M     goto _1209before_idler
  0000005B                M PAGE_TRACKER = _1209before_idler;
                          M ; messg here4 @3094
                          M ;    NOEXPAND
                          M ;not needed: fall-thru would be handled by earlier code    DROP_CONTEXT; BSR and WREG unknown here if dest falls through
                          M ;    EXPAND_POP
005B                      M     ORG ctx_addr_19
005D                      M     ORG ctx_addr_20
005D                      M _1209around:
                      00591         mov8 TX1REG, WREG; start xmit
005D   0142               M     banksel TX1REG
005E   009A               M     movwf TX1REG
  00000003            00592 pxpiece += 1
                      00585 ;        wait2xmit YIELD, YIELD_AGAIN; wait before loading WREG to avoid save/restore
                      00586         mov8 WREG, IIF(pxpiece == 9-1, INDF0_postinc, INDF0);;
                          M     withdest_0 movf (INDF0)
005F   0800               M     movf (INDF0), W;
                      00587         CALL get_palent_encpiece_3;
0060   20D6               M     call get_palent_encpiece_3
                      00588 ;        ws_send_byte WREG, TRUE, YIELD, YIELD_AGAIN;
                      00589 ;       ws_encbyte BYTE, 2/3; after wait to protect WREG, but might cause latency
                      00590         whilebit xmit_ready(FALSE), NULL_STMT; CAUTION: TX1IF !valid until 2 instr after TX1REG; do next byte prep first
0061                      M _1326loop:
0061   014E               M     banksel PIR3
0064                      M     ORG $
0062                      M     ORG ctx_addr_21
                          M     goto_pagesafe _1326before_idler
                          M ;    EXPAND_PUSH FALSE
                          M ; messg here1 @3079
                          M     ERRIF(LITPAGEOF(_1326before_idler), [ERROR] "dest" _1326before_idler 98 !on page 0: 0 @3080)
                          M ; messg here2 @3081
                          M ;PAGESEL_DROP += 1
                          M ;    messg goto dest, page tracker #v(PAGE_TRACKER), need page sel? #v(LITPAGEOF(dest)) != #v(LITPAGEOF(PAGE_TRACKER))? #v(LITPAGEOF(dest) != LITPAGEOF(PAGE_TRACKER))
                          M     if LITPAGEOF(_1326before_idler) != LITPAGEOF(PAGE_TRACKER)
                          M         EMIT CLRF PCLATH; PAGESEL dest; kludge: mpasm doesn't want to pagesel
                          M PAGESEL_KEEP += 1
                          M     else
  0000000E                M PAGESEL_DROP += 1
                          M     endif
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M ; messg here3 @3091
                          M     EMIT goto _1326before_idler; PROGDCL 0x2000 | (dest); call dest
0063   2862               M     goto _1326before_idler
  00000062                M PAGE_TRACKER = _1326before_idler;
                          M ; messg here4 @3094
                          M ;    NOEXPAND
                          M ;not needed: fall-thru would be handled by earlier code    DROP_CONTEXT; BSR and WREG unknown here if dest falls through
                          M ;    EXPAND_POP
0062                      M     ORG ctx_addr_23
0064                      M     ORG ctx_addr_24
0064                      M _1326around:
                      00591         mov8 TX1REG, WREG; start xmit
0064   0142               M     banksel TX1REG
0065   009A               M     movwf TX1REG
  00000004            00592 pxpiece += 1
                      00585 ;        wait2xmit YIELD, YIELD_AGAIN; wait before loading WREG to avoid save/restore
                      00586         mov8 WREG, IIF(pxpiece == 9-1, INDF0_postinc, INDF0);;
                          M     withdest_0 movf (INDF0)
0066   0800               M     movf (INDF0), W;
                      00587         CALL get_palent_encpiece_4;
0067   20F0               M     call get_palent_encpiece_4
                      00588 ;        ws_send_byte WREG, TRUE, YIELD, YIELD_AGAIN;
                      00589 ;       ws_encbyte BYTE, 2/3; after wait to protect WREG, but might cause latency
                      00590         whilebit xmit_ready(FALSE), NULL_STMT; CAUTION: TX1IF !valid until 2 instr after TX1REG; do next byte prep first
0068                      M _1443loop:
0068   014E               M     banksel PIR3
006B                      M     ORG $
0069                      M     ORG ctx_addr_25
                          M     goto_pagesafe _1443before_idler
                          M ;    EXPAND_PUSH FALSE
                          M ; messg here1 @3079
                          M     ERRIF(LITPAGEOF(_1443before_idler), [ERROR] "dest" _1443before_idler 105 !on page 0: 0 @3080)
                          M ; messg here2 @3081
                          M ;PAGESEL_DROP += 1
                          M ;    messg goto dest, page tracker #v(PAGE_TRACKER), need page sel? #v(LITPAGEOF(dest)) != #v(LITPAGEOF(PAGE_TRACKER))? #v(LITPAGEOF(dest) != LITPAGEOF(PAGE_TRACKER))
                          M     if LITPAGEOF(_1443before_idler) != LITPAGEOF(PAGE_TRACKER)
                          M         EMIT CLRF PCLATH; PAGESEL dest; kludge: mpasm doesn't want to pagesel
                          M PAGESEL_KEEP += 1
                          M     else
  00000010                M PAGESEL_DROP += 1
                          M     endif
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M ; messg here3 @3091
                          M     EMIT goto _1443before_idler; PROGDCL 0x2000 | (dest); call dest
006A   2869               M     goto _1443before_idler
  00000069                M PAGE_TRACKER = _1443before_idler;
                          M ; messg here4 @3094
                          M ;    NOEXPAND
                          M ;not needed: fall-thru would be handled by earlier code    DROP_CONTEXT; BSR and WREG unknown here if dest falls through
                          M ;    EXPAND_POP
0069                      M     ORG ctx_addr_27
006B                      M     ORG ctx_addr_28
006B                      M _1443around:
                      00591         mov8 TX1REG, WREG; start xmit
006B   0142               M     banksel TX1REG
006C   009A               M     movwf TX1REG
  00000005            00592 pxpiece += 1
                      00585 ;        wait2xmit YIELD, YIELD_AGAIN; wait before loading WREG to avoid save/restore
                      00586         mov8 WREG, IIF(pxpiece == 9-1, INDF0_postinc, INDF0);;
                          M     withdest_0 movf (INDF0)
006D   0800               M     movf (INDF0), W;
                      00587         CALL get_palent_encpiece_5;
006E   2108               M     call get_palent_encpiece_5
                      00588 ;        ws_send_byte WREG, TRUE, YIELD, YIELD_AGAIN;
                      00589 ;       ws_encbyte BYTE, 2/3; after wait to protect WREG, but might cause latency
                      00590         whilebit xmit_ready(FALSE), NULL_STMT; CAUTION: TX1IF !valid until 2 instr after TX1REG; do next byte prep first
006F                      M _1560loop:
006F   014E               M     banksel PIR3
0072                      M     ORG $
0070                      M     ORG ctx_addr_29
                          M     goto_pagesafe _1560before_idler
                          M ;    EXPAND_PUSH FALSE
                          M ; messg here1 @3079
                          M     ERRIF(LITPAGEOF(_1560before_idler), [ERROR] "dest" _1560before_idler 112 !on page 0: 0 @3080)
                          M ; messg here2 @3081
                          M ;PAGESEL_DROP += 1
                          M ;    messg goto dest, page tracker #v(PAGE_TRACKER), need page sel? #v(LITPAGEOF(dest)) != #v(LITPAGEOF(PAGE_TRACKER))? #v(LITPAGEOF(dest) != LITPAGEOF(PAGE_TRACKER))
                          M     if LITPAGEOF(_1560before_idler) != LITPAGEOF(PAGE_TRACKER)
                          M         EMIT CLRF PCLATH; PAGESEL dest; kludge: mpasm doesn't want to pagesel
                          M PAGESEL_KEEP += 1
                          M     else
  00000012                M PAGESEL_DROP += 1
                          M     endif
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M ; messg here3 @3091
                          M     EMIT goto _1560before_idler; PROGDCL 0x2000 | (dest); call dest
0071   2870               M     goto _1560before_idler
  00000070                M PAGE_TRACKER = _1560before_idler;
                          M ; messg here4 @3094
                          M ;    NOEXPAND
                          M ;not needed: fall-thru would be handled by earlier code    DROP_CONTEXT; BSR and WREG unknown here if dest falls through
                          M ;    EXPAND_POP
0070                      M     ORG ctx_addr_31
0072                      M     ORG ctx_addr_32
0072                      M _1560around:
                      00591         mov8 TX1REG, WREG; start xmit
0072   0142               M     banksel TX1REG
0073   009A               M     movwf TX1REG
  00000006            00592 pxpiece += 1
                      00585 ;        wait2xmit YIELD, YIELD_AGAIN; wait before loading WREG to avoid save/restore
                      00586         mov8 WREG, IIF(pxpiece == 9-1, INDF0_postinc, INDF0);;
                          M     withdest_0 movf (INDF0)
0074   0800               M     movf (INDF0), W;
                      00587         CALL get_palent_encpiece_6;
0075   2122               M     call get_palent_encpiece_6
                      00588 ;        ws_send_byte WREG, TRUE, YIELD, YIELD_AGAIN;
                      00589 ;       ws_encbyte BYTE, 2/3; after wait to protect WREG, but might cause latency
                      00590         whilebit xmit_ready(FALSE), NULL_STMT; CAUTION: TX1IF !valid until 2 instr after TX1REG; do next byte prep first
0076                      M _1677loop:
0076   014E               M     banksel PIR3
0079                      M     ORG $
0077                      M     ORG ctx_addr_33
                          M     goto_pagesafe _1677before_idler
                          M ;    EXPAND_PUSH FALSE
                          M ; messg here1 @3079
                          M     ERRIF(LITPAGEOF(_1677before_idler), [ERROR] "dest" _1677before_idler 119 !on page 0: 0 @3080)
                          M ; messg here2 @3081
                          M ;PAGESEL_DROP += 1
                          M ;    messg goto dest, page tracker #v(PAGE_TRACKER), need page sel? #v(LITPAGEOF(dest)) != #v(LITPAGEOF(PAGE_TRACKER))? #v(LITPAGEOF(dest) != LITPAGEOF(PAGE_TRACKER))
                          M     if LITPAGEOF(_1677before_idler) != LITPAGEOF(PAGE_TRACKER)
                          M         EMIT CLRF PCLATH; PAGESEL dest; kludge: mpasm doesn't want to pagesel
                          M PAGESEL_KEEP += 1
                          M     else
  00000014                M PAGESEL_DROP += 1
                          M     endif
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M ; messg here3 @3091
                          M     EMIT goto _1677before_idler; PROGDCL 0x2000 | (dest); call dest
0078   2877               M     goto _1677before_idler
  00000077                M PAGE_TRACKER = _1677before_idler;
                          M ; messg here4 @3094
                          M ;    NOEXPAND
                          M ;not needed: fall-thru would be handled by earlier code    DROP_CONTEXT; BSR and WREG unknown here if dest falls through
                          M ;    EXPAND_POP
0077                      M     ORG ctx_addr_35
0079                      M     ORG ctx_addr_36
0079                      M _1677around:
                      00591         mov8 TX1REG, WREG; start xmit
0079   0142               M     banksel TX1REG
007A   009A               M     movwf TX1REG
  00000007            00592 pxpiece += 1
                      00585 ;        wait2xmit YIELD, YIELD_AGAIN; wait before loading WREG to avoid save/restore
                      00586         mov8 WREG, IIF(pxpiece == 9-1, INDF0_postinc, INDF0);;
                          M     withdest_0 movf (INDF0)
007B   0800               M     movf (INDF0), W;
                      00587         CALL get_palent_encpiece_7;
007C   213C               M     call get_palent_encpiece_7
                      00588 ;        ws_send_byte WREG, TRUE, YIELD, YIELD_AGAIN;
                      00589 ;       ws_encbyte BYTE, 2/3; after wait to protect WREG, but might cause latency
                      00590         whilebit xmit_ready(FALSE), NULL_STMT; CAUTION: TX1IF !valid until 2 instr after TX1REG; do next byte prep first
007D                      M _1794loop:
007D   014E               M     banksel PIR3
0080                      M     ORG $
007E                      M     ORG ctx_addr_37
                          M     goto_pagesafe _1794before_idler
                          M ;    EXPAND_PUSH FALSE
                          M ; messg here1 @3079
                          M     ERRIF(LITPAGEOF(_1794before_idler), [ERROR] "dest" _1794before_idler 126 !on page 0: 0 @3080)
                          M ; messg here2 @3081
                          M ;PAGESEL_DROP += 1
                          M ;    messg goto dest, page tracker #v(PAGE_TRACKER), need page sel? #v(LITPAGEOF(dest)) != #v(LITPAGEOF(PAGE_TRACKER))? #v(LITPAGEOF(dest) != LITPAGEOF(PAGE_TRACKER))
                          M     if LITPAGEOF(_1794before_idler) != LITPAGEOF(PAGE_TRACKER)
                          M         EMIT CLRF PCLATH; PAGESEL dest; kludge: mpasm doesn't want to pagesel
                          M PAGESEL_KEEP += 1
                          M     else
  00000016                M PAGESEL_DROP += 1
                          M     endif
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M ; messg here3 @3091
                          M     EMIT goto _1794before_idler; PROGDCL 0x2000 | (dest); call dest
007F   287E               M     goto _1794before_idler
  0000007E                M PAGE_TRACKER = _1794before_idler;
                          M ; messg here4 @3094
                          M ;    NOEXPAND
                          M ;not needed: fall-thru would be handled by earlier code    DROP_CONTEXT; BSR and WREG unknown here if dest falls through
                          M ;    EXPAND_POP
007E                      M     ORG ctx_addr_39
0080                      M     ORG ctx_addr_40
0080                      M _1794around:
                      00591         mov8 TX1REG, WREG; start xmit
0080   0142               M     banksel TX1REG
0081   009A               M     movwf TX1REG
  00000008            00592 pxpiece += 1
                      00585 ;        wait2xmit YIELD, YIELD_AGAIN; wait before loading WREG to avoid save/restore
                      00586         mov8 WREG, IIF(pxpiece == 9-1, INDF0_postinc, INDF0);;
0082   0012               M     MOVIW_0_2
                      00587         CALL get_palent_encpiece_8;
0083   2154               M     call get_palent_encpiece_8
                      00588 ;        ws_send_byte WREG, TRUE, YIELD, YIELD_AGAIN;
                      00589 ;       ws_encbyte BYTE, 2/3; after wait to protect WREG, but might cause latency
                      00590         whilebit xmit_ready(FALSE), NULL_STMT; CAUTION: TX1IF !valid until 2 instr after TX1REG; do next byte prep first
0084                      M _1904loop:
0084   014E               M     banksel PIR3
0087                      M     ORG $
0085                      M     ORG ctx_addr_41
                          M     goto_pagesafe _1904before_idler
                          M ;    EXPAND_PUSH FALSE
                          M ; messg here1 @3079
                          M     ERRIF(LITPAGEOF(_1904before_idler), [ERROR] "dest" _1904before_idler 133 !on page 0: 0 @3080)
                          M ; messg here2 @3081
                          M ;PAGESEL_DROP += 1
                          M ;    messg goto dest, page tracker #v(PAGE_TRACKER), need page sel? #v(LITPAGEOF(dest)) != #v(LITPAGEOF(PAGE_TRACKER))? #v(LITPAGEOF(dest) != LITPAGEOF(PAGE_TRACKER))
                          M     if LITPAGEOF(_1904before_idler) != LITPAGEOF(PAGE_TRACKER)
                          M         EMIT CLRF PCLATH; PAGESEL dest; kludge: mpasm doesn't want to pagesel
                          M PAGESEL_KEEP += 1
                          M     else
  00000018                M PAGESEL_DROP += 1
                          M     endif
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M ; messg here3 @3091
                          M     EMIT goto _1904before_idler; PROGDCL 0x2000 | (dest); call dest
0086   2885               M     goto _1904before_idler
  00000085                M PAGE_TRACKER = _1904before_idler;
                          M ; messg here4 @3094
                          M ;    NOEXPAND
                          M ;not needed: fall-thru would be handled by earlier code    DROP_CONTEXT; BSR and WREG unknown here if dest falls through
                          M ;    EXPAND_POP
0085                      M     ORG ctx_addr_43
0087                      M     ORG ctx_addr_44
0087                      M _1904around:
                      00591         mov8 TX1REG, WREG; start xmit
0087   0142               M     banksel TX1REG
0088   009A               M     movwf TX1REG
  00000009            00592 pxpiece += 1
                      00593     endw
                      00594     GOTO brkout_loop;
0089   2847               M     goto brkout_loop
                      00595 ;no    YIELD_AGAIN_inlined; only works if tos unchanged since yield!
                      00596 
                      00597 
                      00598 generate_get_palent macro
                      00599 ;    EXPAND_PUSH FALSE
                      00600     VARIABLE palpiece = 0, palent = 0, pal_byte;
                      00601     while palpiece < 3 * 3
                      00602 ;       EXPAND_PUSH TRUE
                      00603 ;pal byte HI first/second/third piece, byte MID first/second/third piece, byte LO first/second/third piece:
                      00604         EMITL get_palent_encpiece_#v(palpiece): DROP_CONTEXT;
                      00605 ;       addlw 7; kludge: move rgbinx 8 to last position in lookup table; this allows run-time code to take > 1 instr without additional jump
                      00606         EMIT andlw 0x0F;
                      00607         EMIT brw;
                      00608 ;       EXPAND_POP
                      00609         while palent < 16 * (palpiece + 1)
                      00610             if (palent % 16) != CUSTOM_RGBINX; const palette entries can be encoded at compile time
                      00611 ;line too long :(               retlw SPI3x_#v(palpiece % 3)(BYTEOF(PALETTE_#v(palent % 16), palpiece / 3));
                      00612 ;               EXPAND_PUSH TRUE
                      00613 pal_byte = BYTEOF(PALETTE_#v(palent % 16), RGB_ORDER(palpiece / 3));
                      00614                 EMIT retlw SPI3x_#v(palpiece % 3)(pal_byte); #v(pal_byte)
                      00615 ;               EXPAND_POP
                      00616             else
                      00617                 EMIT bra custom_palent_encpiece_#v(palpiece)
                      00618             endif
                      00619 palent += 1
                      00620         endw
                      00621 ;       EXPAND_PUSH TRUE
                      00622         EMITL custom_palent_encpiece_#v(palpiece): DROP_CONTEXT;
                      00623 ;line too long :(       ws_encbyte BYTEOF(PALETTE_#v(15), palpiece / 3), ((palpiece % 3) + 1) / 3; custom palette entry requires run-time computation
                      00624 pal_byte = BYTEOF(PALETTE_#v(CUSTOM_RGBINX), RGB_ORDER(palpiece / 3));
                      00625         ws_encbyte pal_byte, ((palpiece % 3) + 1) / 3; custom palette entry requires run-time computation
                      00626         EMIT return;
                      00627 ;       EXPAND_POP
                      00628 palpiece += 1
                      00629     endw
                      00630 ;    EXPAND_POP
                      00631     endm
                      00632     generate_get_palent; kludge: need macro wrapper for expand push/pop
                          M get_palent_encpiece_0: DROP_CONTEXT
                          M     DROP_BANK
                          M ;    EXPAND_PUSH FALSE
  FFFFFFFF                M BANK_TRACKER = BANK_UNKN  ;forget where latest value came from (used for jump targets)
                          M ;    EXPAND_POP
                          M     DROP_WREG
                          M ;    EXPAND_PUSH FALSE
  40000000                M WREG_TRACKER = WREG_UNKN  ;forget latest value
                          M ;    EXPAND_POP
008A   390F               M     andlw 0x0F
008B   000B               M     brw
008C   3449               M     retlw BRKOUT_BYTE_146
008D   3449               M     retlw BRKOUT_BYTE_146
008E   3449               M     retlw BRKOUT_BYTE_146
008F   3449               M     retlw BRKOUT_BYTE_146
0090   3449               M     retlw BRKOUT_BYTE_146
0091   3449               M     retlw BRKOUT_BYTE_146
0092   3449               M     retlw BRKOUT_BYTE_146
0093   3449               M     retlw BRKOUT_BYTE_146
0094   3207               M     bra custom_palent_encpiece_0
0095   3449               M     retlw BRKOUT_BYTE_146
0096   34DB               M     retlw BRKOUT_BYTE_219
0097   344B               M     retlw BRKOUT_BYTE_210
0098   3449               M     retlw BRKOUT_BYTE_146
0099   3449               M     retlw BRKOUT_BYTE_146
009A   344B               M     retlw BRKOUT_BYTE_210
009B   3459               M     retlw BRKOUT_BYTE_154
                          M custom_palent_encpiece_0: DROP_CONTEXT
                          M     DROP_BANK
                          M ;    EXPAND_PUSH FALSE
  FFFFFFFF                M BANK_TRACKER = BANK_UNKN  ;forget where latest value came from (used for jump targets)
                          M ;    EXPAND_POP
                          M     DROP_WREG
                          M ;    EXPAND_PUSH FALSE
  40000000                M WREG_TRACKER = WREG_UNKN  ;forget latest value
                          M ;    EXPAND_POP
009C   3049               M     movlw BRKOUT_BYTE_146
                          M     iorlw_tracker BRKOUT_BYTE_64
                          M ;    EXPAND_PUSH FALSE
                          M ;    andlw arg
                          M     ERRIF((BRKOUT_BYTE_64) & ~0xFF, [ERROR] extra IOR bits ignored: 0          @2468)
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M     EMIT iorlw BRKOUT_BYTE_64; PROGDCL 0x3800 | value
009E   3802               M     iorlw BRKOUT_BYTE_64
                          M ;    NOEXPAND; reduce clutter
                          M ;don't do this: (doesn't handle STATUS)
                          M     if WREG_TRACKER != WREG_UNKN
  8000004B                M WREG_TRACKER = IIF(ISLIT(WREG_TRACKER), LITERAL(WREG_TRACKER | (BRKOUT_BYTE_64)), WREG_UNKN)
                          M     endif
                          M ;    DROP_WREG
                          M ;    EXPAND_POP
009D                      M     ORG ctx_addr_45
009F                      M     ORG ctx_addr_46
                          M     iorlw_tracker BRKOUT_BYTE_8
                          M ;    EXPAND_PUSH FALSE
                          M ;    andlw arg
                          M     ERRIF((BRKOUT_BYTE_8) & ~0xFF, [ERROR] extra IOR bits ignored: 0           @2468)
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M     EMIT iorlw BRKOUT_BYTE_8; PROGDCL 0x3800 | value
00A0   3810               M     iorlw BRKOUT_BYTE_8
                          M ;    NOEXPAND; reduce clutter
                          M ;don't do this: (doesn't handle STATUS)
                          M     if WREG_TRACKER != WREG_UNKN
  8000005B                M WREG_TRACKER = IIF(ISLIT(WREG_TRACKER), LITERAL(WREG_TRACKER | (BRKOUT_BYTE_8)), WREG_UNKN)
                          M     endif
                          M ;    DROP_WREG
                          M ;    EXPAND_POP
009F                      M     ORG ctx_addr_47
00A1                      M     ORG ctx_addr_48
                          M     iorlw_tracker BRKOUT_BYTE_1
                          M ;    EXPAND_PUSH FALSE
                          M ;    andlw arg
                          M     ERRIF((BRKOUT_BYTE_1) & ~0xFF, [ERROR] extra IOR bits ignored: 0           @2468)
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M     EMIT iorlw BRKOUT_BYTE_1; PROGDCL 0x3800 | value
00A2   3880               M     iorlw BRKOUT_BYTE_1
                          M ;    NOEXPAND; reduce clutter
                          M ;don't do this: (doesn't handle STATUS)
                          M     if WREG_TRACKER != WREG_UNKN
  800000DB                M WREG_TRACKER = IIF(ISLIT(WREG_TRACKER), LITERAL(WREG_TRACKER | (BRKOUT_BYTE_1)), WREG_UNKN)
                          M     endif
                          M ;    DROP_WREG
                          M ;    EXPAND_POP
00A1                      M     ORG ctx_addr_49
00A3                      M     ORG ctx_addr_50
00A3   0008               M     return
                          M get_palent_encpiece_1: DROP_CONTEXT
                          M     DROP_BANK
                          M ;    EXPAND_PUSH FALSE
  FFFFFFFF                M BANK_TRACKER = BANK_UNKN  ;forget where latest value came from (used for jump targets)
                          M ;    EXPAND_POP
                          M     DROP_WREG
                          M ;    EXPAND_PUSH FALSE
  40000000                M WREG_TRACKER = WREG_UNKN  ;forget latest value
                          M ;    EXPAND_POP
00A4   390F               M     andlw 0x0F
00A5   000B               M     brw
00A6   3492               M     retlw BRKOUT_BYTE_73
00A7   3492               M     retlw BRKOUT_BYTE_73
00A8   3492               M     retlw BRKOUT_BYTE_73
00A9   3492               M     retlw BRKOUT_BYTE_73
00AA   3492               M     retlw BRKOUT_BYTE_73
00AB   3492               M     retlw BRKOUT_BYTE_73
00AC   3492               M     retlw BRKOUT_BYTE_73
00AD   3492               M     retlw BRKOUT_BYTE_73
00AE   3207               M     bra custom_palent_encpiece_1
00AF   3492               M     retlw BRKOUT_BYTE_73
00B0   34B6               M     retlw BRKOUT_BYTE_109
00B1   3492               M     retlw BRKOUT_BYTE_73
00B2   3492               M     retlw BRKOUT_BYTE_73
00B3   3492               M     retlw BRKOUT_BYTE_73
00B4   3492               M     retlw BRKOUT_BYTE_73
00B5   3496               M     retlw BRKOUT_BYTE_105
                          M custom_palent_encpiece_1: DROP_CONTEXT
                          M     DROP_BANK
                          M ;    EXPAND_PUSH FALSE
  FFFFFFFF                M BANK_TRACKER = BANK_UNKN  ;forget where latest value came from (used for jump targets)
                          M ;    EXPAND_POP
                          M     DROP_WREG
                          M ;    EXPAND_PUSH FALSE
  40000000                M WREG_TRACKER = WREG_UNKN  ;forget latest value
                          M ;    EXPAND_POP
00B6   3092               M     movlw BRKOUT_BYTE_73
                          M     iorlw_tracker BRKOUT_BYTE_32
                          M ;    EXPAND_PUSH FALSE
                          M ;    andlw arg
                          M     ERRIF((BRKOUT_BYTE_32) & ~0xFF, [ERROR] extra IOR bits ignored: 0          @2468)
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M     EMIT iorlw BRKOUT_BYTE_32; PROGDCL 0x3800 | value
00B8   3804               M     iorlw BRKOUT_BYTE_32
                          M ;    NOEXPAND; reduce clutter
                          M ;don't do this: (doesn't handle STATUS)
                          M     if WREG_TRACKER != WREG_UNKN
  80000096                M WREG_TRACKER = IIF(ISLIT(WREG_TRACKER), LITERAL(WREG_TRACKER | (BRKOUT_BYTE_32)), WREG_UNKN)
                          M     endif
                          M ;    DROP_WREG
                          M ;    EXPAND_POP
00B7                      M     ORG ctx_addr_51
00B9                      M     ORG ctx_addr_52
                          M     iorlw_tracker BRKOUT_BYTE_4
                          M ;    EXPAND_PUSH FALSE
                          M ;    andlw arg
                          M     ERRIF((BRKOUT_BYTE_4) & ~0xFF, [ERROR] extra IOR bits ignored: 0           @2468)
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M     EMIT iorlw BRKOUT_BYTE_4; PROGDCL 0x3800 | value
00BA   3820               M     iorlw BRKOUT_BYTE_4
                          M ;    NOEXPAND; reduce clutter
                          M ;don't do this: (doesn't handle STATUS)
                          M     if WREG_TRACKER != WREG_UNKN
  800000B6                M WREG_TRACKER = IIF(ISLIT(WREG_TRACKER), LITERAL(WREG_TRACKER | (BRKOUT_BYTE_4)), WREG_UNKN)
                          M     endif
                          M ;    DROP_WREG
                          M ;    EXPAND_POP
00B9                      M     ORG ctx_addr_53
00BB                      M     ORG ctx_addr_54
00BB   0008               M     return
                          M get_palent_encpiece_2: DROP_CONTEXT
                          M     DROP_BANK
                          M ;    EXPAND_PUSH FALSE
  FFFFFFFF                M BANK_TRACKER = BANK_UNKN  ;forget where latest value came from (used for jump targets)
                          M ;    EXPAND_POP
                          M     DROP_WREG
                          M ;    EXPAND_PUSH FALSE
  40000000                M WREG_TRACKER = WREG_UNKN  ;forget latest value
                          M ;    EXPAND_POP
00BC   390F               M     andlw 0x0F
00BD   000B               M     brw
00BE   3424               M     retlw BRKOUT_BYTE_36
00BF   3424               M     retlw BRKOUT_BYTE_36
00C0   342C               M     retlw BRKOUT_BYTE_52
00C1   3464               M     retlw BRKOUT_BYTE_38
00C2   3424               M     retlw BRKOUT_BYTE_36
00C3   3424               M     retlw BRKOUT_BYTE_36
00C4   3464               M     retlw BRKOUT_BYTE_38
00C5   3464               M     retlw BRKOUT_BYTE_38
00C6   3207               M     bra custom_palent_encpiece_2
00C7   3424               M     retlw BRKOUT_BYTE_36
00C8   346D               M     retlw BRKOUT_BYTE_182
00C9   3424               M     retlw BRKOUT_BYTE_36
00CA   3424               M     retlw BRKOUT_BYTE_36
00CB   3424               M     retlw BRKOUT_BYTE_36
00CC   3424               M     retlw BRKOUT_BYTE_36
00CD   3465               M     retlw BRKOUT_BYTE_166
                          M custom_palent_encpiece_2: DROP_CONTEXT
                          M     DROP_BANK
                          M ;    EXPAND_PUSH FALSE
  FFFFFFFF                M BANK_TRACKER = BANK_UNKN  ;forget where latest value came from (used for jump targets)
                          M ;    EXPAND_POP
                          M     DROP_WREG
                          M ;    EXPAND_PUSH FALSE
  40000000                M WREG_TRACKER = WREG_UNKN  ;forget latest value
                          M ;    EXPAND_POP
00CE   3024               M     movlw BRKOUT_BYTE_36
                          M     iorlw_tracker BRKOUT_BYTE_128
                          M ;    EXPAND_PUSH FALSE
                          M ;    andlw arg
                          M     ERRIF((BRKOUT_BYTE_128) & ~0xFF, [ERROR] extra IOR bits ignored: 0         @2468)
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M     EMIT iorlw BRKOUT_BYTE_128; PROGDCL 0x3800 | value
00D0   3801               M     iorlw BRKOUT_BYTE_128
                          M ;    NOEXPAND; reduce clutter
                          M ;don't do this: (doesn't handle STATUS)
                          M     if WREG_TRACKER != WREG_UNKN
  80000025                M WREG_TRACKER = IIF(ISLIT(WREG_TRACKER), LITERAL(WREG_TRACKER | (BRKOUT_BYTE_128)), WREG_UNKN)
                          M     endif
                          M ;    DROP_WREG
                          M ;    EXPAND_POP
00CF                      M     ORG ctx_addr_55
00D1                      M     ORG ctx_addr_56
                          M     iorlw_tracker BRKOUT_BYTE_16
                          M ;    EXPAND_PUSH FALSE
                          M ;    andlw arg
                          M     ERRIF((BRKOUT_BYTE_16) & ~0xFF, [ERROR] extra IOR bits ignored: 0          @2468)
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M     EMIT iorlw BRKOUT_BYTE_16; PROGDCL 0x3800 | value
00D2   3808               M     iorlw BRKOUT_BYTE_16
                          M ;    NOEXPAND; reduce clutter
                          M ;don't do this: (doesn't handle STATUS)
                          M     if WREG_TRACKER != WREG_UNKN
  8000002D                M WREG_TRACKER = IIF(ISLIT(WREG_TRACKER), LITERAL(WREG_TRACKER | (BRKOUT_BYTE_16)), WREG_UNKN)
                          M     endif
                          M ;    DROP_WREG
                          M ;    EXPAND_POP
00D1                      M     ORG ctx_addr_57
00D3                      M     ORG ctx_addr_58
                          M     iorlw_tracker BRKOUT_BYTE_2
                          M ;    EXPAND_PUSH FALSE
                          M ;    andlw arg
                          M     ERRIF((BRKOUT_BYTE_2) & ~0xFF, [ERROR] extra IOR bits ignored: 0           @2468)
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M     EMIT iorlw BRKOUT_BYTE_2; PROGDCL 0x3800 | value
00D4   3840               M     iorlw BRKOUT_BYTE_2
                          M ;    NOEXPAND; reduce clutter
                          M ;don't do this: (doesn't handle STATUS)
                          M     if WREG_TRACKER != WREG_UNKN
  8000006D                M WREG_TRACKER = IIF(ISLIT(WREG_TRACKER), LITERAL(WREG_TRACKER | (BRKOUT_BYTE_2)), WREG_UNKN)
                          M     endif
                          M ;    DROP_WREG
                          M ;    EXPAND_POP
00D3                      M     ORG ctx_addr_59
00D5                      M     ORG ctx_addr_60
00D5   0008               M     return
                          M get_palent_encpiece_3: DROP_CONTEXT
                          M     DROP_BANK
                          M ;    EXPAND_PUSH FALSE
  FFFFFFFF                M BANK_TRACKER = BANK_UNKN  ;forget where latest value came from (used for jump targets)
                          M ;    EXPAND_POP
                          M     DROP_WREG
                          M ;    EXPAND_PUSH FALSE
  40000000                M WREG_TRACKER = WREG_UNKN  ;forget latest value
                          M ;    EXPAND_POP
00D6   390F               M     andlw 0x0F
00D7   000B               M     brw
00D8   3449               M     retlw BRKOUT_BYTE_146
00D9   3449               M     retlw BRKOUT_BYTE_146
00DA   3449               M     retlw BRKOUT_BYTE_146
00DB   3449               M     retlw BRKOUT_BYTE_146
00DC   3449               M     retlw BRKOUT_BYTE_146
00DD   3449               M     retlw BRKOUT_BYTE_146
00DE   3449               M     retlw BRKOUT_BYTE_146
00DF   3449               M     retlw BRKOUT_BYTE_146
00E0   3207               M     bra custom_palent_encpiece_3
00E1   3449               M     retlw BRKOUT_BYTE_146
00E2   3449               M     retlw BRKOUT_BYTE_146
00E3   3449               M     retlw BRKOUT_BYTE_146
00E4   34DB               M     retlw BRKOUT_BYTE_219
00E5   344B               M     retlw BRKOUT_BYTE_210
00E6   344B               M     retlw BRKOUT_BYTE_210
00E7   3459               M     retlw BRKOUT_BYTE_154
                          M custom_palent_encpiece_3: DROP_CONTEXT
                          M     DROP_BANK
                          M ;    EXPAND_PUSH FALSE
  FFFFFFFF                M BANK_TRACKER = BANK_UNKN  ;forget where latest value came from (used for jump targets)
                          M ;    EXPAND_POP
                          M     DROP_WREG
                          M ;    EXPAND_PUSH FALSE
  40000000                M WREG_TRACKER = WREG_UNKN  ;forget latest value
                          M ;    EXPAND_POP
00E8   3049               M     movlw BRKOUT_BYTE_146
                          M     iorlw_tracker BRKOUT_BYTE_64
                          M ;    EXPAND_PUSH FALSE
                          M ;    andlw arg
                          M     ERRIF((BRKOUT_BYTE_64) & ~0xFF, [ERROR] extra IOR bits ignored: 0          @2468)
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M     EMIT iorlw BRKOUT_BYTE_64; PROGDCL 0x3800 | value
00EA   3802               M     iorlw BRKOUT_BYTE_64
                          M ;    NOEXPAND; reduce clutter
                          M ;don't do this: (doesn't handle STATUS)
                          M     if WREG_TRACKER != WREG_UNKN
  8000004B                M WREG_TRACKER = IIF(ISLIT(WREG_TRACKER), LITERAL(WREG_TRACKER | (BRKOUT_BYTE_64)), WREG_UNKN)
                          M     endif
                          M ;    DROP_WREG
                          M ;    EXPAND_POP
00E9                      M     ORG ctx_addr_61
00EB                      M     ORG ctx_addr_62
                          M     iorlw_tracker BRKOUT_BYTE_8
                          M ;    EXPAND_PUSH FALSE
                          M ;    andlw arg
                          M     ERRIF((BRKOUT_BYTE_8) & ~0xFF, [ERROR] extra IOR bits ignored: 0           @2468)
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M     EMIT iorlw BRKOUT_BYTE_8; PROGDCL 0x3800 | value
00EC   3810               M     iorlw BRKOUT_BYTE_8
                          M ;    NOEXPAND; reduce clutter
                          M ;don't do this: (doesn't handle STATUS)
                          M     if WREG_TRACKER != WREG_UNKN
  8000005B                M WREG_TRACKER = IIF(ISLIT(WREG_TRACKER), LITERAL(WREG_TRACKER | (BRKOUT_BYTE_8)), WREG_UNKN)
                          M     endif
                          M ;    DROP_WREG
                          M ;    EXPAND_POP
00EB                      M     ORG ctx_addr_63
00ED                      M     ORG ctx_addr_64
                          M     iorlw_tracker BRKOUT_BYTE_1
                          M ;    EXPAND_PUSH FALSE
                          M ;    andlw arg
                          M     ERRIF((BRKOUT_BYTE_1) & ~0xFF, [ERROR] extra IOR bits ignored: 0           @2468)
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M     EMIT iorlw BRKOUT_BYTE_1; PROGDCL 0x3800 | value
00EE   3880               M     iorlw BRKOUT_BYTE_1
                          M ;    NOEXPAND; reduce clutter
                          M ;don't do this: (doesn't handle STATUS)
                          M     if WREG_TRACKER != WREG_UNKN
  800000DB                M WREG_TRACKER = IIF(ISLIT(WREG_TRACKER), LITERAL(WREG_TRACKER | (BRKOUT_BYTE_1)), WREG_UNKN)
                          M     endif
                          M ;    DROP_WREG
                          M ;    EXPAND_POP
00ED                      M     ORG ctx_addr_65
00EF                      M     ORG ctx_addr_66
00EF   0008               M     return
                          M get_palent_encpiece_4: DROP_CONTEXT
                          M     DROP_BANK
                          M ;    EXPAND_PUSH FALSE
  FFFFFFFF                M BANK_TRACKER = BANK_UNKN  ;forget where latest value came from (used for jump targets)
                          M ;    EXPAND_POP
                          M     DROP_WREG
                          M ;    EXPAND_PUSH FALSE
  40000000                M WREG_TRACKER = WREG_UNKN  ;forget latest value
                          M ;    EXPAND_POP
00F0   390F               M     andlw 0x0F
00F1   000B               M     brw
00F2   3492               M     retlw BRKOUT_BYTE_73
00F3   3492               M     retlw BRKOUT_BYTE_73
00F4   3492               M     retlw BRKOUT_BYTE_73
00F5   3492               M     retlw BRKOUT_BYTE_73
00F6   3492               M     retlw BRKOUT_BYTE_73
00F7   3492               M     retlw BRKOUT_BYTE_73
00F8   3492               M     retlw BRKOUT_BYTE_73
00F9   3492               M     retlw BRKOUT_BYTE_73
00FA   3207               M     bra custom_palent_encpiece_4
00FB   3492               M     retlw BRKOUT_BYTE_73
00FC   3492               M     retlw BRKOUT_BYTE_73
00FD   3492               M     retlw BRKOUT_BYTE_73
00FE   34B6               M     retlw BRKOUT_BYTE_109
00FF   3492               M     retlw BRKOUT_BYTE_73
0100   3492               M     retlw BRKOUT_BYTE_73
0101   3496               M     retlw BRKOUT_BYTE_105
                          M custom_palent_encpiece_4: DROP_CONTEXT
                          M     DROP_BANK
                          M ;    EXPAND_PUSH FALSE
  FFFFFFFF                M BANK_TRACKER = BANK_UNKN  ;forget where latest value came from (used for jump targets)
                          M ;    EXPAND_POP
                          M     DROP_WREG
                          M ;    EXPAND_PUSH FALSE
  40000000                M WREG_TRACKER = WREG_UNKN  ;forget latest value
                          M ;    EXPAND_POP
0102   3092               M     movlw BRKOUT_BYTE_73
                          M     iorlw_tracker BRKOUT_BYTE_32
                          M ;    EXPAND_PUSH FALSE
                          M ;    andlw arg
                          M     ERRIF((BRKOUT_BYTE_32) & ~0xFF, [ERROR] extra IOR bits ignored: 0          @2468)
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M     EMIT iorlw BRKOUT_BYTE_32; PROGDCL 0x3800 | value
0104   3804               M     iorlw BRKOUT_BYTE_32
                          M ;    NOEXPAND; reduce clutter
                          M ;don't do this: (doesn't handle STATUS)
                          M     if WREG_TRACKER != WREG_UNKN
  80000096                M WREG_TRACKER = IIF(ISLIT(WREG_TRACKER), LITERAL(WREG_TRACKER | (BRKOUT_BYTE_32)), WREG_UNKN)
                          M     endif
                          M ;    DROP_WREG
                          M ;    EXPAND_POP
0103                      M     ORG ctx_addr_67
0105                      M     ORG ctx_addr_68
                          M     iorlw_tracker BRKOUT_BYTE_4
                          M ;    EXPAND_PUSH FALSE
                          M ;    andlw arg
                          M     ERRIF((BRKOUT_BYTE_4) & ~0xFF, [ERROR] extra IOR bits ignored: 0           @2468)
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M     EMIT iorlw BRKOUT_BYTE_4; PROGDCL 0x3800 | value
0106   3820               M     iorlw BRKOUT_BYTE_4
                          M ;    NOEXPAND; reduce clutter
                          M ;don't do this: (doesn't handle STATUS)
                          M     if WREG_TRACKER != WREG_UNKN
  800000B6                M WREG_TRACKER = IIF(ISLIT(WREG_TRACKER), LITERAL(WREG_TRACKER | (BRKOUT_BYTE_4)), WREG_UNKN)
                          M     endif
                          M ;    DROP_WREG
                          M ;    EXPAND_POP
0105                      M     ORG ctx_addr_69
0107                      M     ORG ctx_addr_70
0107   0008               M     return
                          M get_palent_encpiece_5: DROP_CONTEXT
                          M     DROP_BANK
                          M ;    EXPAND_PUSH FALSE
  FFFFFFFF                M BANK_TRACKER = BANK_UNKN  ;forget where latest value came from (used for jump targets)
                          M ;    EXPAND_POP
                          M     DROP_WREG
                          M ;    EXPAND_PUSH FALSE
  40000000                M WREG_TRACKER = WREG_UNKN  ;forget latest value
                          M ;    EXPAND_POP
0108   390F               M     andlw 0x0F
0109   000B               M     brw
010A   3424               M     retlw BRKOUT_BYTE_36
010B   3424               M     retlw BRKOUT_BYTE_36
010C   3424               M     retlw BRKOUT_BYTE_36
010D   3424               M     retlw BRKOUT_BYTE_36
010E   342C               M     retlw BRKOUT_BYTE_52
010F   3464               M     retlw BRKOUT_BYTE_38
0110   3464               M     retlw BRKOUT_BYTE_38
0111   3464               M     retlw BRKOUT_BYTE_38
0112   3207               M     bra custom_palent_encpiece_5
0113   3424               M     retlw BRKOUT_BYTE_36
0114   3424               M     retlw BRKOUT_BYTE_36
0115   3424               M     retlw BRKOUT_BYTE_36
0116   346D               M     retlw BRKOUT_BYTE_182
0117   3424               M     retlw BRKOUT_BYTE_36
0118   3424               M     retlw BRKOUT_BYTE_36
0119   3465               M     retlw BRKOUT_BYTE_166
                          M custom_palent_encpiece_5: DROP_CONTEXT
                          M     DROP_BANK
                          M ;    EXPAND_PUSH FALSE
  FFFFFFFF                M BANK_TRACKER = BANK_UNKN  ;forget where latest value came from (used for jump targets)
                          M ;    EXPAND_POP
                          M     DROP_WREG
                          M ;    EXPAND_PUSH FALSE
  40000000                M WREG_TRACKER = WREG_UNKN  ;forget latest value
                          M ;    EXPAND_POP
011A   3024               M     movlw BRKOUT_BYTE_36
                          M     iorlw_tracker BRKOUT_BYTE_128
                          M ;    EXPAND_PUSH FALSE
                          M ;    andlw arg
                          M     ERRIF((BRKOUT_BYTE_128) & ~0xFF, [ERROR] extra IOR bits ignored: 0         @2468)
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M     EMIT iorlw BRKOUT_BYTE_128; PROGDCL 0x3800 | value
011C   3801               M     iorlw BRKOUT_BYTE_128
                          M ;    NOEXPAND; reduce clutter
                          M ;don't do this: (doesn't handle STATUS)
                          M     if WREG_TRACKER != WREG_UNKN
  80000025                M WREG_TRACKER = IIF(ISLIT(WREG_TRACKER), LITERAL(WREG_TRACKER | (BRKOUT_BYTE_128)), WREG_UNKN)
                          M     endif
                          M ;    DROP_WREG
                          M ;    EXPAND_POP
011B                      M     ORG ctx_addr_71
011D                      M     ORG ctx_addr_72
                          M     iorlw_tracker BRKOUT_BYTE_16
                          M ;    EXPAND_PUSH FALSE
                          M ;    andlw arg
                          M     ERRIF((BRKOUT_BYTE_16) & ~0xFF, [ERROR] extra IOR bits ignored: 0          @2468)
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M     EMIT iorlw BRKOUT_BYTE_16; PROGDCL 0x3800 | value
011E   3808               M     iorlw BRKOUT_BYTE_16
                          M ;    NOEXPAND; reduce clutter
                          M ;don't do this: (doesn't handle STATUS)
                          M     if WREG_TRACKER != WREG_UNKN
  8000002D                M WREG_TRACKER = IIF(ISLIT(WREG_TRACKER), LITERAL(WREG_TRACKER | (BRKOUT_BYTE_16)), WREG_UNKN)
                          M     endif
                          M ;    DROP_WREG
                          M ;    EXPAND_POP
011D                      M     ORG ctx_addr_73
011F                      M     ORG ctx_addr_74
                          M     iorlw_tracker BRKOUT_BYTE_2
                          M ;    EXPAND_PUSH FALSE
                          M ;    andlw arg
                          M     ERRIF((BRKOUT_BYTE_2) & ~0xFF, [ERROR] extra IOR bits ignored: 0           @2468)
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M     EMIT iorlw BRKOUT_BYTE_2; PROGDCL 0x3800 | value
0120   3840               M     iorlw BRKOUT_BYTE_2
                          M ;    NOEXPAND; reduce clutter
                          M ;don't do this: (doesn't handle STATUS)
                          M     if WREG_TRACKER != WREG_UNKN
  8000006D                M WREG_TRACKER = IIF(ISLIT(WREG_TRACKER), LITERAL(WREG_TRACKER | (BRKOUT_BYTE_2)), WREG_UNKN)
                          M     endif
                          M ;    DROP_WREG
                          M ;    EXPAND_POP
011F                      M     ORG ctx_addr_75
0121                      M     ORG ctx_addr_76
0121   0008               M     return
                          M get_palent_encpiece_6: DROP_CONTEXT
                          M     DROP_BANK
                          M ;    EXPAND_PUSH FALSE
  FFFFFFFF                M BANK_TRACKER = BANK_UNKN  ;forget where latest value came from (used for jump targets)
                          M ;    EXPAND_POP
                          M     DROP_WREG
                          M ;    EXPAND_PUSH FALSE
  40000000                M WREG_TRACKER = WREG_UNKN  ;forget latest value
                          M ;    EXPAND_POP
0122   390F               M     andlw 0x0F
0123   000B               M     brw
0124   3449               M     retlw BRKOUT_BYTE_146
0125   3449               M     retlw BRKOUT_BYTE_146
0126   3449               M     retlw BRKOUT_BYTE_146
0127   3449               M     retlw BRKOUT_BYTE_146
0128   3449               M     retlw BRKOUT_BYTE_146
0129   3449               M     retlw BRKOUT_BYTE_146
012A   3449               M     retlw BRKOUT_BYTE_146
012B   3449               M     retlw BRKOUT_BYTE_146
012C   3207               M     bra custom_palent_encpiece_6
012D   34DB               M     retlw BRKOUT_BYTE_219
012E   3449               M     retlw BRKOUT_BYTE_146
012F   344B               M     retlw BRKOUT_BYTE_210
0130   3449               M     retlw BRKOUT_BYTE_146
0131   344B               M     retlw BRKOUT_BYTE_210
0132   3449               M     retlw BRKOUT_BYTE_146
0133   3459               M     retlw BRKOUT_BYTE_154
                          M custom_palent_encpiece_6: DROP_CONTEXT
                          M     DROP_BANK
                          M ;    EXPAND_PUSH FALSE
  FFFFFFFF                M BANK_TRACKER = BANK_UNKN  ;forget where latest value came from (used for jump targets)
                          M ;    EXPAND_POP
                          M     DROP_WREG
                          M ;    EXPAND_PUSH FALSE
  40000000                M WREG_TRACKER = WREG_UNKN  ;forget latest value
                          M ;    EXPAND_POP
0134   3049               M     movlw BRKOUT_BYTE_146
                          M     iorlw_tracker BRKOUT_BYTE_64
                          M ;    EXPAND_PUSH FALSE
                          M ;    andlw arg
                          M     ERRIF((BRKOUT_BYTE_64) & ~0xFF, [ERROR] extra IOR bits ignored: 0          @2468)
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M     EMIT iorlw BRKOUT_BYTE_64; PROGDCL 0x3800 | value
0136   3802               M     iorlw BRKOUT_BYTE_64
                          M ;    NOEXPAND; reduce clutter
                          M ;don't do this: (doesn't handle STATUS)
                          M     if WREG_TRACKER != WREG_UNKN
  8000004B                M WREG_TRACKER = IIF(ISLIT(WREG_TRACKER), LITERAL(WREG_TRACKER | (BRKOUT_BYTE_64)), WREG_UNKN)
                          M     endif
                          M ;    DROP_WREG
                          M ;    EXPAND_POP
0135                      M     ORG ctx_addr_77
0137                      M     ORG ctx_addr_78
                          M     iorlw_tracker BRKOUT_BYTE_8
                          M ;    EXPAND_PUSH FALSE
                          M ;    andlw arg
                          M     ERRIF((BRKOUT_BYTE_8) & ~0xFF, [ERROR] extra IOR bits ignored: 0           @2468)
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M     EMIT iorlw BRKOUT_BYTE_8; PROGDCL 0x3800 | value
0138   3810               M     iorlw BRKOUT_BYTE_8
                          M ;    NOEXPAND; reduce clutter
                          M ;don't do this: (doesn't handle STATUS)
                          M     if WREG_TRACKER != WREG_UNKN
  8000005B                M WREG_TRACKER = IIF(ISLIT(WREG_TRACKER), LITERAL(WREG_TRACKER | (BRKOUT_BYTE_8)), WREG_UNKN)
                          M     endif
                          M ;    DROP_WREG
                          M ;    EXPAND_POP
0137                      M     ORG ctx_addr_79
0139                      M     ORG ctx_addr_80
                          M     iorlw_tracker BRKOUT_BYTE_1
                          M ;    EXPAND_PUSH FALSE
                          M ;    andlw arg
                          M     ERRIF((BRKOUT_BYTE_1) & ~0xFF, [ERROR] extra IOR bits ignored: 0           @2468)
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M     EMIT iorlw BRKOUT_BYTE_1; PROGDCL 0x3800 | value
013A   3880               M     iorlw BRKOUT_BYTE_1
                          M ;    NOEXPAND; reduce clutter
                          M ;don't do this: (doesn't handle STATUS)
                          M     if WREG_TRACKER != WREG_UNKN
  800000DB                M WREG_TRACKER = IIF(ISLIT(WREG_TRACKER), LITERAL(WREG_TRACKER | (BRKOUT_BYTE_1)), WREG_UNKN)
                          M     endif
                          M ;    DROP_WREG
                          M ;    EXPAND_POP
0139                      M     ORG ctx_addr_81
013B                      M     ORG ctx_addr_82
013B   0008               M     return
                          M get_palent_encpiece_7: DROP_CONTEXT
                          M     DROP_BANK
                          M ;    EXPAND_PUSH FALSE
  FFFFFFFF                M BANK_TRACKER = BANK_UNKN  ;forget where latest value came from (used for jump targets)
                          M ;    EXPAND_POP
                          M     DROP_WREG
                          M ;    EXPAND_PUSH FALSE
  40000000                M WREG_TRACKER = WREG_UNKN  ;forget latest value
                          M ;    EXPAND_POP
013C   390F               M     andlw 0x0F
013D   000B               M     brw
013E   3492               M     retlw BRKOUT_BYTE_73
013F   3492               M     retlw BRKOUT_BYTE_73
0140   3492               M     retlw BRKOUT_BYTE_73
0141   3492               M     retlw BRKOUT_BYTE_73
0142   3492               M     retlw BRKOUT_BYTE_73
0143   3492               M     retlw BRKOUT_BYTE_73
0144   3492               M     retlw BRKOUT_BYTE_73
0145   3492               M     retlw BRKOUT_BYTE_73
0146   3207               M     bra custom_palent_encpiece_7
0147   34B6               M     retlw BRKOUT_BYTE_109
0148   3492               M     retlw BRKOUT_BYTE_73
0149   3492               M     retlw BRKOUT_BYTE_73
014A   3492               M     retlw BRKOUT_BYTE_73
014B   3492               M     retlw BRKOUT_BYTE_73
014C   3492               M     retlw BRKOUT_BYTE_73
014D   3496               M     retlw BRKOUT_BYTE_105
                          M custom_palent_encpiece_7: DROP_CONTEXT
                          M     DROP_BANK
                          M ;    EXPAND_PUSH FALSE
  FFFFFFFF                M BANK_TRACKER = BANK_UNKN  ;forget where latest value came from (used for jump targets)
                          M ;    EXPAND_POP
                          M     DROP_WREG
                          M ;    EXPAND_PUSH FALSE
  40000000                M WREG_TRACKER = WREG_UNKN  ;forget latest value
                          M ;    EXPAND_POP
014E   3092               M     movlw BRKOUT_BYTE_73
                          M     iorlw_tracker BRKOUT_BYTE_32
                          M ;    EXPAND_PUSH FALSE
                          M ;    andlw arg
                          M     ERRIF((BRKOUT_BYTE_32) & ~0xFF, [ERROR] extra IOR bits ignored: 0          @2468)
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M     EMIT iorlw BRKOUT_BYTE_32; PROGDCL 0x3800 | value
0150   3804               M     iorlw BRKOUT_BYTE_32
                          M ;    NOEXPAND; reduce clutter
                          M ;don't do this: (doesn't handle STATUS)
                          M     if WREG_TRACKER != WREG_UNKN
  80000096                M WREG_TRACKER = IIF(ISLIT(WREG_TRACKER), LITERAL(WREG_TRACKER | (BRKOUT_BYTE_32)), WREG_UNKN)
                          M     endif
                          M ;    DROP_WREG
                          M ;    EXPAND_POP
014F                      M     ORG ctx_addr_83
0151                      M     ORG ctx_addr_84
                          M     iorlw_tracker BRKOUT_BYTE_4
                          M ;    EXPAND_PUSH FALSE
                          M ;    andlw arg
                          M     ERRIF((BRKOUT_BYTE_4) & ~0xFF, [ERROR] extra IOR bits ignored: 0           @2468)
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M     EMIT iorlw BRKOUT_BYTE_4; PROGDCL 0x3800 | value
0152   3820               M     iorlw BRKOUT_BYTE_4
                          M ;    NOEXPAND; reduce clutter
                          M ;don't do this: (doesn't handle STATUS)
                          M     if WREG_TRACKER != WREG_UNKN
  800000B6                M WREG_TRACKER = IIF(ISLIT(WREG_TRACKER), LITERAL(WREG_TRACKER | (BRKOUT_BYTE_4)), WREG_UNKN)
                          M     endif
                          M ;    DROP_WREG
                          M ;    EXPAND_POP
0151                      M     ORG ctx_addr_85
0153                      M     ORG ctx_addr_86
0153   0008               M     return
                          M get_palent_encpiece_8: DROP_CONTEXT
                          M     DROP_BANK
                          M ;    EXPAND_PUSH FALSE
  FFFFFFFF                M BANK_TRACKER = BANK_UNKN  ;forget where latest value came from (used for jump targets)
                          M ;    EXPAND_POP
                          M     DROP_WREG
                          M ;    EXPAND_PUSH FALSE
  40000000                M WREG_TRACKER = WREG_UNKN  ;forget latest value
                          M ;    EXPAND_POP
0154   390F               M     andlw 0x0F
0155   000B               M     brw
0156   3424               M     retlw BRKOUT_BYTE_36
0157   342C               M     retlw BRKOUT_BYTE_52
0158   3424               M     retlw BRKOUT_BYTE_36
0159   3464               M     retlw BRKOUT_BYTE_38
015A   3424               M     retlw BRKOUT_BYTE_36
015B   3464               M     retlw BRKOUT_BYTE_38
015C   3424               M     retlw BRKOUT_BYTE_36
015D   3464               M     retlw BRKOUT_BYTE_38
015E   3207               M     bra custom_palent_encpiece_8
015F   346D               M     retlw BRKOUT_BYTE_182
0160   3424               M     retlw BRKOUT_BYTE_36
0161   3424               M     retlw BRKOUT_BYTE_36
0162   3424               M     retlw BRKOUT_BYTE_36
0163   3424               M     retlw BRKOUT_BYTE_36
0164   3424               M     retlw BRKOUT_BYTE_36
0165   3465               M     retlw BRKOUT_BYTE_166
                          M custom_palent_encpiece_8: DROP_CONTEXT
                          M     DROP_BANK
                          M ;    EXPAND_PUSH FALSE
  FFFFFFFF                M BANK_TRACKER = BANK_UNKN  ;forget where latest value came from (used for jump targets)
                          M ;    EXPAND_POP
                          M     DROP_WREG
                          M ;    EXPAND_PUSH FALSE
  40000000                M WREG_TRACKER = WREG_UNKN  ;forget latest value
                          M ;    EXPAND_POP
0166   3024               M     movlw BRKOUT_BYTE_36
                          M     iorlw_tracker BRKOUT_BYTE_128
                          M ;    EXPAND_PUSH FALSE
                          M ;    andlw arg
                          M     ERRIF((BRKOUT_BYTE_128) & ~0xFF, [ERROR] extra IOR bits ignored: 0         @2468)
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M     EMIT iorlw BRKOUT_BYTE_128; PROGDCL 0x3800 | value
0168   3801               M     iorlw BRKOUT_BYTE_128
                          M ;    NOEXPAND; reduce clutter
                          M ;don't do this: (doesn't handle STATUS)
                          M     if WREG_TRACKER != WREG_UNKN
  80000025                M WREG_TRACKER = IIF(ISLIT(WREG_TRACKER), LITERAL(WREG_TRACKER | (BRKOUT_BYTE_128)), WREG_UNKN)
                          M     endif
                          M ;    DROP_WREG
                          M ;    EXPAND_POP
0167                      M     ORG ctx_addr_87
0169                      M     ORG ctx_addr_88
                          M     iorlw_tracker BRKOUT_BYTE_16
                          M ;    EXPAND_PUSH FALSE
                          M ;    andlw arg
                          M     ERRIF((BRKOUT_BYTE_16) & ~0xFF, [ERROR] extra IOR bits ignored: 0          @2468)
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M     EMIT iorlw BRKOUT_BYTE_16; PROGDCL 0x3800 | value
016A   3808               M     iorlw BRKOUT_BYTE_16
                          M ;    NOEXPAND; reduce clutter
                          M ;don't do this: (doesn't handle STATUS)
                          M     if WREG_TRACKER != WREG_UNKN
  8000002D                M WREG_TRACKER = IIF(ISLIT(WREG_TRACKER), LITERAL(WREG_TRACKER | (BRKOUT_BYTE_16)), WREG_UNKN)
                          M     endif
                          M ;    DROP_WREG
                          M ;    EXPAND_POP
0169                      M     ORG ctx_addr_89
016B                      M     ORG ctx_addr_90
                          M     iorlw_tracker BRKOUT_BYTE_2
                          M ;    EXPAND_PUSH FALSE
                          M ;    andlw arg
                          M     ERRIF((BRKOUT_BYTE_2) & ~0xFF, [ERROR] extra IOR bits ignored: 0           @2468)
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M     EMIT iorlw BRKOUT_BYTE_2; PROGDCL 0x3800 | value
016C   3840               M     iorlw BRKOUT_BYTE_2
                          M ;    NOEXPAND; reduce clutter
                          M ;don't do this: (doesn't handle STATUS)
                          M     if WREG_TRACKER != WREG_UNKN
  8000006D                M WREG_TRACKER = IIF(ISLIT(WREG_TRACKER), LITERAL(WREG_TRACKER | (BRKOUT_BYTE_2)), WREG_UNKN)
                          M     endif
                          M ;    DROP_WREG
                          M ;    EXPAND_POP
016B                      M     ORG ctx_addr_91
016D                      M     ORG ctx_addr_92
016D   0008               M     return
                      00633 
                      00634 
                      00635     THREAD_END;
                      00636 
Message[301]: MESSAGE: (end of hoist 5 @639)
Message[301]: MESSAGE: (hoist 6: rcv frame thread (main logic) @176)
                          M         exitm
                      00179 ;; frame rcv thread (main logic) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                      00180 
                      00181 ;    UGLY_PASS12FIX -1
                      00182 ;    messg #thr #v(NUM_THREADS), YIELD @182
                      00183     THREAD_DEF rcv_frame, 4
                          M     CBLOCK NEXT_RAM9999; BOOL2INT(banked))  ;continue where we left off last time
  00000074                M         stkptr_1 
                          M     ENDC  ;can't span macros
Message[301]: MESSAGE: (creating rcv_frame thread# 1 @366, stack size 4, host stack remaining: 8 @1294)
016E   017F               M     banksel STKPTR
                          M     withdest_0 movf STKPTR
016F   086D               M     movf STKPTR, W;
0170   00F4               M     movwf stkptr_1
0174   0008               M     return
002F                      M     ORG ctx_addr_6
002F   2975               M     goto init_4
0175                      M     ORG ctx_addr_94
0175                      M init_4:
0175   2178               M     call stack_alloc_1
0176   217E               M     call rcv_frame
0177   2971               M     goto yield_again
0178   017F               M     banksel STKPTR
                          M     withdest_0 movf STKPTR
0179   086D               M     movf STKPTR, W;
017A   00F4               M     movwf stkptr_1
017B   3003               M     movlw 4 - 1
                          M     withdest_1 addwf STKPTR
017C   07ED               M     addwf STKPTR, F;
Message[301]: MESSAGE: ([DEBUG] 8173 @1386)
                      00184 ;    messg #thr #v(NUM_THREADS), YIELD @184
                      00185 
                      00186 ;    init_more TRUE;
                      00187 ;    call brkout_anim; call this during init
                      00188 ;    init_more FALSE;
                      00189 
                      00190 wait4timeout macro idler, idler2
                      00191     idler; assume not ready yet, let other threads run
                      00192     ifbit LITERAL(1), 0, FALSE, idler2; more efficient than goto $-3 + call
                      00193     endm
                      00194 
                      00195 
                      00196 ;blink_1sec: DROP_CONTEXT;
                      00197 rcv_frame: DROP_CONTEXT;
                      00198     CALL brkout_anim
017E   21BD               M     call brkout_anim
                      00199     fps_init 1 sec
Message[301]: MESSAGE: ([TODO] change this to use postscaler 1..16 instead of just powers of 2 (for more accuracy) @1131)
Message[301]: MESSAGE: ([DEBUG] fps_init 1000000 (1111111 tuned) "usec": "prescaler" 15+1, max intv 2097152, actual 1114112, rollover 136 @1147)
017F   3001               M     movlw (((ASM_MSB | (0 | 0 | _4094POSTSCALER << T0OUTPS0))) & ~ASM_MSB)
0180   014B               M     banksel T0CON0
0181   009E               M     movwf T0CON0
0182   304F               M     movlw (((ASM_MSB | (b'010' << T0CS0 | 0 | _4094PRESCALER << T0CKPS0))) & ~ASM_MSB)
0183   009F               M     movwf T0CON1
0184   019C               M     clrf TMR0L
0185   3087               M     movlw (((ASM_MSB | (_4094ROLLOVER - 1))) & ~ASM_MSB)
0186   009D               M     movwf TMR0H
                          M     withbit_7 bsf T0CON0
0187   179E               M     bsf T0CON0, 7
0188   014E               M     banksel PIR0
                          M     withbit_5 bcf PIR0
0189   128C               M     bcf PIR0, 5
                          M             exitm
                      00200 rcv_loop: DROP_CONTEXT;
                      00201     wait4timeout YIELD, YIELD_AGAIN;
018A   216E               M     call yield
                      00202     ifbit elapsed_fps, TRUE, CALL fps_update; render FPS 1x/sec during idle time at end of frame
018B   014E               M     banksel PIR0
                          M     call_pagesafe fps_update
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND; hide clutter
                          M     ERRIF(LITPAGEOF(fps_update), [ERROR] fps_update !on page 0: 0       @3044)
                          M ;PAGESEL_DROP += 1
                          M ;    LOCAL WREG_SAVE = WREG_TRACKER
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M ;    messg call dest, page tracker #v(PAGE_TRACKER), need page sel? #v(LITPAGEOF(dest)) != #v(LITPAGEOF(PAGE_TRACKER))? #v(LITPAGEOF(dest) != LITPAGEOF(PAGE_TRACKER))
                          M     if LITPAGEOF(fps_update) != LITPAGEOF(PAGE_TRACKER)
                          M         EMIT CLRF PCLATH; PAGESEL dest; kludge: mpasm doesn't want to pagesel
                          M PAGESEL_KEEP += 1
                          M     else
  00000020                M PAGESEL_DROP += 1
                          M     endif
                          M     EMIT call fps_update; PROGDCL 0x2000 | (dest); call dest
018D   219E               M     call fps_update
  0000019E                M PAGE_TRACKER = fps_update;
                          M ;    NOEXPAND
                          M     if (fps_update == nop4) || (fps_update == nop8); ; these don't alter BSR or WREG
                          M ;        EXPAND_POP
                          M         exitm
                          M     endif
                          M     DROP_CONTEXT; BSR and WREG unknown here
                          M     DROP_BANK
                          M ;    EXPAND_PUSH FALSE
  FFFFFFFF                M BANK_TRACKER = BANK_UNKN  ;forget where latest value came from (used for jump targets)
                          M ;    EXPAND_POP
                          M     DROP_WREG
                          M ;    EXPAND_PUSH FALSE
  40000000                M WREG_TRACKER = WREG_UNKN  ;forget latest value
                          M ;    EXPAND_POP
                          M ;    if dest == choose_next_color
                          M ;WREG_TRACKER = color; kludge: avoid unknown contents warning
                          M ;    endif
                          M ;#ifdef BITBANG
                          M ;    if dest == bitbang_wreg
                          M ;BANK_TRACKER = LATA; preserve caller context to improve timing
                          M ;    endif
                          M ;#endif
                          M ;    EXPAND_POP
018C                      M     ORG ctx_addr_96
018E                      M     ORG ctx_addr_97
                      00203     INCF FPS, F; assume !overflow; max FPS likely ~ 40 - 50
                          M     withdest_1 incf FPS
018E   0AF5               M     incf FPS, F;
Message[301]: MESSAGE: (TODO: wait for 50 * 1, start rcv/xfr, trigger brkout render @204)
                      00204     messg TODO: wait for 50 usec, start rcv/xfr, trigger brkout render @204
                      00205 #if 1; dev/test
                      00206     wait4frame YIELD, YIELD_AGAIN; 1 sec
018F   216E               M     call yield
0190   014E               M     banksel PIR0
                          M     goto_pagesafe yield_again
                          M ;    EXPAND_PUSH FALSE
                          M ; messg here1 @3079
                          M     ERRIF(LITPAGEOF(yield_again), [ERROR] "dest" yield_again 369 !on page 0: 0          @3080)
                          M ; messg here2 @3081
                          M ;PAGESEL_DROP += 1
                          M ;    messg goto dest, page tracker #v(PAGE_TRACKER), need page sel? #v(LITPAGEOF(dest)) != #v(LITPAGEOF(PAGE_TRACKER))? #v(LITPAGEOF(dest) != LITPAGEOF(PAGE_TRACKER))
                          M     if LITPAGEOF(yield_again) != LITPAGEOF(PAGE_TRACKER)
                          M         EMIT CLRF PCLATH; PAGESEL dest; kludge: mpasm doesn't want to pagesel
                          M PAGESEL_KEEP += 1
                          M     else
  00000022                M PAGESEL_DROP += 1
                          M     endif
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M ; messg here3 @3091
                          M     EMIT goto yield_again; PROGDCL 0x2000 | (dest); call dest
0192   2971               M     goto yield_again
  00000171                M PAGE_TRACKER = yield_again;
                          M ; messg here4 @3094
                          M ;    NOEXPAND
                          M ;not needed: fall-thru would be handled by earlier code    DROP_CONTEXT; BSR and WREG unknown here if dest falls through
                          M ;    EXPAND_POP
0191                      M     ORG ctx_addr_98
0193                      M     ORG ctx_addr_99
                          M     withbit_5 bcf PIR0
0193   128C               M     bcf PIR0, 5
                      00207     setbit LATA, LEDOUT, TRUE;
0194   0140               M     banksel LATA
                          M     withbit_4 bsf LATA
0195   1618               M     bsf LATA, 4
                      00208 ;    movlw 22;
                      00209 ;    BANKSAFE dest_arg(F) addwf FPS_render;
                      00210     wait4frame YIELD, YIELD_AGAIN; 1 sec
0196   216E               M     call yield
0197   014E               M     banksel PIR0
                          M     goto_pagesafe yield_again
                          M ;    EXPAND_PUSH FALSE
                          M ; messg here1 @3079
                          M     ERRIF(LITPAGEOF(yield_again), [ERROR] "dest" yield_again 369 !on page 0: 0          @3080)
                          M ; messg here2 @3081
                          M ;PAGESEL_DROP += 1
                          M ;    messg goto dest, page tracker #v(PAGE_TRACKER), need page sel? #v(LITPAGEOF(dest)) != #v(LITPAGEOF(PAGE_TRACKER))? #v(LITPAGEOF(dest) != LITPAGEOF(PAGE_TRACKER))
                          M     if LITPAGEOF(yield_again) != LITPAGEOF(PAGE_TRACKER)
                          M         EMIT CLRF PCLATH; PAGESEL dest; kludge: mpasm doesn't want to pagesel
                          M PAGESEL_KEEP += 1
                          M     else
  00000024                M PAGESEL_DROP += 1
                          M     endif
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M ; messg here3 @3091
                          M     EMIT goto yield_again; PROGDCL 0x2000 | (dest); call dest
0199   2971               M     goto yield_again
  00000171                M PAGE_TRACKER = yield_again;
                          M ; messg here4 @3094
                          M ;    NOEXPAND
                          M ;not needed: fall-thru would be handled by earlier code    DROP_CONTEXT; BSR and WREG unknown here if dest falls through
                          M ;    EXPAND_POP
0198                      M     ORG ctx_addr_100
019A                      M     ORG ctx_addr_101
                          M     withbit_5 bcf PIR0
019A   128C               M     bcf PIR0, 5
                      00211     setbit LATA, LEDOUT, FALSE;
019B   0140               M     banksel LATA
                          M     withbit_4 bcf LATA
019C   1218               M     bcf LATA, 4
                      00212 ;    movlw 10;
                      00213 ;    BANKSAFE dest_arg(F) addwf FPS_render;
                      00214 #endif
                      00215 ;no    YIELD_AGAIN_inlined; only works if tos unchanged since yield!
                      00216     GOTO rcv_loop;
019D   298A               M     goto rcv_loop
                      00217 
                      00218 
                      00219     nbDCL FPS,;;
                          M     CBLOCK NEXT_RAM9999; BOOL2INT(banked))  ;continue where we left off last time
  00000075                M         FPS  
                          M     ENDC  ;can't span macros
  0003                00220     CONSTANT FPS_RGBINX = CYAN_RGBINX; FPS
  0005                00221     CONSTANT FPS_RGBINX_ALT = MAGENTA_RGBINX; alternate FPS (heartbeat)
  0004                00222     CONSTANT HEARTBEAT_PARITY = RED_RGBINX; use this bit to distinguish heartbeat parity
                      00223     ERRIF(!((FPS_RGBINX ^ FPS_RGBINX_ALT) & HEARTBEAT_PARITY), [ERROR] heartbeat bit 4                    can''t be used to check frame parity: 6                           
                      00224 
                      00225 set_fps_pxbit macro bitnum
                      00226 ;    BANKCHK brkoutpx;
                      00227 ;    messg TODO ^^^ fix banksel in ifbit @227
                      00228     ifbit IIF(bitnum == 7, LITERAL(0), FPS), 7 - bitnum, TRUE, MOVWF brkoutpx + 24 + bitnum;
                      00229     endm
                      00230 
                      00231 ;render FPS breakout px then reset:
                      00232 fps_update: DROP_CONTEXT;
                          M         exitm
                      00234     MOVLW WHITE_RGBINX;
019E   3007               M     movlw WHITE_RGBINX
                      00235     REPEAT LITERAL(8), MOVWF brkoutpx + 24 + REPEATER; set "on" color
  00000008                M _4478COUNT = (((ASM_MSB | (8))) & ~ASM_MSB)
                          M     movwf_banksafe brkoutpx + 24 + REPEATER
                          M ;    EXPAND_PUSH FALSE
                          M     if (brkoutpx + 24 + REPEATER) & INDF0_special
                          M ;        EXPAND_RESTORE; NOEXPAND
                          M         EMIT MOVWI_opc(FSR0, brkoutpx + 24 + REPEATER);;
                          M ;       NOEXPAND  ;reduce clutter
                          M     else
                          M         if (brkoutpx + 24 + REPEATER) & INDF1_special
                          M ;           EXPAND_RESTORE; NOEXPAND
                          M             EMIT MOVWI_opc(FSR1, brkoutpx + 24 + REPEATER);;
                          M ;           NOEXPAND  ;reduce clutter
                          M         else
                          M ;           if reg != WREG
                          M             BANKCHK brkoutpx + 24 + REPEATER;
019F   0140               M     banksel brkoutpx + 24 + REPEATER
                          M ;               BANKSAFE movwf dest; NOARG
                          M             BANKSAFE EMIT movwf brkoutpx + 24 + REPEATER;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1967
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf brkoutpx + 24 + REPEATER
01A0   00B8               M     movwf brkoutpx + 24 + REPEATER
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M         endif
                          M     endif
                          M ;    EXPAND_POP
                          M     movwf_banksafe brkoutpx + 24 + REPEATER
                          M ;    EXPAND_PUSH FALSE
                          M     if (brkoutpx + 24 + REPEATER) & INDF0_special
                          M ;        EXPAND_RESTORE; NOEXPAND
                          M         EMIT MOVWI_opc(FSR0, brkoutpx + 24 + REPEATER);;
                          M ;       NOEXPAND  ;reduce clutter
                          M     else
                          M         if (brkoutpx + 24 + REPEATER) & INDF1_special
                          M ;           EXPAND_RESTORE; NOEXPAND
                          M             EMIT MOVWI_opc(FSR1, brkoutpx + 24 + REPEATER);;
                          M ;           NOEXPAND  ;reduce clutter
                          M         else
                          M ;           if reg != WREG
                          M             BANKCHK brkoutpx + 24 + REPEATER;
                          M ;               BANKSAFE movwf dest; NOARG
                          M             BANKSAFE EMIT movwf brkoutpx + 24 + REPEATER;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1967
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf brkoutpx + 24 + REPEATER
01A1   00B9               M     movwf brkoutpx + 24 + REPEATER
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M         endif
                          M     endif
                          M ;    EXPAND_POP
                          M     movwf_banksafe brkoutpx + 24 + REPEATER
                          M ;    EXPAND_PUSH FALSE
                          M     if (brkoutpx + 24 + REPEATER) & INDF0_special
                          M ;        EXPAND_RESTORE; NOEXPAND
                          M         EMIT MOVWI_opc(FSR0, brkoutpx + 24 + REPEATER);;
                          M ;       NOEXPAND  ;reduce clutter
                          M     else
                          M         if (brkoutpx + 24 + REPEATER) & INDF1_special
                          M ;           EXPAND_RESTORE; NOEXPAND
                          M             EMIT MOVWI_opc(FSR1, brkoutpx + 24 + REPEATER);;
                          M ;           NOEXPAND  ;reduce clutter
                          M         else
                          M ;           if reg != WREG
                          M             BANKCHK brkoutpx + 24 + REPEATER;
                          M ;               BANKSAFE movwf dest; NOARG
                          M             BANKSAFE EMIT movwf brkoutpx + 24 + REPEATER;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1967
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf brkoutpx + 24 + REPEATER
01A2   00BA               M     movwf brkoutpx + 24 + REPEATER
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M         endif
                          M     endif
                          M ;    EXPAND_POP
                          M     movwf_banksafe brkoutpx + 24 + REPEATER
                          M ;    EXPAND_PUSH FALSE
                          M     if (brkoutpx + 24 + REPEATER) & INDF0_special
                          M ;        EXPAND_RESTORE; NOEXPAND
                          M         EMIT MOVWI_opc(FSR0, brkoutpx + 24 + REPEATER);;
                          M ;       NOEXPAND  ;reduce clutter
                          M     else
                          M         if (brkoutpx + 24 + REPEATER) & INDF1_special
                          M ;           EXPAND_RESTORE; NOEXPAND
                          M             EMIT MOVWI_opc(FSR1, brkoutpx + 24 + REPEATER);;
                          M ;           NOEXPAND  ;reduce clutter
                          M         else
                          M ;           if reg != WREG
                          M             BANKCHK brkoutpx + 24 + REPEATER;
                          M ;               BANKSAFE movwf dest; NOARG
                          M             BANKSAFE EMIT movwf brkoutpx + 24 + REPEATER;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1967
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf brkoutpx + 24 + REPEATER
01A3   00BB               M     movwf brkoutpx + 24 + REPEATER
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M         endif
                          M     endif
                          M ;    EXPAND_POP
                          M     movwf_banksafe brkoutpx + 24 + REPEATER
                          M ;    EXPAND_PUSH FALSE
                          M     if (brkoutpx + 24 + REPEATER) & INDF0_special
                          M ;        EXPAND_RESTORE; NOEXPAND
                          M         EMIT MOVWI_opc(FSR0, brkoutpx + 24 + REPEATER);;
                          M ;       NOEXPAND  ;reduce clutter
                          M     else
                          M         if (brkoutpx + 24 + REPEATER) & INDF1_special
                          M ;           EXPAND_RESTORE; NOEXPAND
                          M             EMIT MOVWI_opc(FSR1, brkoutpx + 24 + REPEATER);;
                          M ;           NOEXPAND  ;reduce clutter
                          M         else
                          M ;           if reg != WREG
                          M             BANKCHK brkoutpx + 24 + REPEATER;
                          M ;               BANKSAFE movwf dest; NOARG
                          M             BANKSAFE EMIT movwf brkoutpx + 24 + REPEATER;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1967
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf brkoutpx + 24 + REPEATER
01A4   00BC               M     movwf brkoutpx + 24 + REPEATER
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M         endif
                          M     endif
                          M ;    EXPAND_POP
                          M     movwf_banksafe brkoutpx + 24 + REPEATER
                          M ;    EXPAND_PUSH FALSE
                          M     if (brkoutpx + 24 + REPEATER) & INDF0_special
                          M ;        EXPAND_RESTORE; NOEXPAND
                          M         EMIT MOVWI_opc(FSR0, brkoutpx + 24 + REPEATER);;
                          M ;       NOEXPAND  ;reduce clutter
                          M     else
                          M         if (brkoutpx + 24 + REPEATER) & INDF1_special
                          M ;           EXPAND_RESTORE; NOEXPAND
                          M             EMIT MOVWI_opc(FSR1, brkoutpx + 24 + REPEATER);;
                          M ;           NOEXPAND  ;reduce clutter
                          M         else
                          M ;           if reg != WREG
                          M             BANKCHK brkoutpx + 24 + REPEATER;
                          M ;               BANKSAFE movwf dest; NOARG
                          M             BANKSAFE EMIT movwf brkoutpx + 24 + REPEATER;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1967
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf brkoutpx + 24 + REPEATER
01A5   00BD               M     movwf brkoutpx + 24 + REPEATER
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M         endif
                          M     endif
                          M ;    EXPAND_POP
                          M     movwf_banksafe brkoutpx + 24 + REPEATER
                          M ;    EXPAND_PUSH FALSE
                          M     if (brkoutpx + 24 + REPEATER) & INDF0_special
                          M ;        EXPAND_RESTORE; NOEXPAND
                          M         EMIT MOVWI_opc(FSR0, brkoutpx + 24 + REPEATER);;
                          M ;       NOEXPAND  ;reduce clutter
                          M     else
                          M         if (brkoutpx + 24 + REPEATER) & INDF1_special
                          M ;           EXPAND_RESTORE; NOEXPAND
                          M             EMIT MOVWI_opc(FSR1, brkoutpx + 24 + REPEATER);;
                          M ;           NOEXPAND  ;reduce clutter
                          M         else
                          M ;           if reg != WREG
                          M             BANKCHK brkoutpx + 24 + REPEATER;
                          M ;               BANKSAFE movwf dest; NOARG
                          M             BANKSAFE EMIT movwf brkoutpx + 24 + REPEATER;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1967
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf brkoutpx + 24 + REPEATER
01A6   00BE               M     movwf brkoutpx + 24 + REPEATER
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M         endif
                          M     endif
                          M ;    EXPAND_POP
                          M     movwf_banksafe brkoutpx + 24 + REPEATER
                          M ;    EXPAND_PUSH FALSE
                          M     if (brkoutpx + 24 + REPEATER) & INDF0_special
                          M ;        EXPAND_RESTORE; NOEXPAND
                          M         EMIT MOVWI_opc(FSR0, brkoutpx + 24 + REPEATER);;
                          M ;       NOEXPAND  ;reduce clutter
                          M     else
                          M         if (brkoutpx + 24 + REPEATER) & INDF1_special
                          M ;           EXPAND_RESTORE; NOEXPAND
                          M             EMIT MOVWI_opc(FSR1, brkoutpx + 24 + REPEATER);;
                          M ;           NOEXPAND  ;reduce clutter
                          M         else
                          M ;           if reg != WREG
                          M             BANKCHK brkoutpx + 24 + REPEATER;
                          M ;               BANKSAFE movwf dest; NOARG
                          M             BANKSAFE EMIT movwf brkoutpx + 24 + REPEATER;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1967
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf brkoutpx + 24 + REPEATER
01A7   00BF               M     movwf brkoutpx + 24 + REPEATER
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M         endif
                          M     endif
                          M ;    EXPAND_POP
                      00236     MOVLW FPS_RGBINX;
01A8   3003               M     movlw FPS_RGBINX
                      00237     ifbit FPS, 7, TRUE, MOVLW FPS_RGBINX_ALT; kludge: use top bit for heartbeat color
                          M     movlw_tracker FPS_RGBINX_ALT
                          M ;    EXPAND_PUSH FALSE
                          M ;    andlw arg
                          M     ERRIF((FPS_RGBINX_ALT) & ~0xFF, [ERROR] extra MOV bits ignored: 0          @2437)
                          M     if WREG_TRACKER != LITERAL(FPS_RGBINX_ALT)
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M ;    messg movlw_tracker: "value" #v(value) value @2440
                          M         EMIT movlw FPS_RGBINX_ALT; #v(value); PROGDCL 0x3000 | (value)
01AA   3005               M     movlw FPS_RGBINX_ALT
                          M ;    NOEXPAND; reduce clutter
  80000005                M WREG_TRACKER = LITERAL(FPS_RGBINX_ALT)
                          M     endif
                          M ;    EXPAND_POP
01A9                      M     ORG ctx_addr_102
01AB                      M     ORG ctx_addr_103
                      00238 ;    setbit FPS, 7, FALSE; strip heartbeat parity before render
                      00239     REPEAT LITERAL(8), set_fps_pxbit REPEATER; set "off" color
  00000008                M _4668COUNT = (((ASM_MSB | (8))) & ~ASM_MSB)
                          M     set_fps_pxbit REPEATER
                          M ;    BANKCHK brkoutpx;
                          M ;    messg TODO ^^^ fix banksel in ifbit @227
                          M     ifbit IIF(REPEATER == 7, LITERAL(0), FPS), 7 - REPEATER, TRUE, MOVWF brkoutpx + 24 + REPEATER;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND  ;reduce clutter
                          M ;    if (SRC == DEST) && ((srcbytes) == (destbytes)) && !(reverse)  ;nothing to do
                          M ;    LOCAL BIT = bit ;kludge; force eval (avoids "missing operand" and "missing argument" errors/MPASM bugs); also helps avoid "line too long" messages (MPASM limit 200)
  0075                    M     LOCAL REG = (FPS) ;kludge; force eval (avoids "missing operand" and "missing argument" errors/MPASM bugs); also helps avoid "line too long" messages (MPASM limit 200)
                          M ;    messg "mov8", #v(DEST), #v(SRC), #v(ISLIT(SRC)), #v(LIT2VAL(SRC)) @2804
                          M ;    messg src, dest @2805;
                          M     if ISLIT((FPS)); ; compile-time check
                          M         if BOOL2INT(LIT2VAL((FPS)) & BIT(7 - REPEATER)) == BOOL2INT(1)
                          M ;           EXPAND_PUSH TRUE
                          M             EMIT movwf_banksafe brkoutpx + 24 + REPEATER
                          M ;           EXPAND_POP
                          M         endif
                          M ;        EXPAND_POP
                          M         exitm
                          M     endif
                          M ;    BANKCHK reg;
                          M ;    if BOOL2INT(bitval)
                          M ;       BANKSAFE bitnum_arg(bitnum) btfsc reg;, bitnum;
                          M ;    else
                          M ;       BANKSAFE bitnum_arg(bitnum) btfss reg;, bitnum;
                          M ;    endif
                          M ;;    LOCAL BEFORE_STMT = $
                          M ;;STMT_ADDR#v(STMT_COUNTER) = 0-$
                          M ;    LOCAL STMT_ADDR
                          M ;STMT_INSTR = 0 - $
                          M ;    LOCAL SVWREG = WREG_TRACKER
                          M ;    EXPAND_RESTORE
                          M ;    stmt
                          M ;    NOEXPAND  ;reduce clutter
                          M ;    if WREG_TRACKER != SVWREG
                          M ;       DROP_WREG
                          M ;;      messg WREG unknown here, conditional stmt might have changed it @2831
                          M ;    endif
                          M ;;STMT_ADDR#v(STMT_COUNTER) += $
                          M ;STMT_INSTR += $
                          M ;;    LOCAL STMT_INSTR = STMT_ADDR; #v(STMT_COUNTER)
                          M ;;STMT_COUNTER += 1
                          M ;;    LOCAL AFTER_STMT = 0; $ - (BEFORE_STMT + 1)
                          M ;    WARNIF((STMT_INSTR != 1) && !ISLIT(reg), [ERROR] if-ed stmt !1 opcode: #v(STMT_INSTR), @2838); use warn to allow compile to continue
  0068                    M     LOCAL NUM_IFBIT = NUM_CONTEXT; kludge: need unique symbols
  01AB                    M     LOCAL has_banksel = $
                          M     BANKCHK (FPS); do this before allocating fized-sized placeholder
  00000000                M has_banksel -= $
  01AB                    M     LOCAL before_addr = $, before_bank = BANK_TRACKER;, before_wreg = WREG_TRACKER
                          M     CONTEXT_SAVE before_104
  00000068                M before_104 EQU 104; allow context access by caller-supplied name
  00000069                M NUM_CONTEXT += 1
  01AB                    M     VARIABLE ctx_addr_104      = $
  0005                    M     VARIABLE ctx_wreg_104      = WREG_TRACKER
  0038                    M     VARIABLE ctx_bank_104      = BANK_TRACKER
  018A                    M     VARIABLE ctx_page_104      = PAGE_TRACKER
                          M ;no, let stmt change it;    DROP_CONTEXT
                          M ;    messg save ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @2059
01AC                      M     ORG before_addr + 1; leave placeholder for btf; backfill after checking for idler
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf_banksafe brkoutpx + 24 + REPEATER;
                          M     movwf_banksafe brkoutpx + 24 + REPEATER
                          M ;    EXPAND_PUSH FALSE
                          M     if (brkoutpx + 24 + REPEATER) & INDF0_special
                          M ;        EXPAND_RESTORE; NOEXPAND
                          M         EMIT MOVWI_opc(FSR0, brkoutpx + 24 + REPEATER);;
                          M ;       NOEXPAND  ;reduce clutter
                          M     else
                          M         if (brkoutpx + 24 + REPEATER) & INDF1_special
                          M ;           EXPAND_RESTORE; NOEXPAND
                          M             EMIT MOVWI_opc(FSR1, brkoutpx + 24 + REPEATER);;
                          M ;           NOEXPAND  ;reduce clutter
                          M         else
                          M ;           if reg != WREG
                          M             BANKCHK brkoutpx + 24 + REPEATER;
                          M ;               BANKSAFE movwf dest; NOARG
                          M             BANKSAFE EMIT movwf brkoutpx + 24 + REPEATER;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1967
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf brkoutpx + 24 + REPEATER
01AC   00B8               M     movwf brkoutpx + 24 + REPEATER
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M         endif
                          M     endif
                          M ;    EXPAND_POP
                          M ;    EXPAND_POP
  01AD                    M     LOCAL after_addr = $, after_bank = BANK_TRACKER;, after_wreg = WREG_TRACKER
                          M     CONTEXT_SAVE after_104
  00000069                M after_104 EQU 105; allow context access by caller-supplied name
  0000006A                M NUM_CONTEXT += 1
  01AD                    M     VARIABLE ctx_addr_105      = $
  0005                    M     VARIABLE ctx_wreg_105      = WREG_TRACKER
  0038                    M     VARIABLE ctx_bank_105      = BANK_TRACKER
  018A                    M     VARIABLE ctx_page_105      = PAGE_TRACKER
                          M ;no, let stmt change it;    DROP_CONTEXT
                          M ;    messg save ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @2059
  0000                    M     LOCAL bank_changed = BANKOF(after_bank);;
  00000000                M bank_changed -= BANKOF(before_bank); ; line too long :(
                          M ;    ORG before_addr
                          M ;BANK_TRACKER = before_bank
                          M ;WREG_TRACKER = before_wreg
                          M     CONTEXT_RESTORE before_104
                          M ;    messg restore ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @2063
                          M     EMIT ORG ctx_addr_104;
01AB                      M     ORG ctx_addr_104
  80000005                M WREG_TRACKER = ctx_wreg_104
  00000038                M BANK_TRACKER = ctx_bank_104
  0000018A                M PAGE_TRACKER = ctx_page_104
                          M     if after_addr == before_addr + 1; no stmt
                          M         WARNIF(has_banksel, [INFO] emitted extraneous banksel (no movwf_banksafe brkoutpx + 24 + REPEATER for ifbit) @2858);;
                          M     else; back-fill btf instr
                          M         if BOOL2INT(1)
                          M             BANKSAFE bitnum_arg(7 - REPEATER) btfsc (FPS);, bitnum;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1967
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     withbit_7 btfsc (FPS)
01AB   1BF5               M     btfsc (FPS), 7
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M         else
                          M             BANKSAFE bitnum_arg(7 - REPEATER) btfss (FPS);, bitnum;
                          M         endif
                          M ;       ORG after_addr
                          M ;BANK_TRACKER = after_bank
                          M ;WREG_TRACKER = after_wreg
                          M         CONTEXT_RESTORE after_104
                          M ;    messg restore ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @2063
                          M     EMIT ORG ctx_addr_105;
01AD                      M     ORG ctx_addr_105
  80000005                M WREG_TRACKER = ctx_wreg_105
  00000038                M BANK_TRACKER = ctx_bank_105
  0000018A                M PAGE_TRACKER = ctx_page_105
                          M     endif
                          M ;    EXPAND_POP
  00000069                M NUM_IFBIT += 1; kludge: need unique labels
                          M     set_fps_pxbit REPEATER
                          M ;    BANKCHK brkoutpx;
                          M ;    messg TODO ^^^ fix banksel in ifbit @227
                          M     ifbit IIF(REPEATER == 7, LITERAL(0), FPS), 7 - REPEATER, TRUE, MOVWF brkoutpx + 24 + REPEATER;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND  ;reduce clutter
                          M ;    if (SRC == DEST) && ((srcbytes) == (destbytes)) && !(reverse)  ;nothing to do
                          M ;    LOCAL BIT = bit ;kludge; force eval (avoids "missing operand" and "missing argument" errors/MPASM bugs); also helps avoid "line too long" messages (MPASM limit 200)
  0075                    M     LOCAL REG = (FPS) ;kludge; force eval (avoids "missing operand" and "missing argument" errors/MPASM bugs); also helps avoid "line too long" messages (MPASM limit 200)
                          M ;    messg "mov8", #v(DEST), #v(SRC), #v(ISLIT(SRC)), #v(LIT2VAL(SRC)) @2804
                          M ;    messg src, dest @2805;
                          M     if ISLIT((FPS)); ; compile-time check
                          M         if BOOL2INT(LIT2VAL((FPS)) & BIT(7 - REPEATER)) == BOOL2INT(1)
                          M ;           EXPAND_PUSH TRUE
                          M             EMIT movwf_banksafe brkoutpx + 24 + REPEATER
                          M ;           EXPAND_POP
                          M         endif
                          M ;        EXPAND_POP
                          M         exitm
                          M     endif
                          M ;    BANKCHK reg;
                          M ;    if BOOL2INT(bitval)
                          M ;       BANKSAFE bitnum_arg(bitnum) btfsc reg;, bitnum;
                          M ;    else
                          M ;       BANKSAFE bitnum_arg(bitnum) btfss reg;, bitnum;
                          M ;    endif
                          M ;;    LOCAL BEFORE_STMT = $
                          M ;;STMT_ADDR#v(STMT_COUNTER) = 0-$
                          M ;    LOCAL STMT_ADDR
                          M ;STMT_INSTR = 0 - $
                          M ;    LOCAL SVWREG = WREG_TRACKER
                          M ;    EXPAND_RESTORE
                          M ;    stmt
                          M ;    NOEXPAND  ;reduce clutter
                          M ;    if WREG_TRACKER != SVWREG
                          M ;       DROP_WREG
                          M ;;      messg WREG unknown here, conditional stmt might have changed it @2831
                          M ;    endif
                          M ;;STMT_ADDR#v(STMT_COUNTER) += $
                          M ;STMT_INSTR += $
                          M ;;    LOCAL STMT_INSTR = STMT_ADDR; #v(STMT_COUNTER)
                          M ;;STMT_COUNTER += 1
                          M ;;    LOCAL AFTER_STMT = 0; $ - (BEFORE_STMT + 1)
                          M ;    WARNIF((STMT_INSTR != 1) && !ISLIT(reg), [ERROR] if-ed stmt !1 opcode: #v(STMT_INSTR), @2838); use warn to allow compile to continue
  006A                    M     LOCAL NUM_IFBIT = NUM_CONTEXT; kludge: need unique symbols
  01AD                    M     LOCAL has_banksel = $
                          M     BANKCHK (FPS); do this before allocating fized-sized placeholder
  00000000                M has_banksel -= $
  01AD                    M     LOCAL before_addr = $, before_bank = BANK_TRACKER;, before_wreg = WREG_TRACKER
                          M     CONTEXT_SAVE before_106
  0000006A                M before_106 EQU 106; allow context access by caller-supplied name
  0000006B                M NUM_CONTEXT += 1
  01AD                    M     VARIABLE ctx_addr_106      = $
  0005                    M     VARIABLE ctx_wreg_106      = WREG_TRACKER
  0038                    M     VARIABLE ctx_bank_106      = BANK_TRACKER
  018A                    M     VARIABLE ctx_page_106      = PAGE_TRACKER
                          M ;no, let stmt change it;    DROP_CONTEXT
                          M ;    messg save ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @2059
01AE                      M     ORG before_addr + 1; leave placeholder for btf; backfill after checking for idler
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf_banksafe brkoutpx + 24 + REPEATER;
                          M     movwf_banksafe brkoutpx + 24 + REPEATER
                          M ;    EXPAND_PUSH FALSE
                          M     if (brkoutpx + 24 + REPEATER) & INDF0_special
                          M ;        EXPAND_RESTORE; NOEXPAND
                          M         EMIT MOVWI_opc(FSR0, brkoutpx + 24 + REPEATER);;
                          M ;       NOEXPAND  ;reduce clutter
                          M     else
                          M         if (brkoutpx + 24 + REPEATER) & INDF1_special
                          M ;           EXPAND_RESTORE; NOEXPAND
                          M             EMIT MOVWI_opc(FSR1, brkoutpx + 24 + REPEATER);;
                          M ;           NOEXPAND  ;reduce clutter
                          M         else
                          M ;           if reg != WREG
                          M             BANKCHK brkoutpx + 24 + REPEATER;
                          M ;               BANKSAFE movwf dest; NOARG
                          M             BANKSAFE EMIT movwf brkoutpx + 24 + REPEATER;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1967
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf brkoutpx + 24 + REPEATER
01AE   00B9               M     movwf brkoutpx + 24 + REPEATER
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M         endif
                          M     endif
                          M ;    EXPAND_POP
                          M ;    EXPAND_POP
  01AF                    M     LOCAL after_addr = $, after_bank = BANK_TRACKER;, after_wreg = WREG_TRACKER
                          M     CONTEXT_SAVE after_106
  0000006B                M after_106 EQU 107; allow context access by caller-supplied name
  0000006C                M NUM_CONTEXT += 1
  01AF                    M     VARIABLE ctx_addr_107      = $
  0005                    M     VARIABLE ctx_wreg_107      = WREG_TRACKER
  0038                    M     VARIABLE ctx_bank_107      = BANK_TRACKER
  018A                    M     VARIABLE ctx_page_107      = PAGE_TRACKER
                          M ;no, let stmt change it;    DROP_CONTEXT
                          M ;    messg save ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @2059
  0000                    M     LOCAL bank_changed = BANKOF(after_bank);;
  00000000                M bank_changed -= BANKOF(before_bank); ; line too long :(
                          M ;    ORG before_addr
                          M ;BANK_TRACKER = before_bank
                          M ;WREG_TRACKER = before_wreg
                          M     CONTEXT_RESTORE before_106
                          M ;    messg restore ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @2063
                          M     EMIT ORG ctx_addr_106;
01AD                      M     ORG ctx_addr_106
  80000005                M WREG_TRACKER = ctx_wreg_106
  00000038                M BANK_TRACKER = ctx_bank_106
  0000018A                M PAGE_TRACKER = ctx_page_106
                          M     if after_addr == before_addr + 1; no stmt
                          M         WARNIF(has_banksel, [INFO] emitted extraneous banksel (no movwf_banksafe brkoutpx + 24 + REPEATER for ifbit) @2858);;
                          M     else; back-fill btf instr
                          M         if BOOL2INT(1)
                          M             BANKSAFE bitnum_arg(7 - REPEATER) btfsc (FPS);, bitnum;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1967
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     withbit_6 btfsc (FPS)
01AD   1B75               M     btfsc (FPS), 6
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M         else
                          M             BANKSAFE bitnum_arg(7 - REPEATER) btfss (FPS);, bitnum;
                          M         endif
                          M ;       ORG after_addr
                          M ;BANK_TRACKER = after_bank
                          M ;WREG_TRACKER = after_wreg
                          M         CONTEXT_RESTORE after_106
                          M ;    messg restore ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @2063
                          M     EMIT ORG ctx_addr_107;
01AF                      M     ORG ctx_addr_107
  80000005                M WREG_TRACKER = ctx_wreg_107
  00000038                M BANK_TRACKER = ctx_bank_107
  0000018A                M PAGE_TRACKER = ctx_page_107
                          M     endif
                          M ;    EXPAND_POP
  0000006B                M NUM_IFBIT += 1; kludge: need unique labels
                          M     set_fps_pxbit REPEATER
                          M ;    BANKCHK brkoutpx;
                          M ;    messg TODO ^^^ fix banksel in ifbit @227
                          M     ifbit IIF(REPEATER == 7, LITERAL(0), FPS), 7 - REPEATER, TRUE, MOVWF brkoutpx + 24 + REPEATER;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND  ;reduce clutter
                          M ;    if (SRC == DEST) && ((srcbytes) == (destbytes)) && !(reverse)  ;nothing to do
                          M ;    LOCAL BIT = bit ;kludge; force eval (avoids "missing operand" and "missing argument" errors/MPASM bugs); also helps avoid "line too long" messages (MPASM limit 200)
  0075                    M     LOCAL REG = (FPS) ;kludge; force eval (avoids "missing operand" and "missing argument" errors/MPASM bugs); also helps avoid "line too long" messages (MPASM limit 200)
                          M ;    messg "mov8", #v(DEST), #v(SRC), #v(ISLIT(SRC)), #v(LIT2VAL(SRC)) @2804
                          M ;    messg src, dest @2805;
                          M     if ISLIT((FPS)); ; compile-time check
                          M         if BOOL2INT(LIT2VAL((FPS)) & BIT(7 - REPEATER)) == BOOL2INT(1)
                          M ;           EXPAND_PUSH TRUE
                          M             EMIT movwf_banksafe brkoutpx + 24 + REPEATER
                          M ;           EXPAND_POP
                          M         endif
                          M ;        EXPAND_POP
                          M         exitm
                          M     endif
                          M ;    BANKCHK reg;
                          M ;    if BOOL2INT(bitval)
                          M ;       BANKSAFE bitnum_arg(bitnum) btfsc reg;, bitnum;
                          M ;    else
                          M ;       BANKSAFE bitnum_arg(bitnum) btfss reg;, bitnum;
                          M ;    endif
                          M ;;    LOCAL BEFORE_STMT = $
                          M ;;STMT_ADDR#v(STMT_COUNTER) = 0-$
                          M ;    LOCAL STMT_ADDR
                          M ;STMT_INSTR = 0 - $
                          M ;    LOCAL SVWREG = WREG_TRACKER
                          M ;    EXPAND_RESTORE
                          M ;    stmt
                          M ;    NOEXPAND  ;reduce clutter
                          M ;    if WREG_TRACKER != SVWREG
                          M ;       DROP_WREG
                          M ;;      messg WREG unknown here, conditional stmt might have changed it @2831
                          M ;    endif
                          M ;;STMT_ADDR#v(STMT_COUNTER) += $
                          M ;STMT_INSTR += $
                          M ;;    LOCAL STMT_INSTR = STMT_ADDR; #v(STMT_COUNTER)
                          M ;;STMT_COUNTER += 1
                          M ;;    LOCAL AFTER_STMT = 0; $ - (BEFORE_STMT + 1)
                          M ;    WARNIF((STMT_INSTR != 1) && !ISLIT(reg), [ERROR] if-ed stmt !1 opcode: #v(STMT_INSTR), @2838); use warn to allow compile to continue
  006C                    M     LOCAL NUM_IFBIT = NUM_CONTEXT; kludge: need unique symbols
  01AF                    M     LOCAL has_banksel = $
                          M     BANKCHK (FPS); do this before allocating fized-sized placeholder
  00000000                M has_banksel -= $
  01AF                    M     LOCAL before_addr = $, before_bank = BANK_TRACKER;, before_wreg = WREG_TRACKER
                          M     CONTEXT_SAVE before_108
  0000006C                M before_108 EQU 108; allow context access by caller-supplied name
  0000006D                M NUM_CONTEXT += 1
  01AF                    M     VARIABLE ctx_addr_108      = $
  0005                    M     VARIABLE ctx_wreg_108      = WREG_TRACKER
  0038                    M     VARIABLE ctx_bank_108      = BANK_TRACKER
  018A                    M     VARIABLE ctx_page_108      = PAGE_TRACKER
                          M ;no, let stmt change it;    DROP_CONTEXT
                          M ;    messg save ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @2059
01B0                      M     ORG before_addr + 1; leave placeholder for btf; backfill after checking for idler
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf_banksafe brkoutpx + 24 + REPEATER;
                          M     movwf_banksafe brkoutpx + 24 + REPEATER
                          M ;    EXPAND_PUSH FALSE
                          M     if (brkoutpx + 24 + REPEATER) & INDF0_special
                          M ;        EXPAND_RESTORE; NOEXPAND
                          M         EMIT MOVWI_opc(FSR0, brkoutpx + 24 + REPEATER);;
                          M ;       NOEXPAND  ;reduce clutter
                          M     else
                          M         if (brkoutpx + 24 + REPEATER) & INDF1_special
                          M ;           EXPAND_RESTORE; NOEXPAND
                          M             EMIT MOVWI_opc(FSR1, brkoutpx + 24 + REPEATER);;
                          M ;           NOEXPAND  ;reduce clutter
                          M         else
                          M ;           if reg != WREG
                          M             BANKCHK brkoutpx + 24 + REPEATER;
                          M ;               BANKSAFE movwf dest; NOARG
                          M             BANKSAFE EMIT movwf brkoutpx + 24 + REPEATER;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1967
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf brkoutpx + 24 + REPEATER
01B0   00BA               M     movwf brkoutpx + 24 + REPEATER
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M         endif
                          M     endif
                          M ;    EXPAND_POP
                          M ;    EXPAND_POP
  01B1                    M     LOCAL after_addr = $, after_bank = BANK_TRACKER;, after_wreg = WREG_TRACKER
                          M     CONTEXT_SAVE after_108
  0000006D                M after_108 EQU 109; allow context access by caller-supplied name
  0000006E                M NUM_CONTEXT += 1
  01B1                    M     VARIABLE ctx_addr_109      = $
  0005                    M     VARIABLE ctx_wreg_109      = WREG_TRACKER
  0038                    M     VARIABLE ctx_bank_109      = BANK_TRACKER
  018A                    M     VARIABLE ctx_page_109      = PAGE_TRACKER
                          M ;no, let stmt change it;    DROP_CONTEXT
                          M ;    messg save ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @2059
  0000                    M     LOCAL bank_changed = BANKOF(after_bank);;
  00000000                M bank_changed -= BANKOF(before_bank); ; line too long :(
                          M ;    ORG before_addr
                          M ;BANK_TRACKER = before_bank
                          M ;WREG_TRACKER = before_wreg
                          M     CONTEXT_RESTORE before_108
                          M ;    messg restore ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @2063
                          M     EMIT ORG ctx_addr_108;
01AF                      M     ORG ctx_addr_108
  80000005                M WREG_TRACKER = ctx_wreg_108
  00000038                M BANK_TRACKER = ctx_bank_108
  0000018A                M PAGE_TRACKER = ctx_page_108
                          M     if after_addr == before_addr + 1; no stmt
                          M         WARNIF(has_banksel, [INFO] emitted extraneous banksel (no movwf_banksafe brkoutpx + 24 + REPEATER for ifbit) @2858);;
                          M     else; back-fill btf instr
                          M         if BOOL2INT(1)
                          M             BANKSAFE bitnum_arg(7 - REPEATER) btfsc (FPS);, bitnum;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1967
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     withbit_5 btfsc (FPS)
01AF   1AF5               M     btfsc (FPS), 5
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M         else
                          M             BANKSAFE bitnum_arg(7 - REPEATER) btfss (FPS);, bitnum;
                          M         endif
                          M ;       ORG after_addr
                          M ;BANK_TRACKER = after_bank
                          M ;WREG_TRACKER = after_wreg
                          M         CONTEXT_RESTORE after_108
                          M ;    messg restore ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @2063
                          M     EMIT ORG ctx_addr_109;
01B1                      M     ORG ctx_addr_109
  80000005                M WREG_TRACKER = ctx_wreg_109
  00000038                M BANK_TRACKER = ctx_bank_109
  0000018A                M PAGE_TRACKER = ctx_page_109
                          M     endif
                          M ;    EXPAND_POP
  0000006D                M NUM_IFBIT += 1; kludge: need unique labels
                          M     set_fps_pxbit REPEATER
                          M ;    BANKCHK brkoutpx;
                          M ;    messg TODO ^^^ fix banksel in ifbit @227
                          M     ifbit IIF(REPEATER == 7, LITERAL(0), FPS), 7 - REPEATER, TRUE, MOVWF brkoutpx + 24 + REPEATER;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND  ;reduce clutter
                          M ;    if (SRC == DEST) && ((srcbytes) == (destbytes)) && !(reverse)  ;nothing to do
                          M ;    LOCAL BIT = bit ;kludge; force eval (avoids "missing operand" and "missing argument" errors/MPASM bugs); also helps avoid "line too long" messages (MPASM limit 200)
  0075                    M     LOCAL REG = (FPS) ;kludge; force eval (avoids "missing operand" and "missing argument" errors/MPASM bugs); also helps avoid "line too long" messages (MPASM limit 200)
                          M ;    messg "mov8", #v(DEST), #v(SRC), #v(ISLIT(SRC)), #v(LIT2VAL(SRC)) @2804
                          M ;    messg src, dest @2805;
                          M     if ISLIT((FPS)); ; compile-time check
                          M         if BOOL2INT(LIT2VAL((FPS)) & BIT(7 - REPEATER)) == BOOL2INT(1)
                          M ;           EXPAND_PUSH TRUE
                          M             EMIT movwf_banksafe brkoutpx + 24 + REPEATER
                          M ;           EXPAND_POP
                          M         endif
                          M ;        EXPAND_POP
                          M         exitm
                          M     endif
                          M ;    BANKCHK reg;
                          M ;    if BOOL2INT(bitval)
                          M ;       BANKSAFE bitnum_arg(bitnum) btfsc reg;, bitnum;
                          M ;    else
                          M ;       BANKSAFE bitnum_arg(bitnum) btfss reg;, bitnum;
                          M ;    endif
                          M ;;    LOCAL BEFORE_STMT = $
                          M ;;STMT_ADDR#v(STMT_COUNTER) = 0-$
                          M ;    LOCAL STMT_ADDR
                          M ;STMT_INSTR = 0 - $
                          M ;    LOCAL SVWREG = WREG_TRACKER
                          M ;    EXPAND_RESTORE
                          M ;    stmt
                          M ;    NOEXPAND  ;reduce clutter
                          M ;    if WREG_TRACKER != SVWREG
                          M ;       DROP_WREG
                          M ;;      messg WREG unknown here, conditional stmt might have changed it @2831
                          M ;    endif
                          M ;;STMT_ADDR#v(STMT_COUNTER) += $
                          M ;STMT_INSTR += $
                          M ;;    LOCAL STMT_INSTR = STMT_ADDR; #v(STMT_COUNTER)
                          M ;;STMT_COUNTER += 1
                          M ;;    LOCAL AFTER_STMT = 0; $ - (BEFORE_STMT + 1)
                          M ;    WARNIF((STMT_INSTR != 1) && !ISLIT(reg), [ERROR] if-ed stmt !1 opcode: #v(STMT_INSTR), @2838); use warn to allow compile to continue
  006E                    M     LOCAL NUM_IFBIT = NUM_CONTEXT; kludge: need unique symbols
  01B1                    M     LOCAL has_banksel = $
                          M     BANKCHK (FPS); do this before allocating fized-sized placeholder
  00000000                M has_banksel -= $
  01B1                    M     LOCAL before_addr = $, before_bank = BANK_TRACKER;, before_wreg = WREG_TRACKER
                          M     CONTEXT_SAVE before_110
  0000006E                M before_110 EQU 110; allow context access by caller-supplied name
  0000006F                M NUM_CONTEXT += 1
  01B1                    M     VARIABLE ctx_addr_110      = $
  0005                    M     VARIABLE ctx_wreg_110      = WREG_TRACKER
  0038                    M     VARIABLE ctx_bank_110      = BANK_TRACKER
  018A                    M     VARIABLE ctx_page_110      = PAGE_TRACKER
                          M ;no, let stmt change it;    DROP_CONTEXT
                          M ;    messg save ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @2059
01B2                      M     ORG before_addr + 1; leave placeholder for btf; backfill after checking for idler
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf_banksafe brkoutpx + 24 + REPEATER;
                          M     movwf_banksafe brkoutpx + 24 + REPEATER
                          M ;    EXPAND_PUSH FALSE
                          M     if (brkoutpx + 24 + REPEATER) & INDF0_special
                          M ;        EXPAND_RESTORE; NOEXPAND
                          M         EMIT MOVWI_opc(FSR0, brkoutpx + 24 + REPEATER);;
                          M ;       NOEXPAND  ;reduce clutter
                          M     else
                          M         if (brkoutpx + 24 + REPEATER) & INDF1_special
                          M ;           EXPAND_RESTORE; NOEXPAND
                          M             EMIT MOVWI_opc(FSR1, brkoutpx + 24 + REPEATER);;
                          M ;           NOEXPAND  ;reduce clutter
                          M         else
                          M ;           if reg != WREG
                          M             BANKCHK brkoutpx + 24 + REPEATER;
                          M ;               BANKSAFE movwf dest; NOARG
                          M             BANKSAFE EMIT movwf brkoutpx + 24 + REPEATER;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1967
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf brkoutpx + 24 + REPEATER
01B2   00BB               M     movwf brkoutpx + 24 + REPEATER
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M         endif
                          M     endif
                          M ;    EXPAND_POP
                          M ;    EXPAND_POP
  01B3                    M     LOCAL after_addr = $, after_bank = BANK_TRACKER;, after_wreg = WREG_TRACKER
                          M     CONTEXT_SAVE after_110
  0000006F                M after_110 EQU 111; allow context access by caller-supplied name
  00000070                M NUM_CONTEXT += 1
  01B3                    M     VARIABLE ctx_addr_111      = $
  0005                    M     VARIABLE ctx_wreg_111      = WREG_TRACKER
  0038                    M     VARIABLE ctx_bank_111      = BANK_TRACKER
  018A                    M     VARIABLE ctx_page_111      = PAGE_TRACKER
                          M ;no, let stmt change it;    DROP_CONTEXT
                          M ;    messg save ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @2059
  0000                    M     LOCAL bank_changed = BANKOF(after_bank);;
  00000000                M bank_changed -= BANKOF(before_bank); ; line too long :(
                          M ;    ORG before_addr
                          M ;BANK_TRACKER = before_bank
                          M ;WREG_TRACKER = before_wreg
                          M     CONTEXT_RESTORE before_110
                          M ;    messg restore ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @2063
                          M     EMIT ORG ctx_addr_110;
01B1                      M     ORG ctx_addr_110
  80000005                M WREG_TRACKER = ctx_wreg_110
  00000038                M BANK_TRACKER = ctx_bank_110
  0000018A                M PAGE_TRACKER = ctx_page_110
                          M     if after_addr == before_addr + 1; no stmt
                          M         WARNIF(has_banksel, [INFO] emitted extraneous banksel (no movwf_banksafe brkoutpx + 24 + REPEATER for ifbit) @2858);;
                          M     else; back-fill btf instr
                          M         if BOOL2INT(1)
                          M             BANKSAFE bitnum_arg(7 - REPEATER) btfsc (FPS);, bitnum;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1967
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     withbit_4 btfsc (FPS)
01B1   1A75               M     btfsc (FPS), 4
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M         else
                          M             BANKSAFE bitnum_arg(7 - REPEATER) btfss (FPS);, bitnum;
                          M         endif
                          M ;       ORG after_addr
                          M ;BANK_TRACKER = after_bank
                          M ;WREG_TRACKER = after_wreg
                          M         CONTEXT_RESTORE after_110
                          M ;    messg restore ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @2063
                          M     EMIT ORG ctx_addr_111;
01B3                      M     ORG ctx_addr_111
  80000005                M WREG_TRACKER = ctx_wreg_111
  00000038                M BANK_TRACKER = ctx_bank_111
  0000018A                M PAGE_TRACKER = ctx_page_111
                          M     endif
                          M ;    EXPAND_POP
  0000006F                M NUM_IFBIT += 1; kludge: need unique labels
                          M     set_fps_pxbit REPEATER
                          M ;    BANKCHK brkoutpx;
                          M ;    messg TODO ^^^ fix banksel in ifbit @227
                          M     ifbit IIF(REPEATER == 7, LITERAL(0), FPS), 7 - REPEATER, TRUE, MOVWF brkoutpx + 24 + REPEATER;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND  ;reduce clutter
                          M ;    if (SRC == DEST) && ((srcbytes) == (destbytes)) && !(reverse)  ;nothing to do
                          M ;    LOCAL BIT = bit ;kludge; force eval (avoids "missing operand" and "missing argument" errors/MPASM bugs); also helps avoid "line too long" messages (MPASM limit 200)
  0075                    M     LOCAL REG = (FPS) ;kludge; force eval (avoids "missing operand" and "missing argument" errors/MPASM bugs); also helps avoid "line too long" messages (MPASM limit 200)
                          M ;    messg "mov8", #v(DEST), #v(SRC), #v(ISLIT(SRC)), #v(LIT2VAL(SRC)) @2804
                          M ;    messg src, dest @2805;
                          M     if ISLIT((FPS)); ; compile-time check
                          M         if BOOL2INT(LIT2VAL((FPS)) & BIT(7 - REPEATER)) == BOOL2INT(1)
                          M ;           EXPAND_PUSH TRUE
                          M             EMIT movwf_banksafe brkoutpx + 24 + REPEATER
                          M ;           EXPAND_POP
                          M         endif
                          M ;        EXPAND_POP
                          M         exitm
                          M     endif
                          M ;    BANKCHK reg;
                          M ;    if BOOL2INT(bitval)
                          M ;       BANKSAFE bitnum_arg(bitnum) btfsc reg;, bitnum;
                          M ;    else
                          M ;       BANKSAFE bitnum_arg(bitnum) btfss reg;, bitnum;
                          M ;    endif
                          M ;;    LOCAL BEFORE_STMT = $
                          M ;;STMT_ADDR#v(STMT_COUNTER) = 0-$
                          M ;    LOCAL STMT_ADDR
                          M ;STMT_INSTR = 0 - $
                          M ;    LOCAL SVWREG = WREG_TRACKER
                          M ;    EXPAND_RESTORE
                          M ;    stmt
                          M ;    NOEXPAND  ;reduce clutter
                          M ;    if WREG_TRACKER != SVWREG
                          M ;       DROP_WREG
                          M ;;      messg WREG unknown here, conditional stmt might have changed it @2831
                          M ;    endif
                          M ;;STMT_ADDR#v(STMT_COUNTER) += $
                          M ;STMT_INSTR += $
                          M ;;    LOCAL STMT_INSTR = STMT_ADDR; #v(STMT_COUNTER)
                          M ;;STMT_COUNTER += 1
                          M ;;    LOCAL AFTER_STMT = 0; $ - (BEFORE_STMT + 1)
                          M ;    WARNIF((STMT_INSTR != 1) && !ISLIT(reg), [ERROR] if-ed stmt !1 opcode: #v(STMT_INSTR), @2838); use warn to allow compile to continue
  0070                    M     LOCAL NUM_IFBIT = NUM_CONTEXT; kludge: need unique symbols
  01B3                    M     LOCAL has_banksel = $
                          M     BANKCHK (FPS); do this before allocating fized-sized placeholder
  00000000                M has_banksel -= $
  01B3                    M     LOCAL before_addr = $, before_bank = BANK_TRACKER;, before_wreg = WREG_TRACKER
                          M     CONTEXT_SAVE before_112
  00000070                M before_112 EQU 112; allow context access by caller-supplied name
  00000071                M NUM_CONTEXT += 1
  01B3                    M     VARIABLE ctx_addr_112      = $
  0005                    M     VARIABLE ctx_wreg_112      = WREG_TRACKER
  0038                    M     VARIABLE ctx_bank_112      = BANK_TRACKER
  018A                    M     VARIABLE ctx_page_112      = PAGE_TRACKER
                          M ;no, let stmt change it;    DROP_CONTEXT
                          M ;    messg save ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @2059
01B4                      M     ORG before_addr + 1; leave placeholder for btf; backfill after checking for idler
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf_banksafe brkoutpx + 24 + REPEATER;
                          M     movwf_banksafe brkoutpx + 24 + REPEATER
                          M ;    EXPAND_PUSH FALSE
                          M     if (brkoutpx + 24 + REPEATER) & INDF0_special
                          M ;        EXPAND_RESTORE; NOEXPAND
                          M         EMIT MOVWI_opc(FSR0, brkoutpx + 24 + REPEATER);;
                          M ;       NOEXPAND  ;reduce clutter
                          M     else
                          M         if (brkoutpx + 24 + REPEATER) & INDF1_special
                          M ;           EXPAND_RESTORE; NOEXPAND
                          M             EMIT MOVWI_opc(FSR1, brkoutpx + 24 + REPEATER);;
                          M ;           NOEXPAND  ;reduce clutter
                          M         else
                          M ;           if reg != WREG
                          M             BANKCHK brkoutpx + 24 + REPEATER;
                          M ;               BANKSAFE movwf dest; NOARG
                          M             BANKSAFE EMIT movwf brkoutpx + 24 + REPEATER;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1967
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf brkoutpx + 24 + REPEATER
01B4   00BC               M     movwf brkoutpx + 24 + REPEATER
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M         endif
                          M     endif
                          M ;    EXPAND_POP
                          M ;    EXPAND_POP
  01B5                    M     LOCAL after_addr = $, after_bank = BANK_TRACKER;, after_wreg = WREG_TRACKER
                          M     CONTEXT_SAVE after_112
  00000071                M after_112 EQU 113; allow context access by caller-supplied name
  00000072                M NUM_CONTEXT += 1
  01B5                    M     VARIABLE ctx_addr_113      = $
  0005                    M     VARIABLE ctx_wreg_113      = WREG_TRACKER
  0038                    M     VARIABLE ctx_bank_113      = BANK_TRACKER
  018A                    M     VARIABLE ctx_page_113      = PAGE_TRACKER
                          M ;no, let stmt change it;    DROP_CONTEXT
                          M ;    messg save ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @2059
  0000                    M     LOCAL bank_changed = BANKOF(after_bank);;
  00000000                M bank_changed -= BANKOF(before_bank); ; line too long :(
                          M ;    ORG before_addr
                          M ;BANK_TRACKER = before_bank
                          M ;WREG_TRACKER = before_wreg
                          M     CONTEXT_RESTORE before_112
                          M ;    messg restore ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @2063
                          M     EMIT ORG ctx_addr_112;
01B3                      M     ORG ctx_addr_112
  80000005                M WREG_TRACKER = ctx_wreg_112
  00000038                M BANK_TRACKER = ctx_bank_112
  0000018A                M PAGE_TRACKER = ctx_page_112
                          M     if after_addr == before_addr + 1; no stmt
                          M         WARNIF(has_banksel, [INFO] emitted extraneous banksel (no movwf_banksafe brkoutpx + 24 + REPEATER for ifbit) @2858);;
                          M     else; back-fill btf instr
                          M         if BOOL2INT(1)
                          M             BANKSAFE bitnum_arg(7 - REPEATER) btfsc (FPS);, bitnum;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1967
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     withbit_3 btfsc (FPS)
01B3   19F5               M     btfsc (FPS), 3
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M         else
                          M             BANKSAFE bitnum_arg(7 - REPEATER) btfss (FPS);, bitnum;
                          M         endif
                          M ;       ORG after_addr
                          M ;BANK_TRACKER = after_bank
                          M ;WREG_TRACKER = after_wreg
                          M         CONTEXT_RESTORE after_112
                          M ;    messg restore ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @2063
                          M     EMIT ORG ctx_addr_113;
01B5                      M     ORG ctx_addr_113
  80000005                M WREG_TRACKER = ctx_wreg_113
  00000038                M BANK_TRACKER = ctx_bank_113
  0000018A                M PAGE_TRACKER = ctx_page_113
                          M     endif
                          M ;    EXPAND_POP
  00000071                M NUM_IFBIT += 1; kludge: need unique labels
                          M     set_fps_pxbit REPEATER
                          M ;    BANKCHK brkoutpx;
                          M ;    messg TODO ^^^ fix banksel in ifbit @227
                          M     ifbit IIF(REPEATER == 7, LITERAL(0), FPS), 7 - REPEATER, TRUE, MOVWF brkoutpx + 24 + REPEATER;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND  ;reduce clutter
                          M ;    if (SRC == DEST) && ((srcbytes) == (destbytes)) && !(reverse)  ;nothing to do
                          M ;    LOCAL BIT = bit ;kludge; force eval (avoids "missing operand" and "missing argument" errors/MPASM bugs); also helps avoid "line too long" messages (MPASM limit 200)
  0075                    M     LOCAL REG = (FPS) ;kludge; force eval (avoids "missing operand" and "missing argument" errors/MPASM bugs); also helps avoid "line too long" messages (MPASM limit 200)
                          M ;    messg "mov8", #v(DEST), #v(SRC), #v(ISLIT(SRC)), #v(LIT2VAL(SRC)) @2804
                          M ;    messg src, dest @2805;
                          M     if ISLIT((FPS)); ; compile-time check
                          M         if BOOL2INT(LIT2VAL((FPS)) & BIT(7 - REPEATER)) == BOOL2INT(1)
                          M ;           EXPAND_PUSH TRUE
                          M             EMIT movwf_banksafe brkoutpx + 24 + REPEATER
                          M ;           EXPAND_POP
                          M         endif
                          M ;        EXPAND_POP
                          M         exitm
                          M     endif
                          M ;    BANKCHK reg;
                          M ;    if BOOL2INT(bitval)
                          M ;       BANKSAFE bitnum_arg(bitnum) btfsc reg;, bitnum;
                          M ;    else
                          M ;       BANKSAFE bitnum_arg(bitnum) btfss reg;, bitnum;
                          M ;    endif
                          M ;;    LOCAL BEFORE_STMT = $
                          M ;;STMT_ADDR#v(STMT_COUNTER) = 0-$
                          M ;    LOCAL STMT_ADDR
                          M ;STMT_INSTR = 0 - $
                          M ;    LOCAL SVWREG = WREG_TRACKER
                          M ;    EXPAND_RESTORE
                          M ;    stmt
                          M ;    NOEXPAND  ;reduce clutter
                          M ;    if WREG_TRACKER != SVWREG
                          M ;       DROP_WREG
                          M ;;      messg WREG unknown here, conditional stmt might have changed it @2831
                          M ;    endif
                          M ;;STMT_ADDR#v(STMT_COUNTER) += $
                          M ;STMT_INSTR += $
                          M ;;    LOCAL STMT_INSTR = STMT_ADDR; #v(STMT_COUNTER)
                          M ;;STMT_COUNTER += 1
                          M ;;    LOCAL AFTER_STMT = 0; $ - (BEFORE_STMT + 1)
                          M ;    WARNIF((STMT_INSTR != 1) && !ISLIT(reg), [ERROR] if-ed stmt !1 opcode: #v(STMT_INSTR), @2838); use warn to allow compile to continue
  0072                    M     LOCAL NUM_IFBIT = NUM_CONTEXT; kludge: need unique symbols
  01B5                    M     LOCAL has_banksel = $
                          M     BANKCHK (FPS); do this before allocating fized-sized placeholder
  00000000                M has_banksel -= $
  01B5                    M     LOCAL before_addr = $, before_bank = BANK_TRACKER;, before_wreg = WREG_TRACKER
                          M     CONTEXT_SAVE before_114
  00000072                M before_114 EQU 114; allow context access by caller-supplied name
  00000073                M NUM_CONTEXT += 1
  01B5                    M     VARIABLE ctx_addr_114      = $
  0005                    M     VARIABLE ctx_wreg_114      = WREG_TRACKER
  0038                    M     VARIABLE ctx_bank_114      = BANK_TRACKER
  018A                    M     VARIABLE ctx_page_114      = PAGE_TRACKER
                          M ;no, let stmt change it;    DROP_CONTEXT
                          M ;    messg save ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @2059
01B6                      M     ORG before_addr + 1; leave placeholder for btf; backfill after checking for idler
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf_banksafe brkoutpx + 24 + REPEATER;
                          M     movwf_banksafe brkoutpx + 24 + REPEATER
                          M ;    EXPAND_PUSH FALSE
                          M     if (brkoutpx + 24 + REPEATER) & INDF0_special
                          M ;        EXPAND_RESTORE; NOEXPAND
                          M         EMIT MOVWI_opc(FSR0, brkoutpx + 24 + REPEATER);;
                          M ;       NOEXPAND  ;reduce clutter
                          M     else
                          M         if (brkoutpx + 24 + REPEATER) & INDF1_special
                          M ;           EXPAND_RESTORE; NOEXPAND
                          M             EMIT MOVWI_opc(FSR1, brkoutpx + 24 + REPEATER);;
                          M ;           NOEXPAND  ;reduce clutter
                          M         else
                          M ;           if reg != WREG
                          M             BANKCHK brkoutpx + 24 + REPEATER;
                          M ;               BANKSAFE movwf dest; NOARG
                          M             BANKSAFE EMIT movwf brkoutpx + 24 + REPEATER;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1967
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf brkoutpx + 24 + REPEATER
01B6   00BD               M     movwf brkoutpx + 24 + REPEATER
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M         endif
                          M     endif
                          M ;    EXPAND_POP
                          M ;    EXPAND_POP
  01B7                    M     LOCAL after_addr = $, after_bank = BANK_TRACKER;, after_wreg = WREG_TRACKER
                          M     CONTEXT_SAVE after_114
  00000073                M after_114 EQU 115; allow context access by caller-supplied name
  00000074                M NUM_CONTEXT += 1
  01B7                    M     VARIABLE ctx_addr_115      = $
  0005                    M     VARIABLE ctx_wreg_115      = WREG_TRACKER
  0038                    M     VARIABLE ctx_bank_115      = BANK_TRACKER
  018A                    M     VARIABLE ctx_page_115      = PAGE_TRACKER
                          M ;no, let stmt change it;    DROP_CONTEXT
                          M ;    messg save ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @2059
  0000                    M     LOCAL bank_changed = BANKOF(after_bank);;
  00000000                M bank_changed -= BANKOF(before_bank); ; line too long :(
                          M ;    ORG before_addr
                          M ;BANK_TRACKER = before_bank
                          M ;WREG_TRACKER = before_wreg
                          M     CONTEXT_RESTORE before_114
                          M ;    messg restore ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @2063
                          M     EMIT ORG ctx_addr_114;
01B5                      M     ORG ctx_addr_114
  80000005                M WREG_TRACKER = ctx_wreg_114
  00000038                M BANK_TRACKER = ctx_bank_114
  0000018A                M PAGE_TRACKER = ctx_page_114
                          M     if after_addr == before_addr + 1; no stmt
                          M         WARNIF(has_banksel, [INFO] emitted extraneous banksel (no movwf_banksafe brkoutpx + 24 + REPEATER for ifbit) @2858);;
                          M     else; back-fill btf instr
                          M         if BOOL2INT(1)
                          M             BANKSAFE bitnum_arg(7 - REPEATER) btfsc (FPS);, bitnum;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1967
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     withbit_2 btfsc (FPS)
01B5   1975               M     btfsc (FPS), 2
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M         else
                          M             BANKSAFE bitnum_arg(7 - REPEATER) btfss (FPS);, bitnum;
                          M         endif
                          M ;       ORG after_addr
                          M ;BANK_TRACKER = after_bank
                          M ;WREG_TRACKER = after_wreg
                          M         CONTEXT_RESTORE after_114
                          M ;    messg restore ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @2063
                          M     EMIT ORG ctx_addr_115;
01B7                      M     ORG ctx_addr_115
  80000005                M WREG_TRACKER = ctx_wreg_115
  00000038                M BANK_TRACKER = ctx_bank_115
  0000018A                M PAGE_TRACKER = ctx_page_115
                          M     endif
                          M ;    EXPAND_POP
  00000073                M NUM_IFBIT += 1; kludge: need unique labels
                          M     set_fps_pxbit REPEATER
                          M ;    BANKCHK brkoutpx;
                          M ;    messg TODO ^^^ fix banksel in ifbit @227
                          M     ifbit IIF(REPEATER == 7, LITERAL(0), FPS), 7 - REPEATER, TRUE, MOVWF brkoutpx + 24 + REPEATER;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND  ;reduce clutter
                          M ;    if (SRC == DEST) && ((srcbytes) == (destbytes)) && !(reverse)  ;nothing to do
                          M ;    LOCAL BIT = bit ;kludge; force eval (avoids "missing operand" and "missing argument" errors/MPASM bugs); also helps avoid "line too long" messages (MPASM limit 200)
  0075                    M     LOCAL REG = (FPS) ;kludge; force eval (avoids "missing operand" and "missing argument" errors/MPASM bugs); also helps avoid "line too long" messages (MPASM limit 200)
                          M ;    messg "mov8", #v(DEST), #v(SRC), #v(ISLIT(SRC)), #v(LIT2VAL(SRC)) @2804
                          M ;    messg src, dest @2805;
                          M     if ISLIT((FPS)); ; compile-time check
                          M         if BOOL2INT(LIT2VAL((FPS)) & BIT(7 - REPEATER)) == BOOL2INT(1)
                          M ;           EXPAND_PUSH TRUE
                          M             EMIT movwf_banksafe brkoutpx + 24 + REPEATER
                          M ;           EXPAND_POP
                          M         endif
                          M ;        EXPAND_POP
                          M         exitm
                          M     endif
                          M ;    BANKCHK reg;
                          M ;    if BOOL2INT(bitval)
                          M ;       BANKSAFE bitnum_arg(bitnum) btfsc reg;, bitnum;
                          M ;    else
                          M ;       BANKSAFE bitnum_arg(bitnum) btfss reg;, bitnum;
                          M ;    endif
                          M ;;    LOCAL BEFORE_STMT = $
                          M ;;STMT_ADDR#v(STMT_COUNTER) = 0-$
                          M ;    LOCAL STMT_ADDR
                          M ;STMT_INSTR = 0 - $
                          M ;    LOCAL SVWREG = WREG_TRACKER
                          M ;    EXPAND_RESTORE
                          M ;    stmt
                          M ;    NOEXPAND  ;reduce clutter
                          M ;    if WREG_TRACKER != SVWREG
                          M ;       DROP_WREG
                          M ;;      messg WREG unknown here, conditional stmt might have changed it @2831
                          M ;    endif
                          M ;;STMT_ADDR#v(STMT_COUNTER) += $
                          M ;STMT_INSTR += $
                          M ;;    LOCAL STMT_INSTR = STMT_ADDR; #v(STMT_COUNTER)
                          M ;;STMT_COUNTER += 1
                          M ;;    LOCAL AFTER_STMT = 0; $ - (BEFORE_STMT + 1)
                          M ;    WARNIF((STMT_INSTR != 1) && !ISLIT(reg), [ERROR] if-ed stmt !1 opcode: #v(STMT_INSTR), @2838); use warn to allow compile to continue
  0074                    M     LOCAL NUM_IFBIT = NUM_CONTEXT; kludge: need unique symbols
  01B7                    M     LOCAL has_banksel = $
                          M     BANKCHK (FPS); do this before allocating fized-sized placeholder
  00000000                M has_banksel -= $
  01B7                    M     LOCAL before_addr = $, before_bank = BANK_TRACKER;, before_wreg = WREG_TRACKER
                          M     CONTEXT_SAVE before_116
  00000074                M before_116 EQU 116; allow context access by caller-supplied name
  00000075                M NUM_CONTEXT += 1
  01B7                    M     VARIABLE ctx_addr_116      = $
  0005                    M     VARIABLE ctx_wreg_116      = WREG_TRACKER
  0038                    M     VARIABLE ctx_bank_116      = BANK_TRACKER
  018A                    M     VARIABLE ctx_page_116      = PAGE_TRACKER
                          M ;no, let stmt change it;    DROP_CONTEXT
                          M ;    messg save ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @2059
01B8                      M     ORG before_addr + 1; leave placeholder for btf; backfill after checking for idler
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf_banksafe brkoutpx + 24 + REPEATER;
                          M     movwf_banksafe brkoutpx + 24 + REPEATER
                          M ;    EXPAND_PUSH FALSE
                          M     if (brkoutpx + 24 + REPEATER) & INDF0_special
                          M ;        EXPAND_RESTORE; NOEXPAND
                          M         EMIT MOVWI_opc(FSR0, brkoutpx + 24 + REPEATER);;
                          M ;       NOEXPAND  ;reduce clutter
                          M     else
                          M         if (brkoutpx + 24 + REPEATER) & INDF1_special
                          M ;           EXPAND_RESTORE; NOEXPAND
                          M             EMIT MOVWI_opc(FSR1, brkoutpx + 24 + REPEATER);;
                          M ;           NOEXPAND  ;reduce clutter
                          M         else
                          M ;           if reg != WREG
                          M             BANKCHK brkoutpx + 24 + REPEATER;
                          M ;               BANKSAFE movwf dest; NOARG
                          M             BANKSAFE EMIT movwf brkoutpx + 24 + REPEATER;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1967
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf brkoutpx + 24 + REPEATER
01B8   00BE               M     movwf brkoutpx + 24 + REPEATER
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M         endif
                          M     endif
                          M ;    EXPAND_POP
                          M ;    EXPAND_POP
  01B9                    M     LOCAL after_addr = $, after_bank = BANK_TRACKER;, after_wreg = WREG_TRACKER
                          M     CONTEXT_SAVE after_116
  00000075                M after_116 EQU 117; allow context access by caller-supplied name
  00000076                M NUM_CONTEXT += 1
  01B9                    M     VARIABLE ctx_addr_117      = $
  0005                    M     VARIABLE ctx_wreg_117      = WREG_TRACKER
  0038                    M     VARIABLE ctx_bank_117      = BANK_TRACKER
  018A                    M     VARIABLE ctx_page_117      = PAGE_TRACKER
                          M ;no, let stmt change it;    DROP_CONTEXT
                          M ;    messg save ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @2059
  0000                    M     LOCAL bank_changed = BANKOF(after_bank);;
  00000000                M bank_changed -= BANKOF(before_bank); ; line too long :(
                          M ;    ORG before_addr
                          M ;BANK_TRACKER = before_bank
                          M ;WREG_TRACKER = before_wreg
                          M     CONTEXT_RESTORE before_116
                          M ;    messg restore ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @2063
                          M     EMIT ORG ctx_addr_116;
01B7                      M     ORG ctx_addr_116
  80000005                M WREG_TRACKER = ctx_wreg_116
  00000038                M BANK_TRACKER = ctx_bank_116
  0000018A                M PAGE_TRACKER = ctx_page_116
                          M     if after_addr == before_addr + 1; no stmt
                          M         WARNIF(has_banksel, [INFO] emitted extraneous banksel (no movwf_banksafe brkoutpx + 24 + REPEATER for ifbit) @2858);;
                          M     else; back-fill btf instr
                          M         if BOOL2INT(1)
                          M             BANKSAFE bitnum_arg(7 - REPEATER) btfsc (FPS);, bitnum;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1967
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     withbit_1 btfsc (FPS)
01B7   18F5               M     btfsc (FPS), 1;
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M         else
                          M             BANKSAFE bitnum_arg(7 - REPEATER) btfss (FPS);, bitnum;
                          M         endif
                          M ;       ORG after_addr
                          M ;BANK_TRACKER = after_bank
                          M ;WREG_TRACKER = after_wreg
                          M         CONTEXT_RESTORE after_116
                          M ;    messg restore ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @2063
                          M     EMIT ORG ctx_addr_117;
01B9                      M     ORG ctx_addr_117
  80000005                M WREG_TRACKER = ctx_wreg_117
  00000038                M BANK_TRACKER = ctx_bank_117
  0000018A                M PAGE_TRACKER = ctx_page_117
                          M     endif
                          M ;    EXPAND_POP
  00000075                M NUM_IFBIT += 1; kludge: need unique labels
                          M     set_fps_pxbit REPEATER
                          M ;    BANKCHK brkoutpx;
                          M ;    messg TODO ^^^ fix banksel in ifbit @227
                          M     ifbit IIF(REPEATER == 7, LITERAL(0), FPS), 7 - REPEATER, TRUE, MOVWF brkoutpx + 24 + REPEATER;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND  ;reduce clutter
                          M ;    if (SRC == DEST) && ((srcbytes) == (destbytes)) && !(reverse)  ;nothing to do
                          M ;    LOCAL BIT = bit ;kludge; force eval (avoids "missing operand" and "missing argument" errors/MPASM bugs); also helps avoid "line too long" messages (MPASM limit 200)
  0000                    M     LOCAL REG = ((ASM_MSB | (0))) ;kludge; force eval (avoids "missing operand" and "missing argument" errors/MPASM bugs); also helps avoid "line too long" messages (MPASM 
                          M ;    messg "mov8", #v(DEST), #v(SRC), #v(ISLIT(SRC)), #v(LIT2VAL(SRC)) @2804
                          M ;    messg src, dest @2805;
                          M     if ISLIT(((ASM_MSB | (0)))); ; compile-time check
                          M         if BOOL2INT(LIT2VAL(((ASM_MSB | (0)))) & BIT(7 - REPEATER)) == BOOL2INT(1)
                          M ;           EXPAND_PUSH TRUE
                          M             EMIT movwf_banksafe brkoutpx + 24 + REPEATER
                          M ;           EXPAND_POP
                          M         endif
                          M ;        EXPAND_POP
                          M         exitm
                      00240     CLRF FPS; restart frame count for next 1 sec
01B9   01F5               M     clrf FPS
                      00241     ifbit WREG, log2(HEARTBEAT_PARITY), FPS_RGBINX & HEARTBEAT_PARITY, biton_7     FPS; toggle parity
                          M     biton_7 FPS
                          M         setbit FPS, 7, TRUE;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND  ;reduce clutter
                          M ;    if (SRC == DEST) && ((srcbytes) == (destbytes)) && !(reverse)  ;nothing to do
                          M ;    LOCAL BIT = bit ;kludge; force eval (avoids "missing operand" and "missing argument" errors/MPASM bugs); also helps avoid "line too long" messages (MPASM limit 200)
  0075                    M     LOCAL DEST = FPS  ;kludge; force eval (avoids "missing operand" and "missing argument" errors/MPASM bugs); also helps avoid "line too long" messages (MPASM limit 200)
                          M ;    messg "mov8", #v(DEST), #v(SRC), #v(ISLIT(SRC)), #v(LIT2VAL(SRC)) @2692
                          M ;    messg src, dest @2693;
                          M ;    BANKCHK dest;
  0007                    M     LOCAL BITNUM = 7
                          M     if BOOL2INT(1)
                          M ;        BANKSAFE bitnum_arg(BITNUM) bsf dest;, bit;
                          M ;        EMIT bitnum_arg(BITNUM) BSF dest;, bit;
                          M         BSF FPS,  7;
                          M ;    EXPAND_PUSH FALSE
                          M     ERRIF((7)      & ~7, [ERROR] invalid 7      ignored: 7          @2516)
                          M     BANKCHK FPS
                          M     BANKSAFE EMIT bitnum_arg(7)      bsf FPS
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1967
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT withbit_7 bsf FPS
                          M     withbit_7 bsf FPS
01BB   17F5               M     bsf FPS, 7
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M     if FPS == WREG
                          M WREG_TRACKER = IIF(ISLIT(WREG_TRACKER), LITERAL(WREG_TRACKER | BIT(7)),      WREG_UNKN)
                          M     endif
                          M ;    EXPAND_POP
                          M     else
                          M ;       BANKSAFE bitnum_arg(BITNUM) bcf dest;, bit;
                          M ;       EMIT bitnum_arg(BITNUM) BCF dest;, bit;
                          M         BCF FPS,  7;
                          M     endif
                          M     if FPS  == WREG
                          M ;       if ISLIT(WREG_TRACKER)
                          M ;           if BOOL2INT(bitval)
                          M ;WREG_TRACKER |= BIT(bit)
                          M ;           else
                          M ;WREG_TRACKER &= ~BIT(bit)
                          M ;           endif
                          M ;       else
                          M ;WREG_TRACKER = WREG_UNK
                          M ;       endif
                          M         if BOOL2INT(1)
                          M WREG_TRACKER = IIF(ISLIT(WREG_TRACKER, WREG_TRACKER | BIT(7),   WREG_UNKN);;
                          M         else
                          M WREG_TRACKER = IIF(ISLIT(WREG_TRACKER, WREG_TRACKER & ~BIT(7),   WREG_UNKN);;
                          M         endif
                          M     endif
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
01BA                      M     ORG ctx_addr_118
01BC                      M     ORG ctx_addr_119
                      00242 ;    setbit elapsed_fps, FALSE;
                          M         exitm
01BC   0008           00244     return;
                      00245 ;even_frame:
                      00246 ;use cyan for even frames (heartbeat):
                      00247 ;    set_brkout_px 24+0, FPS, 7, WHITE_RGBINX, CYAN_RGBINX;
                      00248 ;    set_brkout_px 24+1, FPS, 6, WHITE_RGBINX, CYAN_RGBINX;
                      00249 ;    set_brkout_px 24+2, FPS, 5, WHITE_RGBINX, CYAN_RGBINX;
                      00250 ;    set_brkout_px 24+3, FPS, 4, WHITE_RGBINX, CYAN_RGBINX;
                      00251 ;    set_brkout_px 24+4, FPS, 3, WHITE_RGBINX, CYAN_RGBINX;
                      00252 ;    set_brkout_px 24+5, FPS, 2, WHITE_RGBINX, CYAN_RGBINX;
                      00253 ;    set_brkout_px 24+6, FPS, 1, WHITE_RGBINX, CYAN_RGBINX;
                      00254 ;    set_brkout_px 24+7, FPS, 0, WHITE_RGBINX, CYAN_RGBINX;
                      00255 ;    mov8 FPS, LITERAL(0);
                      00256 ;    wait4frame YIELD, YIELD_AGAIN; 1 sec
                      00257 ;    wait4render YIELD, YIELD_AGAIN; don't change breakout px while being rendered
                      00258 ;use magenta for odd frames (heartbeat):
                      00259 ;    set_brkout_px 24+0, FPS, 7, WHITE_RGBINX, MAGENTA_RGBINX;
                      00260 ;    set_brkout_px 24+1, FPS, 6, WHITE_RGBINX, MAGENTA_RGBINX;
                      00261 ;    set_brkout_px 24+2, FPS, 5, WHITE_RGBINX, MAGENTA_RGBINX;
                      00262 ;    set_brkout_px 24+3, FPS, 4, WHITE_RGBINX, MAGENTA_RGBINX;
                      00263 ;    set_brkout_px 24+4, FPS, 3, WHITE_RGBINX, MAGENTA_RGBINX;
                      00264 ;    set_brkout_px 24+5, FPS, 2, WHITE_RGBINX, MAGENTA_RGBINX;
                      00265 ;    set_brkout_px 24+6, FPS, 1, WHITE_RGBINX, MAGENTA_RGBINX;
                      00266 ;    set_brkout_px 24+7, FPS, 0, WHITE_RGBINX, MAGENTA_RGBINX;
                      00267 
                      00268 
                      00269 #if 0; dev/debug test
                      00270     messg REMOVE THIS
                      00271     mov8 brkoutpx+0, LITERAL(RED_RGBINX);;
                      00272     CALL anim_delay;
                      00273     mov8 brkoutpx+8, LITERAL(GREEN_RGBINX);;
                      00274     CALL anim_delay;
                      00275     mov8 brkoutpx+16, LITERAL(BLUE_RGBINX);;
                      00276     CALL anim_delay;
                      00277     mov8 brkoutpx+24, LITERAL(YELLOW_RGBINX);;
                      00278     CALL anim_delay;
                      00279     mov8 brkoutpx+0, LITERAL(OFF_RGBINX);;
                      00280     mov8 brkoutpx+8, LITERAL(OFF_RGBINX);;
                      00281     mov8 brkoutpx+16, LITERAL(OFF_RGBINX);;
                      00282     mov8 brkoutpx+24, LITERAL(OFF_RGBINX);;
                      00283     return;
                      00284 #endif
                      00285 
                      00286 
                      00287 ;show a little animation on power-up:
                      00288 ;turn on 1 breakout px at a time then alternate them a few times
                      00289 ;NOTE: this interferes with FPS tracking; use only at startup
                      00290 ;use FSR1 to set animation, FSR0 to send it
                      00291 brkout_anim: DROP_CONTEXT;
                      00292 #if 0; dev/test
                      00293     fps_init 1 sec;
                      00294     brkout_fill RED_RGBINX; //shows blue
                      00295     CALL anim_delay;
                      00296     brkout_fill OFF_RGBINX;
                      00297     CALL anim_delay;
                      00298     brkout_fill GREEN_RGBINX; //shows red
                      00299     CALL anim_delay;
                      00300     brkout_fill OFF_RGBINX;
                      00301     CALL anim_delay;
                      00302     brkout_fill BLUE_RGBINX; //shows green
                      00303     CALL anim_delay;
                      00304     brkout_fill OFF_RGBINX;
                      00305     CALL anim_delay;
                      00306     brkout_fill YELLOW_RGBINX; //shows blue
                      00307     CALL anim_delay;
                      00308     brkout_fill OFF_RGBINX;
                      00309     CALL anim_delay;
                      00310     brkout_fill MAGENTA_RGBINX; //shows red
                      00311     CALL anim_delay;
                      00312     brkout_fill OFF_RGBINX;
                      00313     CALL anim_delay;
                      00314     brkout_fill CYAN_RGBINX; //shows green
                      00315     CALL anim_delay;
                      00316     brkout_fill OFF_RGBINX;
                      00317     CALL anim_delay;
                      00318     brkout_fill WHITE_RGBINX;
                      00319     CALL anim_delay;
                      00320     GOTO all_off;
                      00321 #endif
                      00322     fps_init 1 sec / 32; 100 msec; CAUTION: reusing FPS timer
Message[301]: MESSAGE: ([TODO] change this to use postscaler 1..16 instead of just powers of 2 (for more accuracy) @1131)
Message[301]: MESSAGE: ([DEBUG] fps_init 31250 (34722 tuned) "usec": "prescaler" 11+0, max intv 65536, actual 34816, rollover 136 @1147)
01BD   014B               M     banksel T0CON0
01BE   019E               M     clrf T0CON0
01BF   304B               M     movlw (((ASM_MSB | (b'010' << T0CS0 | 0 | _5058PRESCALER << T0CKPS0))) & ~ASM_MSB)
01C0   009F               M     movwf T0CON1
01C1   019C               M     clrf TMR0L
01C2   3087               M     movlw (((ASM_MSB | (_5058ROLLOVER - 1))) & ~ASM_MSB)
01C3   009D               M     movwf TMR0H
                          M     withbit_7 bsf T0CON0
01C4   179E               M     bsf T0CON0, 7
01C5   014E               M     banksel PIR0
                          M     withbit_5 bcf PIR0
01C6   128C               M     bcf PIR0, 5
                          M             exitm
                      00323     CALL all_off;
01C7   21E7               M     call all_off
                      00324     mov16 FSR1, LITERAL(brkoutpx); ; //rewind
01C8   3020               M     movlw (((ASM_MSB | (_5179SRC & 0xFF))) & ~ASM_MSB)
01C9   0086               M     movwf FSR1
01CA   0187               M     clrf FSR10hi
01CB                  00325 red_anim: ;DROP_CONTEXT;
                      00326     mov8 INDF1_postinc, LITERAL(RED_RGBINX); ; //turn on 1/@time
01CB   3004               M     movlw (((ASM_MSB | (RED_RGBINX))) & ~ASM_MSB)
01CC   001E               M     MOVWI_1_2
                      00327     CALL anim_delay;
01CD   21EF               M     call anim_delay
                      00328     ifbit FSR1L, log2(8), !((brkoutpx + 8) & 8), GOTO red_anim; still doing first byte
                          M     goto_pagesafe red_anim
                          M ;    EXPAND_PUSH FALSE
                          M ; messg here1 @3079
                          M     ERRIF(LITPAGEOF(red_anim), [ERROR] "dest" red_anim 459 !on page 0: 0                @3080)
                          M ; messg here2 @3081
                          M ;PAGESEL_DROP += 1
                          M ;    messg goto dest, page tracker #v(PAGE_TRACKER), need page sel? #v(LITPAGEOF(dest)) != #v(LITPAGEOF(PAGE_TRACKER))? #v(LITPAGEOF(dest) != LITPAGEOF(PAGE_TRACKER))
                          M     if LITPAGEOF(red_anim) != LITPAGEOF(PAGE_TRACKER)
                          M         EMIT CLRF PCLATH; PAGESEL dest; kludge: mpasm doesn't want to pagesel
                          M PAGESEL_KEEP += 1
                          M     else
  00000028                M PAGESEL_DROP += 1
                          M     endif
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M ; messg here3 @3091
                          M     EMIT goto red_anim; PROGDCL 0x2000 | (dest); call dest
01CF   29CB               M     goto red_anim
  000001CB                M PAGE_TRACKER = red_anim;
                          M ; messg here4 @3094
                          M ;    NOEXPAND
                          M ;not needed: fall-thru would be handled by earlier code    DROP_CONTEXT; BSR and WREG unknown here if dest falls through
                          M ;    EXPAND_POP
01CE                      M     ORG ctx_addr_120
01D0                      M     ORG ctx_addr_121
01D0                  00329 green_anim: ;DROP_CONTEXT;
                      00330     mov8 INDF1_postinc, LITERAL(GREEN_RGBINX); ; //turn on 1/@time
01D0   3002               M     movlw (((ASM_MSB | (GREEN_RGBINX))) & ~ASM_MSB)
01D1   001E               M     MOVWI_1_2
                      00331     CALL anim_delay;
01D2   21EF               M     call anim_delay
                      00332     ifbit FSR1L, log2(16), !((brkoutpx + 16) & 16), GOTO green_anim; still doing second byte
                          M     goto_pagesafe green_anim
                          M ;    EXPAND_PUSH FALSE
                          M ; messg here1 @3079
                          M     ERRIF(LITPAGEOF(green_anim), [ERROR] "dest" green_anim 464 !on page 0: 0            @3080)
                          M ; messg here2 @3081
                          M ;PAGESEL_DROP += 1
                          M ;    messg goto dest, page tracker #v(PAGE_TRACKER), need page sel? #v(LITPAGEOF(dest)) != #v(LITPAGEOF(PAGE_TRACKER))? #v(LITPAGEOF(dest) != LITPAGEOF(PAGE_TRACKER))
                          M     if LITPAGEOF(green_anim) != LITPAGEOF(PAGE_TRACKER)
                          M         EMIT CLRF PCLATH; PAGESEL dest; kludge: mpasm doesn't want to pagesel
                          M PAGESEL_KEEP += 1
                          M     else
  0000002A                M PAGESEL_DROP += 1
                          M     endif
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M ; messg here3 @3091
                          M     EMIT goto green_anim; PROGDCL 0x2000 | (dest); call dest
01D4   29D0               M     goto green_anim
  000001D0                M PAGE_TRACKER = green_anim;
                          M ; messg here4 @3094
                          M ;    NOEXPAND
                          M ;not needed: fall-thru would be handled by earlier code    DROP_CONTEXT; BSR and WREG unknown here if dest falls through
                          M ;    EXPAND_POP
01D3                      M     ORG ctx_addr_122
01D5                      M     ORG ctx_addr_123
01D5                  00333 blue_anim: ;DROP_CONTEXT;
                      00334     mov8 INDF1_postinc, LITERAL(BLUE_RGBINX); ; //turn on 1/@time
01D5   3001               M     movlw (((ASM_MSB | (BLUE_RGBINX))) & ~ASM_MSB)
01D6   001E               M     MOVWI_1_2
                      00335     CALL anim_delay;
01D7   21EF               M     call anim_delay
                      00336     ifbit FSR1L, log2(8), !((brkoutpx + 24) & 8), GOTO blue_anim; still doing third byte
                          M     goto_pagesafe blue_anim
                          M ;    EXPAND_PUSH FALSE
                          M ; messg here1 @3079
                          M     ERRIF(LITPAGEOF(blue_anim), [ERROR] "dest" blue_anim 469 !on page 0: 0              @3080)
                          M ; messg here2 @3081
                          M ;PAGESEL_DROP += 1
                          M ;    messg goto dest, page tracker #v(PAGE_TRACKER), need page sel? #v(LITPAGEOF(dest)) != #v(LITPAGEOF(PAGE_TRACKER))? #v(LITPAGEOF(dest) != LITPAGEOF(PAGE_TRACKER))
                          M     if LITPAGEOF(blue_anim) != LITPAGEOF(PAGE_TRACKER)
                          M         EMIT CLRF PCLATH; PAGESEL dest; kludge: mpasm doesn't want to pagesel
                          M PAGESEL_KEEP += 1
                          M     else
  0000002C                M PAGESEL_DROP += 1
                          M     endif
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M ; messg here3 @3091
                          M     EMIT goto blue_anim; PROGDCL 0x2000 | (dest); call dest
01D9   29D5               M     goto blue_anim
  000001D5                M PAGE_TRACKER = blue_anim;
                          M ; messg here4 @3094
                          M ;    NOEXPAND
                          M ;not needed: fall-thru would be handled by earlier code    DROP_CONTEXT; BSR and WREG unknown here if dest falls through
                          M ;    EXPAND_POP
01D8                      M     ORG ctx_addr_124
01DA                      M     ORG ctx_addr_125
01DA                  00337 fps_anim: ;DROP_CONTEXT;
                      00338     mov8 INDF1_postinc, LITERAL(FPS_RGBINX); ; //turn on 1/@time
01DA   3003               M     movlw (((ASM_MSB | (FPS_RGBINX))) & ~ASM_MSB)
01DB   001E               M     MOVWI_1_2
                      00339     CALL anim_delay;
01DC   21EF               M     call anim_delay
                      00340     ifbit FSR1L, log2(64), !((brkoutpx + 32) & 64), GOTO fps_anim; still doing fourth byte
                          M     goto_pagesafe fps_anim
                          M ;    EXPAND_PUSH FALSE
                          M ; messg here1 @3079
                          M     ERRIF(LITPAGEOF(fps_anim), [ERROR] "dest" fps_anim 474 !on page 0: 0                @3080)
                          M ; messg here2 @3081
                          M ;PAGESEL_DROP += 1
                          M ;    messg goto dest, page tracker #v(PAGE_TRACKER), need page sel? #v(LITPAGEOF(dest)) != #v(LITPAGEOF(PAGE_TRACKER))? #v(LITPAGEOF(dest) != LITPAGEOF(PAGE_TRACKER))
                          M     if LITPAGEOF(fps_anim) != LITPAGEOF(PAGE_TRACKER)
                          M         EMIT CLRF PCLATH; PAGESEL dest; kludge: mpasm doesn't want to pagesel
                          M PAGESEL_KEEP += 1
                          M     else
  0000002E                M PAGESEL_DROP += 1
                          M     endif
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M ; messg here3 @3091
                          M     EMIT goto fps_anim; PROGDCL 0x2000 | (dest); call dest
01DE   29DA               M     goto fps_anim
  000001DA                M PAGE_TRACKER = fps_anim;
                          M ; messg here4 @3094
                          M ;    NOEXPAND
                          M ;not needed: fall-thru would be handled by earlier code    DROP_CONTEXT; BSR and WREG unknown here if dest falls through
                          M ;    EXPAND_POP
01DD                      M     ORG ctx_addr_126
01DF                      M     ORG ctx_addr_127
                      00341 #if 0
                      00342     fps_init 1 sec; 500 msec;
                      00343 alt_loop:
                      00344     MOVLW WHITE_RGBINX;
                      00345     REPEAT LITERAL(SIZEOF(brkoutpx) / 2), MOVWF brkoutpx + REPEATER * 2; set "on" color every other px
                      00346     CALL anim_delay;
                      00347     REPEAT LITERAL(SIZEOF(brkoutpx) / 2), swap_pair REPEATER * 2; alternate
                      00348     CALL anim_delay;
                      00349     REPEAT LITERAL(SIZEOF(brkoutpx) / 2), swap_pair REPEATER * 2; alternate
                      00350     CALL anim_delay;
                      00351     REPEAT LITERAL(SIZEOF(brkoutpx) / 2), swap_pair REPEATER * 2; alternate
                      00352     CALL anim_delay;
                      00353     REPEAT LITERAL(SIZEOF(brkoutpx) / 2), swap_pair REPEATER * 2; alternate
                      00354     CALL anim_delay;
                      00355 #endif
                      00356 ;    CALL all_off; leave brkout px initialized to all "off" color
                      00357 ;    return;
                      00358     mov16 FSR1, LITERAL(brkoutpx); ; //rewind
01DF   3020               M     movlw (((ASM_MSB | (_5452SRC & 0xFF))) & ~ASM_MSB)
01E0   0086               M     movwf FSR1
01E1   0187               M     clrf FSR10hi
01E2                  00359 off_anim: ;DROP_CONTEXT;
                      00360     mov8 INDF1_postinc, LITERAL(OFF_RGBINX); ; //turn on 1/@time
01E2   3000               M     movlw (((ASM_MSB | (OFF_RGBINX))) & ~ASM_MSB)
01E3   001E               M     MOVWI_1_2
                      00361     CALL anim_delay;
01E4   21EF               M     call anim_delay
                      00362     ifbit FSR1L, log2(64), !((brkoutpx + 32) & 64), GOTO off_anim; still doing fourth byte
                          M     goto_pagesafe off_anim
                          M ;    EXPAND_PUSH FALSE
                          M ; messg here1 @3079
                          M     ERRIF(LITPAGEOF(off_anim), [ERROR] "dest" off_anim 482 !on page 0: 0                @3080)
                          M ; messg here2 @3081
                          M ;PAGESEL_DROP += 1
                          M ;    messg goto dest, page tracker #v(PAGE_TRACKER), need page sel? #v(LITPAGEOF(dest)) != #v(LITPAGEOF(PAGE_TRACKER))? #v(LITPAGEOF(dest) != LITPAGEOF(PAGE_TRACKER))
                          M     if LITPAGEOF(off_anim) != LITPAGEOF(PAGE_TRACKER)
                          M         EMIT CLRF PCLATH; PAGESEL dest; kludge: mpasm doesn't want to pagesel
                          M PAGESEL_KEEP += 1
                          M     else
  00000030                M PAGESEL_DROP += 1
                          M     endif
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M ; messg here3 @3091
                          M     EMIT goto off_anim; PROGDCL 0x2000 | (dest); call dest
01E6   29E2               M     goto off_anim
  000001E2                M PAGE_TRACKER = off_anim;
                          M ; messg here4 @3094
                          M ;    NOEXPAND
                          M ;not needed: fall-thru would be handled by earlier code    DROP_CONTEXT; BSR and WREG unknown here if dest falls through
                          M ;    EXPAND_POP
01E5                      M     ORG ctx_addr_128
01E7                      M     ORG ctx_addr_129
                      00363 ;fall thru ...
                      00364 
                      00365 ;turn all breakout px off and display for 1 frame:
                      00366 all_off: DROP_CONTEXT;
                      00367 ;    mov16 FSR1, LITERAL(brkoutpx);
                      00368 ;    MOVLW OFF_RGBINX;
                      00369 ;off_loop: ;DROP_CONTEXT;
                      00370 ;    mov8 INDF1_postinc, WREG; LITERAL(OFF_RGBINX);
                      00371 ;;    ifbit FSR0L, log2(END_DETECT), !(ENDOF(brkoutpx) & END_DETECT), goto off_loop;
                      00372 ;    ifbit FSR1L, breakout_eof(FALSE), GOTO off_loop;
                      00373 ;    whilebit FSR1L, breakout_eof(FALSE), MOVWF INDF1_postinc;
                      00374 ;    CALL anim_delay;
                      00375 ;    return
                      00376     brkout_fill OFF_RGBINX;
01E7   3020               M     movlw (((ASM_MSB | (_5552SRC & 0xFF))) & ~ASM_MSB)
01E8   0086               M     movwf FSR1
01E9   0187               M     clrf FSR10hi
01EA   3000               M     movlw OFF_RGBINX
01EB                      M _5596loop:
                          M     movwf_banksafe INDF1_postinc
                          M ;    EXPAND_PUSH FALSE
                          M     if (INDF1_postinc) & INDF0_special
                          M ;        EXPAND_RESTORE; NOEXPAND
                          M         EMIT MOVWI_opc(FSR0, INDF1_postinc);;
                          M ;       NOEXPAND  ;reduce clutter
                          M     else
                          M         if (INDF1_postinc) & INDF1_special
                          M ;           EXPAND_RESTORE; NOEXPAND
                          M             EMIT MOVWI_opc(FSR1, INDF1_postinc);;
01ED   001E               M     MOVWI_1_2
                          M ;           NOEXPAND  ;reduce clutter
                          M         else
                          M ;           if reg != WREG
                          M             BANKCHK INDF1_postinc;
                          M ;               BANKSAFE movwf dest; NOARG
                          M             BANKSAFE EMIT movwf INDF1_postinc;
                          M         endif
                          M     endif
                          M ;    EXPAND_POP
01EB                      M     ORG ctx_addr_130
                          M     goto_pagesafe _5596around
                          M ;    EXPAND_PUSH FALSE
                          M ; messg here1 @3079
                          M     ERRIF(LITPAGEOF(_5596around), [ERROR] "dest" _5596around 495 !on page 0: 0          @3080)
                          M ; messg here2 @3081
                          M ;PAGESEL_DROP += 1
                          M ;    messg goto dest, page tracker #v(PAGE_TRACKER), need page sel? #v(LITPAGEOF(dest)) != #v(LITPAGEOF(PAGE_TRACKER))? #v(LITPAGEOF(dest) != LITPAGEOF(PAGE_TRACKER))
                          M     if LITPAGEOF(_5596around) != LITPAGEOF(PAGE_TRACKER)
                          M         EMIT CLRF PCLATH; PAGESEL dest; kludge: mpasm doesn't want to pagesel
                          M PAGESEL_KEEP += 1
                          M     else
  00000031                M PAGESEL_DROP += 1
                          M     endif
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M ; messg here3 @3091
                          M     EMIT goto _5596around; PROGDCL 0x2000 | (dest); call dest
01EC   29EF               M     goto _5596around
  000001EF                M PAGE_TRACKER = _5596around;
                          M ; messg here4 @3094
                          M ;    NOEXPAND
                          M ;not needed: fall-thru would be handled by earlier code    DROP_CONTEXT; BSR and WREG unknown here if dest falls through
                          M ;    EXPAND_POP
01EB                      M     ORG ctx_addr_132
01ED                      M     ORG ctx_addr_133
01EE                      M     ORG ctx_addr_131
01EE   29EB               M     goto (_5596before_idler)
01EF                      M _5596around:
                      00377 ;fall thru ...
                      00378 
                      00379 ;send breakout px then delay for animation:
                      00380 anim_delay: DROP_CONTEXT;
                      00381 ;    call brkoutpx_sendall;
                      00382 ;    mov16 FSR0, LITERAL(brkoutpx);
                      00383     render_busy TRUE;
01EF   3020               M     movlw (((ASM_MSB | (_5687SRC & 0xFF))) & ~ASM_MSB)
01F0   0084               M     movwf FSR0
01F1   0185               M     clrf FSR00hi
                      00384 ;anim_loop: DROP_CONTEXT
                      00385 ;    mov8 WREG, INDF0_postinc
                      00386 ;    call ws_send_palette
                      00387 ;    wait_msec 100,; animation speed
                      00388 ;    whilebit elapsed_fps, FALSE, ;goto no_fps_update
                      00389     wait4frame YIELD, YIELD_AGAIN; 1/10 sec; assume breakout is written by now (takes < 1 msec)
01F2   216E               M     call yield
01F3   014E               M     banksel PIR0
                          M     goto_pagesafe yield_again
                          M ;    EXPAND_PUSH FALSE
                          M ; messg here1 @3079
                          M     ERRIF(LITPAGEOF(yield_again), [ERROR] "dest" yield_again 369 !on page 0: 0          @3080)
                          M ; messg here2 @3081
                          M ;PAGESEL_DROP += 1
                          M ;    messg goto dest, page tracker #v(PAGE_TRACKER), need page sel? #v(LITPAGEOF(dest)) != #v(LITPAGEOF(PAGE_TRACKER))? #v(LITPAGEOF(dest) != LITPAGEOF(PAGE_TRACKER))
                          M     if LITPAGEOF(yield_again) != LITPAGEOF(PAGE_TRACKER)
                          M         EMIT CLRF PCLATH; PAGESEL dest; kludge: mpasm doesn't want to pagesel
                          M PAGESEL_KEEP += 1
                          M     else
  00000034                M PAGESEL_DROP += 1
                          M     endif
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M ; messg here3 @3091
                          M     EMIT goto yield_again; PROGDCL 0x2000 | (dest); call dest
01F5   2971               M     goto yield_again
  00000171                M PAGE_TRACKER = yield_again;
                          M ; messg here4 @3094
                          M ;    NOEXPAND
                          M ;not needed: fall-thru would be handled by earlier code    DROP_CONTEXT; BSR and WREG unknown here if dest falls through
                          M ;    EXPAND_POP
01F4                      M     ORG ctx_addr_134
01F6                      M     ORG ctx_addr_135
                          M     withbit_5 bcf PIR0
01F6   128C               M     bcf PIR0, 5
                      00390 ;    ifbit FSR0L, log2(64), !((brkoutpx + 32) & 64), goto anim_loop; send more breakout px
01F7   0008           00391     return;
                      00392 
                      00393     THREAD_END;
                      00394 
Message[301]: MESSAGE: (end of hoist 6 @397)
Message[301]: MESSAGE: (epilog @3741)
017D                      M     ORG ctx_addr_95
017D   29F8               M     goto init_5
01F8                      M     ORG ctx_addr_136
01F8                      M init_5:
01F8                      M at_eof_0:
01F8                      M at_eof_1:
01F8                      M at_eof_2:
Message[301]: MESSAGE: ([INFO] optimization stats: @3729)
01F8                      M at_eof_3:
Message[301]: MESSAGE: ([INFO] bank sel: 42 (45%), dropped: 51 (55%) @1950)
01F8                      M at_eof_4:
Message[301]: MESSAGE: ([INFO] bank0 used: 32/80 (40%) @2127)
Message[301]: MESSAGE: ([INFO] non-banked used: 6/16 (38%) @2133)
01F8                      M at_eof_5:
Message[301]: MESSAGE: ([INFO] page sel: 1 (2%), dropped: 53 (98%) @3103)
Message[301]: MESSAGE: ([INFO] page0 used: 504/2048 (25%) @3105)
01F8                      M at_eof_6:
01F8                      M at_eof_7:
Message[301]: MESSAGE: ([INFO] #threads: 2, stack alloc: 8/16 (50%) @1470)
Message[301]: MESSAGE: ([DEBUG] why is banksel needed here? 1804 @1476)
                          M     withdest_0 movf stkptr_2
01F8   0873               M     movf stkptr_2, W;
01F9   017F               M     banksel STKPTR
01FA   00ED               M     movwf STKPTR
01FB   0008               M     return
0023                      M     ORG ctx_addr_4
                          M     withdest_0 movf stkptr_1
0023   0874               M     movf stkptr_1, W;
0024   017F               M     banksel STKPTR
0025   00ED               M     movwf STKPTR
0171                      M     ORG ctx_addr_93
                          M     withdest_0 movf stkptr_2
0171   0873               M     movf stkptr_2, W;
0172   017F               M     banksel STKPTR
0173   00ED               M     movwf STKPTR
01FC                      M     ORG ctx_addr_137
Message[301]: MESSAGE: (end of epilog @3776)
MPASM 5.87  /HOME/DJ/MPLABXPROJECTS/WSSPLITT   12-5-2021  23:02:33         PAGE  3
WS281X-Splitter - WS281X segment splitter/breakout/debug for Microchip PIC

SYMBOL TABLE
  LABEL                             VALUE 

ADDLW                             addlw_tracker
ADDWF                             addwf_banksafe
ALLOC_GPR                         
ANDLW                             andlw_tracker
ASM_MSB                           80000000
BANKCHK                           
BANKLEN                           0x80
BANKOF                            IIF(ISBANKED(reg), REG2ADDR(reg) / BANKLEN, BANK_UNKN)
BANKOFS                           ((reg) % BANKLEN)
BANKSAFE                          
BANKSEL_DROP                      00000033
BANKSEL_KEEP                      0000002D
BANK_TRACKER                      00001FED
BANK_UNKN                         -1
BCF                               bcf_tracker
BIT                               (1 << (n))
BLUE_RGBINX                       00000001
BOOL2INT                          ((val) != 0)
BORROW                            STATUS, C, !
BREAKOUT                          RA0
BRIGHT                            ((rgb) + 8)
BRKOUT_BITREV                     
BRKOUT_BYTE                       BRKOUT_BYTE_#v(byte)
BSF                               bsf_tracker
BYTEOF                            IIF(ISLIT(val), BYTEOF_LIT(val, which), BYTEOF_REG(val, which))
BYTEOF_LIT                        LITERAL(((val) >> (8 * (which))) & 0xFF)
BYTEOF_REG                        REGISTER((val) + (which))
CALL                              call_pagesafe
CARRY                             STATUS, C,
CLRF                              clrf_tracker
CLRW                              CLRF WREG
COMMON_END                        0xC
CONTEXT_RESTORE                   
CONTEXT_SAVE                      
CUSTOM_RGBINX                     00000008
CYAN_RGBINX                       00000003
DECF                              decf_banksafe
DISABLED                          BIT(n)
DISABLED_ALL                      0xFF
DROP_BANK                         
DROP_CONTEXT                      
DROP_WREG                         
EMIT                              
EMITL                             
ENABLED                           NOBIT(n)
ENABLED_ALL                       0
ENDOF                             (name + SIZEOF(name))
EOF_ADDR                          000001F8
EOF_COUNT                         00000008
EQUALS                            STATUS, Z,
ERRIF                             ERRIF_#v(((assert) != 0))  msg
ERRIF_0                           IGNORE_EOL
ERRIF_1                           error
EXPAND_CTL                        
EXPAND_POP                        EXPAND_CTL -1
EXPAND_PUSH                       EXPAND_CTL
EXPAND_RESTORE                    EXPAND_CTL 0xf00d
FALSE                             0
FOSC_FREQ                         (32 MHz)
FOUND_MSB                         00000040
FPS                               00000075
FPS0size                          00000001
FPS_RGBINX                        00000003
FPS_RGBINX_ALT                    00000005
FSR00hi                           00000005
FSR10hi                           00000007
GOTO                              goto_pagesafe
GPR_END                           0x70
GPR_START                         0x20
GREEN_RGBINX                      00000002
HEARTBEAT_PARITY                  00000004
HIBYTE                            BYTEOF(val, 2)
HOST_STKLEN                       16-0
IGNORE_EOL                        
IIF                               IIF_#v(((TF) != 0))(tval,  fval)
IIFDEBUG                          expr_true
IIF_0                             (fval)
IIF_1                             (tval)
INCF                              incf_banksafe
INDF0_postdec                     00020003
INDF0_postinc                     00020002
INDF0_predec                      00020001
INDF0_preinc                      00020000
INDF0_special                     00020000
INDF1_postdec                     00010003
INDF1_postinc                     00010002
INDF1_predec                      00010001
INDF1_preinc                      00010000
INDF1_special                     00010000
INIT_COUNT                        00000005
IN_THREAD                         00000000
IORLW                             iorlw_tracker
ISBANKED                          ((BANKOFS(reg) >= COMMON_END) && (BANKOFS(reg) < GPR_END))
ISLIT                             ((val) & ASM_MSB)
ISR_VECTOR                        (RESET_VECTOR + 4)
KHz                               * 1000
LAST_INIT                         0000017E
LATEST_RAM1                       00000073
LATEST_RAM2                       00000040
LATEST_RAM3                       00000074
LATEST_RAM4                       00000075
LATEST_RAM5                       00000076
LEDOUT                            IIFDEBUG(SEG4OUT, -1)
LISTCTL                           
LIST_POP                          LISTCTL -1
LIST_PUSH                         LISTCTL
LIST_RESTORE                      LISTCTL 0xfeed
LIT2VAL                           ((n) & ~ASM_MSB)
LITBIT                            LITERAL(BIT(n))
LITERAL                           (ASM_MSB | (n))
LITPAGEOF                         ((addr) / LIT_PAGELEN)
LIT_PAGELEN                       0x800
LOBYTE                            BYTEOF(val, 0)
LSTCTL_DEEPEST                    00000003
LSTCTL_DEPTH                      00000000
LSTCTL_STACK                      00000000
MAGENTA_RGBINX                    00000005
MAX                               IIF((x) > (y), x, y)
MAX_RAM0                          00000070
MAX_RAM1                          000000F0
MAX_RAM9999                       00000080
MAX_T0POSTSC                      00000004
MAX_T0PRESCALER                   0000000F
MEXPAND_DEEPEST                   00000005
MEXPAND_DEPTH                     00000000
MEXPAND_STACK                     00000001
MHz                               * 1000000
MIDBYTE                           BYTEOF(val, 1)
MIN                               IIF((x) < (y), x, y)
MIN_STACK                         2
MIPS                              * 4 MHz
MOVF                              movf_banksafe
MOVIW_0_0                         MOVIW ++FSR0
MOVIW_0_1                         MOVIW --FSR0
MOVIW_0_2                         MOVIW FSR0++
MOVIW_0_3                         MOVIW FSR0--
MOVIW_1_0                         MOVIW ++FSR1
MOVIW_1_1                         MOVIW --FSR1
MOVIW_1_2                         MOVIW FSR1++
MOVIW_1_3                         MOVIW FSR1--
MOVIW_opc                         MOVIW_#v((fsr) == FSR1)_#v((mode) & 3)
MOVLW                             movlw_tracker
MOVWF                             movwf_banksafe
MOVWI_0_0                         MOVWI ++FSR0
MOVWI_0_1                         MOVWI --FSR0
MOVWI_0_2                         MOVWI FSR0++
MOVWI_0_3                         MOVWI FSR0--
MOVWI_1_0                         MOVWI ++FSR1
MOVWI_1_1                         MOVWI --FSR1
MOVWI_1_2                         MOVWI FSR1++
MOVWI_1_3                         MOVWI FSR1--
MOVWI_opc                         MOVWI_#v((fsr) == FSR1)_#v((mode) & 3)
MY_BRG                            (FOSC_FREQ / (freq) / 4 - 1)
MY_CONFIG1                        0000178C
MY_CONFIG2                        00002FFE
MY_CONFIG3                        00003F9F
MY_CONFIG4                        00001FFF
MY_CONFIG5                        00003FFF
NEXT_RAM0                         00000040
NEXT_RAM1                         000000A0
NEXT_RAM9999                      00000076
NOBANK                            0000270F
NOBIT                             0
NOP                               nop_multi
NULL_STMT                         ORG $
NUM_CONTEXT                       0000008A
NUM_THREADS                       00000002
OFF_RGBINX                        00000000
OUTPPS_DT1                        0x10
OUTPPS_TX1_CK1                    0x0F
PAGESEL_DROP                      00000035
PAGESEL_KEEP                      00000001
PAGE_TRACKER                      0000017E
PASS1_FIXUPS                      00000000
PASS2_FIXUPS                      00000000
PINK_RGBINX                       00000005
PLL                               * 2
POP                               
PUSH                              
RAM_BLOCK                         00000005
RAM_LEN0                          00000050
RAM_LEN1                          00000050
RAM_LEN9999                       00000010
RAM_START0                        00000020
RAM_START1                        000000A0
RAM_START9999                     00000070
RAM_USED0                         00000020
RAM_USED1                         00000000
RAM_USED9999                      00000006
RED_RGBINX                        00000004
REG2ADDR                          (a)
REGHI                             name#v(0)hi
REGISTER                          (a)
REGLO                             name
REGMID                            name#v(0)mid
REGPAGEOF                         ((addr) / REG_PAGELEN)
REG_PAGELEN                       0x100
REPEAT                            
REPEATER                          00000008
RERUN_THREADS                     TRUE
RESET_VECTOR                      0
REVBIT                            (0x80 >> (n))
RGB_ORDER                         RGB_#v(n)
RGSWAP                            0x231
SEG1OUT                           RA1
SEG2OUT                           RA2
SEG3OUT                           RA#v(3+2)
SEG4OUT                           RA4
SETUP_FULL                        00000080
SETUP_ONLY                        00000010
SETUP_PART                        00000040
SIZEOF                            name#v(0)size
SP1BRG0hi                         0000011C
SPI3x_0                           SPI3x_FIRST(byte)
SPI3x_1                           SPI3x_MID(byte)
SPI3x_2                           SPI3x_LAST(byte)
SPI3x_FIRST                       BRKOUT_BYTE(b'10010010' | BOOL2INT((byte) & BIT(7)) << 6 | BOOL2INT((byte) & BIT(6)) << 3 | BOOL2I
SPI3x_LAST                        BRKOUT_BYTE(b'00100100' | BOOL2INT((byte) & BIT(2)) << 7 | BOOL2INT((byte) & BIT(1)) << 4 | BOOL2I
SPI3x_MID                         BRKOUT_BYTE(b'01001001' | BOOL2INT((byte) & BIT(4)) << 5 | BOOL2INT((byte) & BIT(3)) << 2)
STK_ALLOC                         00000008
T0SRC_FOSC4                       b'010'
T0_prescaler                      prescaler(FOSC_FREQ/4, freq)
T1GATE_LC1OUT                     b'01101'
T1GATE_LC4OUT                     b'10000'
T1SRC_HFINTOSC                    b'0011'
T1SRC_LC3OUT                      b'1100'
T1_prescale                       log2(1)
THREAD_DEF                        
THREAD_END                        
TOS                               00001FEE
TOS0hi                            00001FEF
TRUE                              1
TUNED                             ((freq) * 10/9)
UGLY_PASS12FIX                    
UNTUNED                           ((freq) * 9/10)
USE_HFFRQ                         b'110'
WAIT_4PX                          00000002
WANT_BIT                          00000001
WANT_DEBUG                        
WARNIF                            WARNIF_#v(((assert) != 0))  msg
WARNIF_0                          IGNORE_EOL
WARNIF_1                          messg
WHITE_RGBINX                      00000007
WREG_TRACKER                      00000073
WREG_UNKN                         40000000
WSBIT_FREQ                        (800 KHz)
WSBIT_THRESHOLD                   (FOSC_FREQ / (2 MHz))
WSDI                              RA3
WSENC_TEMP                        FFFFFFFF
WSLATCH                           (50 -20 usec)
XBIT                              NOBIT(n)
XORLW                             xorlw_tracker
YELLOW_RGBINX                     00000006
YESNO                             YESNO_#v(((val) != 0))
YESNO_0                           false
YESNO_1                           true
YIELD_AGAIN_inlined               
__16F15313                        00000001
addlw_tracker                     
addwf_banksafe                    
all_off                           000001E7
andlw_tracker                     
anim_delay                        000001EF
asmbit                            00000020
asmpower2                         00000000
at_eof                            
b0DCL                             ALLOC_GPR 0,
b0DCL16                           
b0DCL24                           
bcf_tracker                       
before_yield                      00000089
bitnum_arg                        withbit_#v(argg)
bitoff_0                          
bitoff_1                          
bitoff_2                          
bitoff_3                          
bitoff_4                          
bitoff_5                          
bitoff_6                          
bitoff_7                          
biton_0                           
biton_1                           
biton_2                           
biton_3                           
biton_4                           
biton_5                           
biton_6                           
biton_7                           
blue_anim                         000001D5
breakout_eof                      log2(ENDOF(brkoutpx)), IIF(brkoutpx & ENDOF(brkoutpx), !(yesno), yesno)
brkout_anim                       000001BD
brkout_fill                       
brkout_loop                       00000047
brkout_render                     00000030
brkoutpx                          00000020
brkoutpx0size                     00000020
bsf_tracker                       
call_pagesafe                     
ccolor                            00000070
ccolor0hi                         00000072
ccolor0mid                        00000071
ccolor0size                       00000003
clrf_tracker                      
clrw                              clrf WREG
comf2s                            
decf_banksafe                     
dest_arg                          withdest_#v(argg)
elapsed_fps                       PIR0, TMR0IF
eof                               000001F8
eof_0                             
eof_1                             
eof_2                             
eof_3                             
eof_4                             
eof_5                             
eof_6                             
eof_7                             
find_msb                          
fosc_init                         
fps_anim                          000001DA
fps_init                          
fps_update                        0000019E
generate_brkout_bytes             
generate_get_palent               
goto_pagesafe                     
green_anim                        000001D0
ifbit                             
incf_banksafe                     
init_more                         
iopin_init                        
iorlw_tracker                     
khz                               rdiv(freq, 1000)
log2                              LOG2_#v(n)
mhz                               rdiv(freq, 1000000)
mov16                             mov_mb 16,
mov24                             mov_mb 24,
mov8                              
mov_mb                            
movf_banksafe                     
movlw_tracker                     
movwf_banksafe                    
msec                              * 1000
nbDCL                             ALLOC_GPR NOBANK,
nbDCL16                           
nbDCL24                           
nop16                             00000004
nop32                             00000003
nop4                              00000006
nop8                              00000005
nop_multi                         
off_anim                          000001E2
pal_byte                          00000070
palent                            00000090
palpiece                          00000009
pct                               rdiv(100 * (num), den)
pmd_init                          
pps_lock                          
prescaler                         log2((base_freq) / (want_freq))
pxpiece                           00000009
rcv_frame                         0000017E
rcv_loop                          0000018A
rdiv                              (((num)+(den)/2)/MAX(den, 1))
red_anim                          000001CB
render_busy                       
scale                             (BIT(prescale) KHz / khz(freq))
sec                               * 1000000
set_fps_pxbit                     
setbit                            
showarg_0                         
stkptr_00size                     00000001
stkptr_10size                     00000001
swap_pair                         
swapreg                           
usec                              * 1
val_arg                           showarg_#v(argg)
wait2render                       
wait2xmit                         
wait4frame                        
wait4px                           
wait4timeout                      
waitpx                            
whilebit                          
withbit_0                         
withbit_1                         
withbit_2                         
withbit_3                         
withbit_4                         
withbit_5                         
withbit_6                         
withbit_7                         
withdest_0                        
withdest_1                        
ws_breakout_setup                 
ws_decode                         
ws_encbyte                        
ws_send_byte                      
ws_send_px                        
xmit_ready                        PIR3, TX1IF, yesno
xorlw_tracker                     
yield                             0000016E
yield_again                       00000171


MEMORY USAGE MAP ('X' = Used,  '-' = Unused)

0000 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0040 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0080 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
00C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0100 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0140 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0180 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
01C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXX---
8000 : -------XXXXX---- ---------------- ---------------- ----------------

All other memory blocks unused.

Program Memory Words Used:   514
Program Memory Words Free:  1534


Errors   :     0
Warnings :     0 reported,     0 suppressed
Messages :    43 reported,    67 suppressed


