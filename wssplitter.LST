MPASM 5.87  /HOME/DJ/MPLABXPROJECTS/WSSPLITT   11-10-2021  22:05:05         PAGE  1


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00001     title  "WS281X-Splitter - WS281X segment splitter/breakout/debug for Microchip PIC"
                      00002 ;================================================================================
                      00003 ; File:     wssplitter.asm
                      00004 ; Date:     8/11/2021
                      00005 ; Version:  0.21.10
                      00006 ; Author:   djulien@thejuliens.net, (c)2021 djulien@thejuliens.net
                      00007 ; Device:   PIC16F15313 (midrange Microchip 8-pin PIC) or equivalent running @8 MIPS
                      00008 ; Peripherals used: Timer0, Timer1 (gated), Timer2, no-MSSP, EUSART, no-PWM, CLC
                      00009 ; Compiler: mpasmx(v5.35), NOT pic-as; NOTE: custom build line is used for source code fixups
                      00010 ; IDE:      MPLABX v5.35 (last one to include mpasm)
                      00011 ; Description:
                      00012 ;   WS281X-Splitter can be used for the following purposes:
                      00013 ;   1. split a single WS281X data stream into <= 4 separate segments; 
                      00014 ;     creates a virtual daisy chain of LED strings instead of using null pixels between
                      00015 ;   2. debugger or signal integrity checker; show 24-bit WS pixel data at end of string
                      00016 ;   3. timing checker; display frame rate (FPS received); alternating color is used as heartbeat
                      00017 ; Build instructions:
                      00018 ;no   ?Add this line in the project properties box, pic-as Global Options -> Additional options:
                      00019 ;no   -Wa,-a -Wl,-pPor_Vec=0h,-pIsr_Vec=4h
                      00020 ;   - use PICKit2 or 3 or equivalent programmer (PICKit2 requires PICKitPlus for newer PICs)
                      00021 ; Wiring:
                      00022 ;  RA0 = debug output (32 px WS281X):
                      00023 ;        - first 24 px shows segment 1/2/3 quad px length (0 = 1K)
                      00024 ;        - next 8 px = FPS (255 max), msb first
                      00025 ;  RA1 = output segment 1
                      00026 ;  RA2 = output segment 2
                      00027 ;  RA3 = WS281X input stream
                      00028 ;        - first/second/third byte = segment 1/2/3 quad pixel length
                      00029 ;        - first segment data follows immediately
                      00030 ;  RA4 = output segment 4; receives anything after segment 1/2/3
                      00031 ;  RA5 = output segment 3
                      00032 ; TODO:
                      00033 ;  - use PPS to set RA3 as segment 3 out and RA5 as WS input?
                      00034 ;  - uart bootloader; ground segment 0 out to enable? auto-baud detect; verify
                      00035 ;  - custom pixel dup/skip, enforce max brightness limit?
                      00036 ;================================================================================
Message[301]: MESSAGE: (hoist 0: generic pic/asm helpers @3083)
Message[301]: MESSAGE: (TODO: fix this ^^^ vvv)
Message[301]: MESSAGE: (end of hoist 0 @3598)
Message[301]: MESSAGE: (no hoist, app config/defs @__LINE__)
                          M         exitm
                      00050 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                      00051 
                      00052 ;compile-time options:
                      00053 ;#define BITBANG; dev/test only
                      00054 ;;#define SPI_TEST
                      00055 #define WANT_DEBUG; DEV/TEST ONLY!
                      00056 ;#define WANT_ISR; ISR not used; uncomment to reserve for (jump from) ISR
                      00057 #define WSBIT_FREQ  (800 KHz); WS281X "high" speed
                      00058 #define WSLATCH  (50 -20 usec); end-of-frame latch time; "cheat" by using shorter interval and use the e
                            xtra time for processing overhead
MPASM 5.87  /HOME/DJ/MPLABXPROJECTS/WSSPLITT   11-10-2021  22:05:05         PAGE  2
WS281X-Splitter - WS281X segment splitter/breakout/debug for Microchip PIC

LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00059 ;#define MAX_THREADS  2; ani xmit or frame rcv, breakout xmit
                      00060 #define FOSC_FREQ  (32 MHz); max speed; TODO: check if lower speed will work
                      00061 
                      00062 ;pin assignments:
                      00063 #define WSDI  RA3; RA3 = WS input stream (from controller or previous WS281X pixels)
                      00064 #define BREAKOUT  RA0; RA0 = WS breakout pixels, or simple LED for dev/debug
                      00065 #define LEDOUT  IIFDEBUG(SEG4OUT, -1); RA5 = simple LED output; ONLY FOR DEV/DEBUG
                      00066 ;#define WSCLK  4-2; RA4 = WS input clock (recovered from WS input data signal); EUSART sync rcv clock n
                            eeds a real I/O pin?
                      00067 #define SEG1OUT  RA1; RA1 = WS output segment 1
                      00068 #define SEG2OUT  RA2; RA2 = WS output segment 2
                      00069 #define SEG3OUT  RA#v(3+2); RA5 = WS output segment 3; RA3 is input-only, use alternate pin for segment 
                            3
                      00070 #define SEG4OUT  RA4; RA4 = WS output segment 4
                      00071 #define RGSWAP  0x321; 3 = R, 2 = G, 1 = B; default = 0x123 = BGR
                      00072 ;123 = rbg
                      00073 ;132 = brg
                      00074 ;213 = gbr
                      00075 ;231 = grb
                      00076 ;312 = bgr
                      00077 ;321 = rgb
                      00078 
                      00079 ;peripherals:
                      00080 ;NOTE: PPS is locked and each WS output segment has its own CLC to copy RA3, rather than changing PPS al
                            l the time
                      00081 ;#define WSSYNC  3; PWM# generate WS data sync pulse
                      00082 ;#define WSPASS  1; CLC# pass-thru WS input -> output
                      00083 ;#define WSDO  2; CLC# generate composite WS data signal
                      00084 ;#define ONESHOT  3; CLC# to generate one-shot 0.5 usec pulse triggered by WS data signal
                      00085 
Message[301]: MESSAGE: (end of !hoist @__LINE__)
Message[301]: MESSAGE: (hoist 1: custom opc @1667)
Message[301]: MESSAGE: ([INFO] COMPILED FOR DEV/DEBUG! @1681)
  80000000                M ASM_MSB EQU -2147483648
0000                      M     ORG 0
                          M     nop_multi 1
0000   0000               M     nop
Message[301]: MESSAGE: (end of hoist 1 @3079)
Message[301]: MESSAGE: (hoist 2: cooperative multi-tasking ukernel @1165)
0001                      M     ORG ctx_addr_1
                          M     clrf_tracker PCLATH
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK PCLATH
0001   018A               M     clrf PCLATH
0002   2807               M     goto init_2
0007                      M     ORG ctx_addr_2
0007                      M init_2:
                      01573     iopin_init;
                          M     mov8 ANSELA, LITERAL(0); ; //all digital; CAUTION: do this before pin I/O
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND  ;reduce clutter
                          M ;    if (SRC == DEST) && ((srcbytes) == (destbytes)) && !(reverse)  ;nothing to do
  0000                    M     LOCAL SRC = (ASM_MSB | (0)) ;kludge; force eval (avoids "missing operand" and "missing argument" errors/MPASM bugs); also helps avoid "line too long" messages (MPASM li
  1F38                    M     LOCAL DEST = ANSELA ;kludge; force eval (avoids "missing operand" and "missing argument" errors/MPASM bugs); also helps avoid "line too long" messages (MPASM limit 200)
                          M     WARNIF(DEST == SRC, [WARNING] useless mov8 from ANSELA to (ASM_MSB | (0)) @2101);;
                          M ;    messg "mov8", #v(DEST), #v(SRC), #v(ISLIT(SRC)), #v(LIT2VAL(SRC)) @2102
                          M ;    messg src, dest @2103;
                          M     if ISLIT(SRC)  ;unpack SRC bytes
                          M ; messg dest, #v(!LIT2VAL(SRC)), #v(DEST != WREG), #v(!(DEST & INDF0_special)), #v(!(DEST & INDF1_special)) @2105
                          M         if !LIT2VAL(SRC) && (DEST != WREG) && !(DEST & INDF0_special) && !(DEST & INDF1_special)
                          M ;           BANKCHK dest;
                          M ;           BANKSAFE clrf dest; special case
                          M ;           EMIT CLRF dest;
                          M             CLRF ANSELA;
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK ANSELA
0007   017E               M     banksel ANSELA
0008   01B8               M     clrf ANSELA
0009   3008               M     movlw (((ASM_MSB | ((1 << (RA3))))) & ~ASM_MSB)
000A   00B9               M     movwf WPUA
000B   0140               M     banksel LATA
000C   0198               M     clrf LATA
000D   0092               M     movwf TRISA
000E   0151               M     banksel OSCCON3
                          M     withbit_7 bcf OSCCON3
000F   138F               M     bcf OSCCON3, 7
0010   3060               M     movlw (((ASM_MSB | (b'110' << NOSC0 | 0 << NDIV0))) & ~ASM_MSB)
0011   008D               M     movwf OSCCON1
0012   3006               M     movlw (((ASM_MSB | (HFFRQ_32000000))) & ~ASM_MSB)
0013   0093               M     movwf OSCFRQ
0014   307F               M     movlw (((ASM_MSB | (0xFF ^ (1 << (SYSCMD))))) & ~ASM_MSB)
0015   014F               M     banksel PMD0
0016   0096               M     movwf PMD0
0017   30F8               M     movlw (((ASM_MSB | (0xFF ^ (1 << (TMR2MD)) ^ (1 << (TMR1MD)) ^ (1 << (TMR0MD))))) & ~ASM_MSB)
0018   0097               M     movwf PMD1
0019   30FF               M     movlw (((ASM_MSB | (0xFF))) & ~ASM_MSB)
001A   0098               M     movwf PMD2
001B   0099               M     movwf PMD3
001C   30BF               M     movlw (((ASM_MSB | (0xFF ^ (1 << (UART1MD))))) & ~ASM_MSB)
001D   009A               M     movwf PMD4
001E   019B               M     clrf PMD5
Message[301]: MESSAGE: ([TODO] use RSTOSC HFINT 1MHz? @1613)
Message[301]: MESSAGE: ([TODO] boot loader + LVP? @1632)
8007   178C           01644     __config _CONFIG1, MY_CONFIG1
8008   2FFE           01645     __config _CONFIG2, MY_CONFIG2
8009   3F9F           01646     __config _CONFIG3, MY_CONFIG3
800A   1FFF           01647     __config _CONFIG4, MY_CONFIG4
800B   3FFF           01648     __config _CONFIG5, MY_CONFIG5
Message[301]: MESSAGE: (end of hoist 2 @1663)
Message[301]: MESSAGE: (hoist 3: app helpers @581)
Message[301]: MESSAGE: ([INFO] uart 16-bit brg ((32 * 1000000) / (2400 * 1000) / 4 - 1)) = 2 @698)
Message[301]: MESSAGE: ([DEBUG] rgb order 0x321, R = 2, G = 1, B = 0 @748)
Message[301]: MESSAGE: ([INFO] reversing breakout bit order (EUSART sends lsb first) @857)
Message[301]: MESSAGE: (end of hoist 3 @1161)
Message[301]: MESSAGE: (NO-hoist 4: fps tracking thread @92)
                          M         exitm
                      00095 ;; fps tracking thread ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                      00096 
                      00097 #if 0; OBSOLETE; combined into rcv_frame thread for efficiency
                      00098     THREAD_DEF fps_tracking, 2
                      00099 
                      00100     nbDCL FPS_count,;;
                      00101     nbDCL FPS_render,; ; save latest count so rendering can be done while counting frames
                      00102 
                      00103 fps_tracking: DROP_CONTEXT;
                      00104 ;    fps_init 1 sec; do this in rcv_frame thread after running brkout_ani
                      00105 ;    mov8 count_FPS, LITERAL(0); FPS will be junk until rcv_frame is finished startup
                      00106 fps_loop:
                      00107     mov8 FPS_render, FPS_count; rendered by brkout thread
                      00108     mov8 FPS_count, LITERAL(0); ; updated by rcv frame
                      00109     wait4frame YIELD, YIELD_AGAIN; 1 sec
                      00110 ;    wait4render YIELD, YIELD_AGAIN; don't change breakout px while being rendered
                      00111 ;use cyan for even frames (heartbeat):
                      00112 ;    set_brkout_px 24+0, FPS, 7, WHITE_RGBINX, CYAN_RGBINX;
                      00113 ;    set_brkout_px 24+1, FPS, 6, WHITE_RGBINX, CYAN_RGBINX;
                      00114 ;    set_brkout_px 24+2, FPS, 5, WHITE_RGBINX, CYAN_RGBINX;
                      00115 ;    set_brkout_px 24+3, FPS, 4, WHITE_RGBINX, CYAN_RGBINX;
                      00116 ;    set_brkout_px 24+4, FPS, 3, WHITE_RGBINX, CYAN_RGBINX;
                      00117 ;    set_brkout_px 24+5, FPS, 2, WHITE_RGBINX, CYAN_RGBINX;
                      00118 ;    set_brkout_px 24+6, FPS, 1, WHITE_RGBINX, CYAN_RGBINX;
                      00119 ;    set_brkout_px 24+7, FPS, 0, WHITE_RGBINX, CYAN_RGBINX;
                      00120 ;    mov8 FPS, LITERAL(0);
                      00121 ;    wait4frame YIELD, YIELD_AGAIN; 1 sec
                      00122 ;    wait4render YIELD, YIELD_AGAIN; don't change breakout px while being rendered
                      00123 ;use magenta for odd frames (heartbeat):
                      00124 ;    set_brkout_px 24+0, FPS, 7, WHITE_RGBINX, MAGENTA_RGBINX;
                      00125 ;    set_brkout_px 24+1, FPS, 6, WHITE_RGBINX, MAGENTA_RGBINX;
                      00126 ;    set_brkout_px 24+2, FPS, 5, WHITE_RGBINX, MAGENTA_RGBINX;
                      00127 ;    set_brkout_px 24+3, FPS, 4, WHITE_RGBINX, MAGENTA_RGBINX;
                      00128 ;    set_brkout_px 24+4, FPS, 3, WHITE_RGBINX, MAGENTA_RGBINX;
                      00129 ;    set_brkout_px 24+5, FPS, 2, WHITE_RGBINX, MAGENTA_RGBINX;
                      00130 ;    set_brkout_px 24+6, FPS, 1, WHITE_RGBINX, MAGENTA_RGBINX;
                      00131 ;    set_brkout_px 24+7, FPS, 0, WHITE_RGBINX, MAGENTA_RGBINX;
                      00132     goto fps_loop;
                      00133     
                      00134 ;wait4render macro idler, idler2
                      00135 ;    whilebit FSR0L, breakout_eof(FALSE), idler
                      00136 ;    whilebit FSR0L, breakout_eof(FALSE), idler2
                      00137 ;    endm
                      00138 ;set_brkout_px macro pxofs, val, bitnum, oncolor, offcolor
                      00139 ;    movlw offcolor
                      00140 ;    ifbit val, bitnum, TRUE, movlw oncolor
                      00141 ;    mov8 brkoutpx+pxofs, WREG;
                      00142 ;    endm
                      00143     
                      00144 ;;    CONSTANT BRKOUT#v(3)_RGBINX  CYAN_RGBINX; FPS
                      00145 ;    CONSTANT BRKOUT#v(4)_RGBINX  MAGENTA_RGBINX; alternate FPS (heartbeat)
                      00146 
                      00147     THREAD_END;
                      00148 #endif; 0
                      00149 
Message[301]: MESSAGE: (end of hoist 4 @152)
Message[301]: MESSAGE: (hoist 5: brkout render thread @346)
                          M         exitm
                      00349 ;; breakout render thread ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                      00350     
                      00351 ;RGB color indexes:
                      00352 ;3 lsb control R/G/B on/off (for easier color combinations/debug):
                      00353 ;4th bit is brightness
  0004                00354     CONSTANT RED_RGBINX = 4;
  0002                00355     CONSTANT GREEN_RGBINX = 2;
  0001                00356     CONSTANT BLUE_RGBINX = 1;
                      00357 #define BRIGHT(rgb)  ((rgb) + 8); brighter variant
  0006                00358     CONSTANT YELLOW_RGBINX = RED_RGBINX | GREEN_RGBINX;
  0003                00359     CONSTANT CYAN_RGBINX = GREEN_RGBINX | BLUE_RGBINX;
  0005                00360     CONSTANT MAGENTA_RGBINX = RED_RGBINX | BLUE_RGBINX;
  0005                00361     CONSTANT PINK_RGBINX = MAGENTA_RGBINX; easier to spell :P
  0007                00362     CONSTANT WHITE_RGBINX = RED_RGBINX | GREEN_RGBINX | BLUE_RGBINX;
  0000                00363     CONSTANT OFF_RGBINX = 0; "black"
  0008                00364     CONSTANT CUSTOM_RGBINX = BRIGHT(0); ; caller-defined palette entry
                      00365 ;0, B, G, C, R, M, Y, W
                      00366 
                      00367 ;indexed color palette:
                      00368 ;palette consists of 15 hard-coded colors + 1 caller-defined custom color
                      00369     nbDCL24 ccolor; caller-defined custom color
                          M     CBLOCK NEXT_RAM9999; BOOL2INT(banked))  ;continue where we left off last time
  00000070                M         ccolor :3
                          M     ENDC  ;can't span macros
  0071                    M     CONSTANT ccolor0mid = ccolor + 1
  0072                    M     CONSTANT ccolor0hi = ccolor + 2
                      00370 ;use EQU to show 32 bit values in .LST
                      00371 ;primary colors (dim):
  80000000            00372 PALETTE_0              EQU LITERAL(0); ; off
  80000200            00373 PALETTE_4              EQU LITERAL(0x000200); ; red dim
  80020000            00374 PALETTE_2                EQU LITERAL(0x020000); ; green dim
  80010100            00375 PALETTE_6                 EQU LITERAL(0x010100); ; yellow dim; try to keep consistent brightness with single colors
  80000002            00376 PALETTE_1               EQU LITERAL(0x000002); ; blue dim
  80000101            00377 PALETTE_5                  EQU LITERAL(0x000101); ; magenta dim; try to keep consistent brightness with single colors
  80010001            00378 PALETTE_3               EQU LITERAL(0x010001); ; cyan dim; try to keep consistent brightness with single colors
  80010101            00379 PALETTE_7                EQU LITERAL(0x010101); ; white dim; try to keep consistent brightness with single colors
                      00380 ;primary colors (bright):
  8000FF00            00381 PALETTE_12                     EQU LITERAL(0x00FF00); ; red bright
  80FF0000            00382 PALETTE_10                       EQU LITERAL(0xFF0000); ; green bright
  80808000            00383 PALETTE_14                        EQU LITERAL(0x808000); ; yellow bright; try to keep consistent brightness with single colors
  800000FF            00384 PALETTE_9                       EQU LITERAL(0x0000FF); ; blue bright
  80008080            00385 PALETTE_13                         EQU LITERAL(0x008080); ; magenta bright; try to keep consistent brightness with single colors
  80800080            00386 PALETTE_11                      EQU LITERAL(0x800080); ; cyan bright; try to keep consistent brightness with single colors
  80555555            00387 PALETTE_15                       EQU LITERAL(0x555555); ; white dim; try to keep consistent brightness with single colors
  00000070            00388 PALETTE_8                 EQU ccolor; caller-defined palette entry
                      00389 
                      00390 
                      00391 ;display buffer:
                      00392 ;#define NUMPX  #v(24 + 8); 24 px for first wspixel received + 8 px for fps
                      00393 ;    b0DCL brkoutpx:#v(NUMPX/2); 1 nibble per pixel (color indexed); FSR# handles banking
                      00394     b0DCL brkoutpx,:(24 + 8) / 1; 1/2 byte per pixel (color indexed): 24px for first rcv pixel + 8 px for fps; FSR# handles banking
                          M     CBLOCK NEXT_RAM0; BOOL2INT(banked))  ;continue where we left off last time
  00000020                M         brkoutpx :(24 + 8) / 1
                          M     ENDC  ;can't span macros
                      00395     find_msb ENDOF(brkoutpx);;
                          M             exitm
                      00396 ;    messg #v(FOUND_MSB), #v(ENDOF(brkoutpx)) @396
                      00397 ;TODO? 4 bpp, 2 px/byte
                      00398 ;TODO? linear addr?
                      00399 ;check if fsr is at breakout eof:
                      00400 ;CAUTION: uses linear addr + assumes power of 2
                      00401 ;#define END_DETECT  SIZEOF(brkoutpx); (0x20 + 24+8); 0X40; BIT(5); CAUTION: only works with power of 2
                      00402     if ENDOF(brkoutpx) == FOUND_MSB; can use single-bit check
                      00403 #define breakout_eof(yesno)  log2(ENDOF(brkoutpx)), IIF(brkoutpx & ENDOF(brkoutpx), !(yesno), yesno); BOOL2INT(brkoutpx & ENDOF(brkoutpx)) ^ BOOL2INT(yesno)
Message[301]: MESSAGE: ([INFO] #brkout pxbuf 32 @32, eof@ 64, detect& 0 @404)
                      00404     messg [INFO] #brkout pxbuf 32                   @32,           eof@ 64,                  detect& 0                              @404
                      00405 ;    ERRIF((ENDOF(brkoutpx) - 1) & END_DETECT == ENDOF(brkoutpx) & END_DETECT, [ERROR] pixelbuf end detect broken, !span #v(END_DETECT): #v(brkoutpx) @405)
                      00406 ;    messg ENDOF(brkoutpx) #v(ENDOF(brkoutpx))
                      00407 ;    messg log2(ENDOF(brkoutpx)) #v(log2(ENDOF(brkoutpx)))
                      00408 ;    messg ENDOF(brkoutpx), #v(ENDOF(brkoutpx))
                      00409     ERRIF(!log2(ENDOF(brkoutpx)), [ERROR] breakout pxbuf end detect !power of 2: 64","                  simple bit test won''t work @409)
                      00410 #else
                      00411     error TODO: brkoupx eof check: 64                  @411
                      00412 #endif
                      00413 
                      00414 ;#define render_busy(yesno)  mov16 FSR0, LITERAL(IIF(yesno, brkoutpx, ENDOF(brkoutpx)))
                      00415 render_busy macro yesno
                      00416     if !(yesno) && (ENDOF(brkoutpx) == FOUND_MSB); use single-bit check
                      00417         setbit FSR0L, breakout_eof(TRUE); just set eof bit (faster than setting entire FSR0)
                      00418         exitm
                      00419     endif
                      00420     mov16 FSR0, LITERAL(IIF(yesno, brkoutpx, ENDOF(brkoutpx)))
                      00421     endm
                      00422 
                      00423 wait2render macro idler, idler2
                      00425 ;    ifbit FSR0L, breakout_eof(TRUE), idler; goto brkout_wait; log2(64), !((brkoutpx + 32) & 64), goto brkout_loop; nothing to send
                      00426     idler; assume not ready yet, let other threads run
                      00427     ifbit FSR0L, breakout_eof(TRUE), idler2; goto brkout_wait; log2(64), !((brkoutpx + 32) & 64), goto brkout_loop; nothing to send
                      00429     endm
                      00430 
                      00431 ;swap a pair of pixels:
                      00432 swap_pair macro ofs
                      00433     swapreg brkoutpx + ofs, brkoutpx + (ofs ^ 1)
                      00434     endm
                      00435 
                      00436 ;brkoutpx initial state:
                      00437 ;    more_init TRUE;
                      00438 ;    mov16 FSR0, LITERAL(brkoutpx);
                      00439 ;    movlw OFF_RGBINX;
                      00440 ;brkout_initloop:
                      00441 ;    mov8 INDF0_postinc, WREG;
                      00442 ;    ifbit FSR0L, breakout_eof(FALSE), goto brkout_initloop;
                      00443 ;    more_init FALSE
                      00444 
                      00445 ;breakout byte pixel colors:
                      00446 ;#define FPS_RGBINX  CYAN_RGBINX
                      00447 ;    CONSTANT BRKOUT#v(0)_RGBINX  RED_RGBINX; first byte
                      00448 ;    CONSTANT BRKOUT#v(1)_RGBINX  GREEN_RGBINX; second byte
                      00449 ;    CONSTANT BRKOUT#v(2)_RGBINX  BLUE_RGBINX; third byte
                      00450 ;    CONSTANT BRKOUT#v(3)_RGBINX  CYAN_RGBINX; FPS
                      00451 ;    CONSTANT BRKOUT#v(4)_RGBINX  MAGENTA_RGBINX; alternate FPS (heartbeat)
                      00452 
                      00453     
                      00454     THREAD_DEF brkout_render, 4
                          M     CBLOCK NEXT_RAM9999; BOOL2INT(banked))  ;continue where we left off last time
  00000073                M         stkptr_0 
                          M     ENDC  ;can't span macros
Message[301]: MESSAGE: (creating brkout_render thread# 0 @32, stack size 4, host stack remaining: 12 @1218)
0020   017F               M     banksel STKPTR
                          M     withdest_0 movf STKPTR
0021   086D               M     movf STKPTR, W;
0022   00F3               M     movwf stkptr_0
0026   0008               M     return
001F                      M     ORG ctx_addr_3
001F   2827               M     goto init_3
0027                      M     ORG ctx_addr_5
0027                      M init_3:
0027   202A               M     call stack_alloc_0
0028   2030               M     call brkout_render
0029   2828               M     goto $-1
002A   017F               M     banksel STKPTR
                          M     withdest_0 movf STKPTR
002B   086D               M     movf STKPTR, W;
002C   00F3               M     movwf stkptr_0
002D   3003               M     movlw 4 - 1
                          M     withdest_1 addwf STKPTR
002E   07ED               M     addwf STKPTR, F;
                      00455 
                      00456 #if 0; uses a lot of prog space
                      00457 ;send palette entry to next WS pixel:
                      00458     VARIABLE palinx = 0;
                      00459     while palinx < 16
                      00460 ws_send_pal0:          DROP_CONTEXT;
                      00461         ws_send_px PALETTE_0,          TRUE, YIELD, YIELD_AGAIN; 3x3 bytes
                      00462         return;
                      00463 palinx += 1;
                      00464     endw
                      00465 ;in: WREG contains color index (4-bit value); caller can pack 2/byte if desired
                      00466 ws_send_palette: DROP_CONTEXT
                      00467     andlw 0x0F;
                      00468     brw;
                      00469     while palinx < 16+16
                      00470         goto ws_send_pal0; 3x3 bytes
                      00471 palinx += 1;
                      00472     endw
                      00473 #endif
                      00474 ;want expand to:
                      00475 ;repeat:
                      00476 ;;    ifbit xmit_ready(TRUE), goto around
                      00477 ;;    YIELD;
                      00478 ;;    ifbit xmit_ready(FALSE), YIELD_AGAIN; more efficient than goto $-3 + call
                      00479 ;;    dont-goto repeat
                      00480 ;;around:
                      00481 ;    ifbit xmit_ready(FALSE), YIELD;
                      00482 ;    ifbit xmit_ready(FALSE), YIELD_AGAIN; more efficient than goto $-3 + call
                      00483     
                      00484 ;in: WREG = palinx
                      00485 ;piece:
                      00486 ;  1, 2, 3 to get entire byte
                      00487 ;or 1/3, 2/3, 3/3 to get SPI3x-encoded piece of byte
                      00488 ;unneeded: get_palent_byte macro piece
                      00489 ;    andlw 0x0F;
                      00490 ;    brw
                      00491 ;    LOCAL WHICH = SPI3x_detect(piece); 1, 2, 4 (SPI3x pieces) or 3, 6, 12 (bytes)
                      00492 ;    LOCAL palinx = 0
                      00493 ;    while palinx < 15
                      00494 ;       if !(WHICH % 3); whole byte
                      00495 ;           retlw BYTEOF(PALETTE_#v(palinx), (piece) - 1);
                      00496 ;       else; partial byte
                      00497 ;           ws_encbyte BYTE, 2/3; before wait so it's ready
                      00498 ;    messg TODO: ^^^ needs work @498
                      00499 ;           return;
                      00500 ;       endif
                      00501 ;    endm
                      00502 
                      00503 ;    init_more TRUE
                      00504 ;    ws_breakout_setup;
                      00505 ;    init_more FALSE;
                      00506 
                      00507 ;use FSR0 to send breakout, leave FSR1 for caller to use for animation or render
                      00508 brkout_render: DROP_CONTEXT;
                      00509     ws_breakout_setup; eusart init @SPI 3x (2.4 Mbps)
0030   3010               M     movlw (((ASM_MSB | (0x10))) & ~ASM_MSB)
0031   017E               M     banksel RA0PPS
0032   0090               M     movwf RA0PPS
0033   017D               M     banksel RX1DTPPS
0034   01CB               M     clrf RX1DTPPS
0035   3003               M     movlw (((ASM_MSB | (RA3))) & ~ASM_MSB)
0036   00CC               M     movwf TX1CKPPS
Message[301]: MESSAGE: (TODO: ^^^ are these 2 needed?)
0037   0140               M     banksel TRISA
                          M     withbit_0 bsf TRISA
0038   1412               M     bsf TRISA, 0;
0039   301A               M     movlw (((ASM_MSB | (0x20 * 10/12))) & ~ASM_MSB)
003A   0151               M     banksel OSCTUNE
003B   0092               M     movwf OSCTUNE
003C   0142               M     banksel RC1STA
003D   019D               M     clrf RC1STA
003E   30B4               M     movlw (((ASM_MSB | ((1 << (CSRC)) | 0 | (1 << (TXEN)) | (1 << (SYNC_TXSTA)) | (1 << (BRGH))))) & ~ASM_MSB)
003F   009E               M     movwf TX1STA
0040   3008               M     movlw (((ASM_MSB | (0 | (1 << (BRG16))))) & ~ASM_MSB)
0041   009F               M     movwf BAUD1CON
0042   3002               M     movlw (((ASM_MSB | (_849SRC & 0xFF))) & ~ASM_MSB)
0043   009B               M     movwf SP1BRG
0044   019C               M     clrf SP1BRG0hi
                          M     withbit_7 bsf RC1STA
0045   179D               M     bsf RC1STA, 7
                      00510     render_busy(FALSE); ; set empty outbuf
                          M     withbit_6 bsf FSR0L
0046   1704               M     bsf FSR0L, 6
                          M         exitm
                      00511 ;    mov16 FSR0, LITERAL(ENDOF(brkoutpx)); set empty outbuf
                      00512 brkout_loop: DROP_CONTEXT;
                      00513 ;    setbit LATA, BREAKOUT, TRUE;
                      00514 ;    wait4frame YIELD, YIELD_AGAIN; 1 sec
                      00515 ;    NOP 16
                      00516 ;    setbit LATA, BREAKOUT, FALSE;
                      00517 ;    wait4frame YIELD, YIELD_AGAIN; 1 sec
                      00518 ;    NOP 16
                      00519 ;    ifbit FSR0L, breakout_eof(TRUE), YIELD; goto brkout_wait; log2(64), !((brkoutpx + 32) & 64), goto brkout_loop; nothing to send
                      00520 ;    ifbit FSR0L, breakout_eof(TRUE), YIELD_AGAIN; goto brkout_wait; log2(64), !((brkoutpx + 32) & 64), goto brkout_loop; nothing to send
                      00521     wait2render YIELD, YIELD_AGAIN; only yield 1x/breakout px; this prevents unexpected gaps during WS xmit (seems to be okay *between* WS px); breakout px only needs to be
0047   2020               M     call yield
                          M     goto_pagesafe yield_again
                          M ;    EXPAND_PUSH FALSE
                          M ; messg here1 @2947
                          M     ERRIF(LITPAGEOF(yield_again), [ERROR] "dest" yield_again 35 !on page 0: 0           @2948)
                          M ; messg here2 @2949
                          M ;PAGESEL_DROP += 1
                          M ;    messg goto dest, page tracker #v(PAGE_TRACKER), need page sel? #v(LITPAGEOF(dest)) != #v(LITPAGEOF(PAGE_TRACKER))? #v(LITPAGEOF(dest) != LITPAGEOF(PAGE_TRACKER))
                          M     if LITPAGEOF(yield_again) != LITPAGEOF(PAGE_TRACKER)
                          M         EMIT CLRF PCLATH; PAGESEL dest; kludge: mpasm doesn't want to pagesel
                          M PAGESEL_KEEP += 1
                          M     else
  00000006                M PAGESEL_DROP += 1
                          M     endif
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M ; messg here3 @2959
                          M     EMIT goto yield_again; PROGDCL 0x2000 | (dest); call dest
0049   2823               M     goto yield_again
  00000023                M PAGE_TRACKER = yield_again;
                          M ; messg here4 @2962
                          M ;    NOEXPAND
                          M ;not needed: fall-thru would be handled by earlier code    DROP_CONTEXT; BSR and WREG unknown here if dest falls through
                          M ;    EXPAND_POP
0048                      M     ORG ctx_addr_7
004A                      M     ORG ctx_addr_8
  0000                00522     VARIABLE pxpiece = 0;
                      00523     while pxpiece < 3*3; each px takes 9 bytes (3 rgb bytes * 3 SPI bytes)
                      00524 ;        wait2xmit YIELD, YIELD_AGAIN; wait before loading WREG to avoid save/restore
                      00525         mov8 WREG, IIF(pxpiece == 9-1, INDF0_postinc, INDF0);;
                          M     withdest_0 movf (((pxpiece == 9-1) != 0) * ((INDF0_postinc) - (INDF0)) + (INDF0))
004A   0800               M     movf (((pxpiece == 9-1) != 0) * ((INDF0_postinc) - (INDF0)) + (INDF0)), W;
                      00526         CALL get_palent_encpiece_0;
004B   208A               M     call get_palent_encpiece_0
                      00527 ;        ws_send_byte WREG, TRUE, YIELD, YIELD_AGAIN;
                      00528 ;       ws_encbyte BYTE, 2/3; after wait to protect WREG, but might cause latency
                      00529         whilebit xmit_ready(FALSE), NULL_STMT; CAUTION: TX1IF !valid until 2 instr after TX1REG; do next byte prep first
004C                      M _994loop:
004C   014E               M     banksel PIR3
004F                      M     ORG $
004D                      M     ORG ctx_addr_9
                          M     goto_pagesafe _994before_addr
                          M ;    EXPAND_PUSH FALSE
                          M ; messg here1 @2947
                          M     ERRIF(LITPAGEOF(_994before_addr), [ERROR] "dest" _994before_addr 77 !on page 0: 0   @2948)
                          M ; messg here2 @2949
                          M ;PAGESEL_DROP += 1
                          M ;    messg goto dest, page tracker #v(PAGE_TRACKER), need page sel? #v(LITPAGEOF(dest)) != #v(LITPAGEOF(PAGE_TRACKER))? #v(LITPAGEOF(dest) != LITPAGEOF(PAGE_TRACKER))
                          M     if LITPAGEOF(_994before_addr) != LITPAGEOF(PAGE_TRACKER)
                          M         EMIT CLRF PCLATH; PAGESEL dest; kludge: mpasm doesn't want to pagesel
                          M PAGESEL_KEEP += 1
                          M     else
  00000008                M PAGESEL_DROP += 1
                          M     endif
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M ; messg here3 @2959
                          M     EMIT goto _994before_addr; PROGDCL 0x2000 | (dest); call dest
004E   284D               M     goto _994before_addr
  0000004D                M PAGE_TRACKER = _994before_addr;
                          M ; messg here4 @2962
                          M ;    NOEXPAND
                          M ;not needed: fall-thru would be handled by earlier code    DROP_CONTEXT; BSR and WREG unknown here if dest falls through
                          M ;    EXPAND_POP
004D                      M     ORG ctx_addr_11
004F                      M     ORG ctx_addr_12
                      00530         mov8 TX1REG, WREG; start xmit
004F   0142               M     banksel TX1REG
0050   009A               M     movwf TX1REG
  00000001            00531 pxpiece += 1
                      00524 ;        wait2xmit YIELD, YIELD_AGAIN; wait before loading WREG to avoid save/restore
                      00525         mov8 WREG, IIF(pxpiece == 9-1, INDF0_postinc, INDF0);;
                          M     withdest_0 movf (((pxpiece == 9-1) != 0) * ((INDF0_postinc) - (INDF0)) + (INDF0))
0051   0800               M     movf (((pxpiece == 9-1) != 0) * ((INDF0_postinc) - (INDF0)) + (INDF0)), W;
                      00526         CALL get_palent_encpiece_1;
0052   20A4               M     call get_palent_encpiece_1
                      00527 ;        ws_send_byte WREG, TRUE, YIELD, YIELD_AGAIN;
                      00528 ;       ws_encbyte BYTE, 2/3; after wait to protect WREG, but might cause latency
                      00529         whilebit xmit_ready(FALSE), NULL_STMT; CAUTION: TX1IF !valid until 2 instr after TX1REG; do next byte prep first
0053                      M _1102loop:
0053   014E               M     banksel PIR3
0056                      M     ORG $
0054                      M     ORG ctx_addr_13
                          M     goto_pagesafe _1102before_addr
                          M ;    EXPAND_PUSH FALSE
                          M ; messg here1 @2947
                          M     ERRIF(LITPAGEOF(_1102before_addr), [ERROR] "dest" _1102before_addr 84 !on page 0: 0 @2948)
                          M ; messg here2 @2949
                          M ;PAGESEL_DROP += 1
                          M ;    messg goto dest, page tracker #v(PAGE_TRACKER), need page sel? #v(LITPAGEOF(dest)) != #v(LITPAGEOF(PAGE_TRACKER))? #v(LITPAGEOF(dest) != LITPAGEOF(PAGE_TRACKER))
                          M     if LITPAGEOF(_1102before_addr) != LITPAGEOF(PAGE_TRACKER)
                          M         EMIT CLRF PCLATH; PAGESEL dest; kludge: mpasm doesn't want to pagesel
                          M PAGESEL_KEEP += 1
                          M     else
  0000000A                M PAGESEL_DROP += 1
                          M     endif
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M ; messg here3 @2959
                          M     EMIT goto _1102before_addr; PROGDCL 0x2000 | (dest); call dest
0055   2854               M     goto _1102before_addr
  00000054                M PAGE_TRACKER = _1102before_addr;
                          M ; messg here4 @2962
                          M ;    NOEXPAND
                          M ;not needed: fall-thru would be handled by earlier code    DROP_CONTEXT; BSR and WREG unknown here if dest falls through
                          M ;    EXPAND_POP
0054                      M     ORG ctx_addr_15
0056                      M     ORG ctx_addr_16
                      00530         mov8 TX1REG, WREG; start xmit
0056   0142               M     banksel TX1REG
0057   009A               M     movwf TX1REG
  00000002            00531 pxpiece += 1
                      00524 ;        wait2xmit YIELD, YIELD_AGAIN; wait before loading WREG to avoid save/restore
                      00525         mov8 WREG, IIF(pxpiece == 9-1, INDF0_postinc, INDF0);;
                          M     withdest_0 movf (((pxpiece == 9-1) != 0) * ((INDF0_postinc) - (INDF0)) + (INDF0))
0058   0800               M     movf (((pxpiece == 9-1) != 0) * ((INDF0_postinc) - (INDF0)) + (INDF0)), W;
                      00526         CALL get_palent_encpiece_2;
0059   20BC               M     call get_palent_encpiece_2
                      00527 ;        ws_send_byte WREG, TRUE, YIELD, YIELD_AGAIN;
                      00528 ;       ws_encbyte BYTE, 2/3; after wait to protect WREG, but might cause latency
                      00529         whilebit xmit_ready(FALSE), NULL_STMT; CAUTION: TX1IF !valid until 2 instr after TX1REG; do next byte prep first
005A                      M _1210loop:
005A   014E               M     banksel PIR3
005D                      M     ORG $
005B                      M     ORG ctx_addr_17
                          M     goto_pagesafe _1210before_addr
                          M ;    EXPAND_PUSH FALSE
                          M ; messg here1 @2947
                          M     ERRIF(LITPAGEOF(_1210before_addr), [ERROR] "dest" _1210before_addr 91 !on page 0: 0 @2948)
                          M ; messg here2 @2949
                          M ;PAGESEL_DROP += 1
                          M ;    messg goto dest, page tracker #v(PAGE_TRACKER), need page sel? #v(LITPAGEOF(dest)) != #v(LITPAGEOF(PAGE_TRACKER))? #v(LITPAGEOF(dest) != LITPAGEOF(PAGE_TRACKER))
                          M     if LITPAGEOF(_1210before_addr) != LITPAGEOF(PAGE_TRACKER)
                          M         EMIT CLRF PCLATH; PAGESEL dest; kludge: mpasm doesn't want to pagesel
                          M PAGESEL_KEEP += 1
                          M     else
  0000000C                M PAGESEL_DROP += 1
                          M     endif
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M ; messg here3 @2959
                          M     EMIT goto _1210before_addr; PROGDCL 0x2000 | (dest); call dest
005C   285B               M     goto _1210before_addr
  0000005B                M PAGE_TRACKER = _1210before_addr;
                          M ; messg here4 @2962
                          M ;    NOEXPAND
                          M ;not needed: fall-thru would be handled by earlier code    DROP_CONTEXT; BSR and WREG unknown here if dest falls through
                          M ;    EXPAND_POP
005B                      M     ORG ctx_addr_19
005D                      M     ORG ctx_addr_20
                      00530         mov8 TX1REG, WREG; start xmit
005D   0142               M     banksel TX1REG
005E   009A               M     movwf TX1REG
  00000003            00531 pxpiece += 1
                      00524 ;        wait2xmit YIELD, YIELD_AGAIN; wait before loading WREG to avoid save/restore
                      00525         mov8 WREG, IIF(pxpiece == 9-1, INDF0_postinc, INDF0);;
                          M     withdest_0 movf (((pxpiece == 9-1) != 0) * ((INDF0_postinc) - (INDF0)) + (INDF0))
005F   0800               M     movf (((pxpiece == 9-1) != 0) * ((INDF0_postinc) - (INDF0)) + (INDF0)), W;
                      00526         CALL get_palent_encpiece_3;
0060   20D6               M     call get_palent_encpiece_3
                      00527 ;        ws_send_byte WREG, TRUE, YIELD, YIELD_AGAIN;
                      00528 ;       ws_encbyte BYTE, 2/3; after wait to protect WREG, but might cause latency
                      00529         whilebit xmit_ready(FALSE), NULL_STMT; CAUTION: TX1IF !valid until 2 instr after TX1REG; do next byte prep first
0061                      M _1318loop:
0061   014E               M     banksel PIR3
0064                      M     ORG $
0062                      M     ORG ctx_addr_21
                          M     goto_pagesafe _1318before_addr
                          M ;    EXPAND_PUSH FALSE
                          M ; messg here1 @2947
                          M     ERRIF(LITPAGEOF(_1318before_addr), [ERROR] "dest" _1318before_addr 98 !on page 0: 0 @2948)
                          M ; messg here2 @2949
                          M ;PAGESEL_DROP += 1
                          M ;    messg goto dest, page tracker #v(PAGE_TRACKER), need page sel? #v(LITPAGEOF(dest)) != #v(LITPAGEOF(PAGE_TRACKER))? #v(LITPAGEOF(dest) != LITPAGEOF(PAGE_TRACKER))
                          M     if LITPAGEOF(_1318before_addr) != LITPAGEOF(PAGE_TRACKER)
                          M         EMIT CLRF PCLATH; PAGESEL dest; kludge: mpasm doesn't want to pagesel
                          M PAGESEL_KEEP += 1
                          M     else
  0000000E                M PAGESEL_DROP += 1
                          M     endif
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M ; messg here3 @2959
                          M     EMIT goto _1318before_addr; PROGDCL 0x2000 | (dest); call dest
0063   2862               M     goto _1318before_addr
  00000062                M PAGE_TRACKER = _1318before_addr;
                          M ; messg here4 @2962
                          M ;    NOEXPAND
                          M ;not needed: fall-thru would be handled by earlier code    DROP_CONTEXT; BSR and WREG unknown here if dest falls through
                          M ;    EXPAND_POP
0062                      M     ORG ctx_addr_23
0064                      M     ORG ctx_addr_24
                      00530         mov8 TX1REG, WREG; start xmit
0064   0142               M     banksel TX1REG
0065   009A               M     movwf TX1REG
  00000004            00531 pxpiece += 1
                      00524 ;        wait2xmit YIELD, YIELD_AGAIN; wait before loading WREG to avoid save/restore
                      00525         mov8 WREG, IIF(pxpiece == 9-1, INDF0_postinc, INDF0);;
                          M     withdest_0 movf (((pxpiece == 9-1) != 0) * ((INDF0_postinc) - (INDF0)) + (INDF0))
0066   0800               M     movf (((pxpiece == 9-1) != 0) * ((INDF0_postinc) - (INDF0)) + (INDF0)), W;
                      00526         CALL get_palent_encpiece_4;
0067   20F0               M     call get_palent_encpiece_4
                      00527 ;        ws_send_byte WREG, TRUE, YIELD, YIELD_AGAIN;
                      00528 ;       ws_encbyte BYTE, 2/3; after wait to protect WREG, but might cause latency
                      00529         whilebit xmit_ready(FALSE), NULL_STMT; CAUTION: TX1IF !valid until 2 instr after TX1REG; do next byte prep first
0068                      M _1426loop:
0068   014E               M     banksel PIR3
006B                      M     ORG $
0069                      M     ORG ctx_addr_25
                          M     goto_pagesafe _1426before_addr
                          M ;    EXPAND_PUSH FALSE
                          M ; messg here1 @2947
                          M     ERRIF(LITPAGEOF(_1426before_addr), [ERROR] "dest" _1426before_addr 105 !on page 0: 0 @2948)
                          M ; messg here2 @2949
                          M ;PAGESEL_DROP += 1
                          M ;    messg goto dest, page tracker #v(PAGE_TRACKER), need page sel? #v(LITPAGEOF(dest)) != #v(LITPAGEOF(PAGE_TRACKER))? #v(LITPAGEOF(dest) != LITPAGEOF(PAGE_TRACKER))
                          M     if LITPAGEOF(_1426before_addr) != LITPAGEOF(PAGE_TRACKER)
                          M         EMIT CLRF PCLATH; PAGESEL dest; kludge: mpasm doesn't want to pagesel
                          M PAGESEL_KEEP += 1
                          M     else
  00000010                M PAGESEL_DROP += 1
                          M     endif
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M ; messg here3 @2959
                          M     EMIT goto _1426before_addr; PROGDCL 0x2000 | (dest); call dest
006A   2869               M     goto _1426before_addr
  00000069                M PAGE_TRACKER = _1426before_addr;
                          M ; messg here4 @2962
                          M ;    NOEXPAND
                          M ;not needed: fall-thru would be handled by earlier code    DROP_CONTEXT; BSR and WREG unknown here if dest falls through
                          M ;    EXPAND_POP
0069                      M     ORG ctx_addr_27
006B                      M     ORG ctx_addr_28
                      00530         mov8 TX1REG, WREG; start xmit
006B   0142               M     banksel TX1REG
006C   009A               M     movwf TX1REG
  00000005            00531 pxpiece += 1
                      00524 ;        wait2xmit YIELD, YIELD_AGAIN; wait before loading WREG to avoid save/restore
                      00525         mov8 WREG, IIF(pxpiece == 9-1, INDF0_postinc, INDF0);;
                          M     withdest_0 movf (((pxpiece == 9-1) != 0) * ((INDF0_postinc) - (INDF0)) + (INDF0))
006D   0800               M     movf (((pxpiece == 9-1) != 0) * ((INDF0_postinc) - (INDF0)) + (INDF0)), W;
                      00526         CALL get_palent_encpiece_5;
006E   2108               M     call get_palent_encpiece_5
                      00527 ;        ws_send_byte WREG, TRUE, YIELD, YIELD_AGAIN;
                      00528 ;       ws_encbyte BYTE, 2/3; after wait to protect WREG, but might cause latency
                      00529         whilebit xmit_ready(FALSE), NULL_STMT; CAUTION: TX1IF !valid until 2 instr after TX1REG; do next byte prep first
006F                      M _1534loop:
006F   014E               M     banksel PIR3
0072                      M     ORG $
0070                      M     ORG ctx_addr_29
                          M     goto_pagesafe _1534before_addr
                          M ;    EXPAND_PUSH FALSE
                          M ; messg here1 @2947
                          M     ERRIF(LITPAGEOF(_1534before_addr), [ERROR] "dest" _1534before_addr 112 !on page 0: 0 @2948)
                          M ; messg here2 @2949
                          M ;PAGESEL_DROP += 1
                          M ;    messg goto dest, page tracker #v(PAGE_TRACKER), need page sel? #v(LITPAGEOF(dest)) != #v(LITPAGEOF(PAGE_TRACKER))? #v(LITPAGEOF(dest) != LITPAGEOF(PAGE_TRACKER))
                          M     if LITPAGEOF(_1534before_addr) != LITPAGEOF(PAGE_TRACKER)
                          M         EMIT CLRF PCLATH; PAGESEL dest; kludge: mpasm doesn't want to pagesel
                          M PAGESEL_KEEP += 1
                          M     else
  00000012                M PAGESEL_DROP += 1
                          M     endif
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M ; messg here3 @2959
                          M     EMIT goto _1534before_addr; PROGDCL 0x2000 | (dest); call dest
0071   2870               M     goto _1534before_addr
  00000070                M PAGE_TRACKER = _1534before_addr;
                          M ; messg here4 @2962
                          M ;    NOEXPAND
                          M ;not needed: fall-thru would be handled by earlier code    DROP_CONTEXT; BSR and WREG unknown here if dest falls through
                          M ;    EXPAND_POP
0070                      M     ORG ctx_addr_31
0072                      M     ORG ctx_addr_32
                      00530         mov8 TX1REG, WREG; start xmit
0072   0142               M     banksel TX1REG
0073   009A               M     movwf TX1REG
  00000006            00531 pxpiece += 1
                      00524 ;        wait2xmit YIELD, YIELD_AGAIN; wait before loading WREG to avoid save/restore
                      00525         mov8 WREG, IIF(pxpiece == 9-1, INDF0_postinc, INDF0);;
                          M     withdest_0 movf (((pxpiece == 9-1) != 0) * ((INDF0_postinc) - (INDF0)) + (INDF0))
0074   0800               M     movf (((pxpiece == 9-1) != 0) * ((INDF0_postinc) - (INDF0)) + (INDF0)), W;
                      00526         CALL get_palent_encpiece_6;
0075   2122               M     call get_palent_encpiece_6
                      00527 ;        ws_send_byte WREG, TRUE, YIELD, YIELD_AGAIN;
                      00528 ;       ws_encbyte BYTE, 2/3; after wait to protect WREG, but might cause latency
                      00529         whilebit xmit_ready(FALSE), NULL_STMT; CAUTION: TX1IF !valid until 2 instr after TX1REG; do next byte prep first
0076                      M _1642loop:
0076   014E               M     banksel PIR3
0079                      M     ORG $
0077                      M     ORG ctx_addr_33
                          M     goto_pagesafe _1642before_addr
                          M ;    EXPAND_PUSH FALSE
                          M ; messg here1 @2947
                          M     ERRIF(LITPAGEOF(_1642before_addr), [ERROR] "dest" _1642before_addr 119 !on page 0: 0 @2948)
                          M ; messg here2 @2949
                          M ;PAGESEL_DROP += 1
                          M ;    messg goto dest, page tracker #v(PAGE_TRACKER), need page sel? #v(LITPAGEOF(dest)) != #v(LITPAGEOF(PAGE_TRACKER))? #v(LITPAGEOF(dest) != LITPAGEOF(PAGE_TRACKER))
                          M     if LITPAGEOF(_1642before_addr) != LITPAGEOF(PAGE_TRACKER)
                          M         EMIT CLRF PCLATH; PAGESEL dest; kludge: mpasm doesn't want to pagesel
                          M PAGESEL_KEEP += 1
                          M     else
  00000014                M PAGESEL_DROP += 1
                          M     endif
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M ; messg here3 @2959
                          M     EMIT goto _1642before_addr; PROGDCL 0x2000 | (dest); call dest
0078   2877               M     goto _1642before_addr
  00000077                M PAGE_TRACKER = _1642before_addr;
                          M ; messg here4 @2962
                          M ;    NOEXPAND
                          M ;not needed: fall-thru would be handled by earlier code    DROP_CONTEXT; BSR and WREG unknown here if dest falls through
                          M ;    EXPAND_POP
0077                      M     ORG ctx_addr_35
0079                      M     ORG ctx_addr_36
                      00530         mov8 TX1REG, WREG; start xmit
0079   0142               M     banksel TX1REG
007A   009A               M     movwf TX1REG
  00000007            00531 pxpiece += 1
                      00524 ;        wait2xmit YIELD, YIELD_AGAIN; wait before loading WREG to avoid save/restore
                      00525         mov8 WREG, IIF(pxpiece == 9-1, INDF0_postinc, INDF0);;
                          M     withdest_0 movf (((pxpiece == 9-1) != 0) * ((INDF0_postinc) - (INDF0)) + (INDF0))
007B   0800               M     movf (((pxpiece == 9-1) != 0) * ((INDF0_postinc) - (INDF0)) + (INDF0)), W;
                      00526         CALL get_palent_encpiece_7;
007C   213C               M     call get_palent_encpiece_7
                      00527 ;        ws_send_byte WREG, TRUE, YIELD, YIELD_AGAIN;
                      00528 ;       ws_encbyte BYTE, 2/3; after wait to protect WREG, but might cause latency
                      00529         whilebit xmit_ready(FALSE), NULL_STMT; CAUTION: TX1IF !valid until 2 instr after TX1REG; do next byte prep first
007D                      M _1750loop:
007D   014E               M     banksel PIR3
0080                      M     ORG $
007E                      M     ORG ctx_addr_37
                          M     goto_pagesafe _1750before_addr
                          M ;    EXPAND_PUSH FALSE
                          M ; messg here1 @2947
                          M     ERRIF(LITPAGEOF(_1750before_addr), [ERROR] "dest" _1750before_addr 126 !on page 0: 0 @2948)
                          M ; messg here2 @2949
                          M ;PAGESEL_DROP += 1
                          M ;    messg goto dest, page tracker #v(PAGE_TRACKER), need page sel? #v(LITPAGEOF(dest)) != #v(LITPAGEOF(PAGE_TRACKER))? #v(LITPAGEOF(dest) != LITPAGEOF(PAGE_TRACKER))
                          M     if LITPAGEOF(_1750before_addr) != LITPAGEOF(PAGE_TRACKER)
                          M         EMIT CLRF PCLATH; PAGESEL dest; kludge: mpasm doesn't want to pagesel
                          M PAGESEL_KEEP += 1
                          M     else
  00000016                M PAGESEL_DROP += 1
                          M     endif
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M ; messg here3 @2959
                          M     EMIT goto _1750before_addr; PROGDCL 0x2000 | (dest); call dest
007F   287E               M     goto _1750before_addr
  0000007E                M PAGE_TRACKER = _1750before_addr;
                          M ; messg here4 @2962
                          M ;    NOEXPAND
                          M ;not needed: fall-thru would be handled by earlier code    DROP_CONTEXT; BSR and WREG unknown here if dest falls through
                          M ;    EXPAND_POP
007E                      M     ORG ctx_addr_39
0080                      M     ORG ctx_addr_40
                      00530         mov8 TX1REG, WREG; start xmit
0080   0142               M     banksel TX1REG
0081   009A               M     movwf TX1REG
  00000008            00531 pxpiece += 1
                      00524 ;        wait2xmit YIELD, YIELD_AGAIN; wait before loading WREG to avoid save/restore
                      00525         mov8 WREG, IIF(pxpiece == 9-1, INDF0_postinc, INDF0);;
0082   0012               M     MOVIW_0_2
                      00526         CALL get_palent_encpiece_8;
0083   2154               M     call get_palent_encpiece_8
                      00527 ;        ws_send_byte WREG, TRUE, YIELD, YIELD_AGAIN;
                      00528 ;       ws_encbyte BYTE, 2/3; after wait to protect WREG, but might cause latency
                      00529         whilebit xmit_ready(FALSE), NULL_STMT; CAUTION: TX1IF !valid until 2 instr after TX1REG; do next byte prep first
0084                      M _1850loop:
0084   014E               M     banksel PIR3
0087                      M     ORG $
0085                      M     ORG ctx_addr_41
                          M     goto_pagesafe _1850before_addr
                          M ;    EXPAND_PUSH FALSE
                          M ; messg here1 @2947
                          M     ERRIF(LITPAGEOF(_1850before_addr), [ERROR] "dest" _1850before_addr 133 !on page 0: 0 @2948)
                          M ; messg here2 @2949
                          M ;PAGESEL_DROP += 1
                          M ;    messg goto dest, page tracker #v(PAGE_TRACKER), need page sel? #v(LITPAGEOF(dest)) != #v(LITPAGEOF(PAGE_TRACKER))? #v(LITPAGEOF(dest) != LITPAGEOF(PAGE_TRACKER))
                          M     if LITPAGEOF(_1850before_addr) != LITPAGEOF(PAGE_TRACKER)
                          M         EMIT CLRF PCLATH; PAGESEL dest; kludge: mpasm doesn't want to pagesel
                          M PAGESEL_KEEP += 1
                          M     else
  00000018                M PAGESEL_DROP += 1
                          M     endif
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M ; messg here3 @2959
                          M     EMIT goto _1850before_addr; PROGDCL 0x2000 | (dest); call dest
0086   2885               M     goto _1850before_addr
  00000085                M PAGE_TRACKER = _1850before_addr;
                          M ; messg here4 @2962
                          M ;    NOEXPAND
                          M ;not needed: fall-thru would be handled by earlier code    DROP_CONTEXT; BSR and WREG unknown here if dest falls through
                          M ;    EXPAND_POP
0085                      M     ORG ctx_addr_43
0087                      M     ORG ctx_addr_44
                      00530         mov8 TX1REG, WREG; start xmit
0087   0142               M     banksel TX1REG
0088   009A               M     movwf TX1REG
  00000009            00531 pxpiece += 1
                      00532     endw
                      00533     GOTO brkout_loop;
0089   2847               M     goto brkout_loop
                      00534 
                      00535 
                      00536 generate_get_palent macro
                      00537 ;    EXPAND_PUSH FALSE
                      00538     VARIABLE palpiece = 0, palent = 0, pal_byte;
                      00539     while palpiece < 3 * 3
                      00540 ;       EXPAND_PUSH TRUE
                      00541 ;pal byte HI first/second/third piece, byte MID first/second/third piece, byte LO first/second/third piece:
                      00542         EMITL get_palent_encpiece_#v(palpiece): DROP_CONTEXT;
                      00543 ;       addlw 7; kludge: move rgbinx 8 to last position in lookup table; this allows run-time code to take > 1 instr without additional jump
                      00544         EMIT andlw 0x0F;
                      00545         EMIT brw;
                      00546 ;       EXPAND_POP
                      00547         while palent < 16 * (palpiece + 1)
                      00548             if (palent % 16) != CUSTOM_RGBINX; const palette entries can be encoded at compile time
                      00549 ;line too long :(               retlw SPI3x_#v(palpiece % 3)(BYTEOF(PALETTE_#v(palent % 16), palpiece / 3));
                      00550 ;               EXPAND_PUSH TRUE
                      00551 pal_byte = BYTEOF(PALETTE_#v(palent % 16), RGB_ORDER(palpiece / 3));
                      00552                 EMIT retlw SPI3x_#v(palpiece % 3)(pal_byte); #v(pal_byte)
                      00553 ;               EXPAND_POP
                      00554             else
                      00555                 EMIT bra custom_palent_encpiece_#v(palpiece)
                      00556             endif
                      00557 palent += 1
                      00558         endw
                      00559 ;       EXPAND_PUSH TRUE
                      00560         EMITL custom_palent_encpiece_#v(palpiece): DROP_CONTEXT;
                      00561 ;line too long :(       ws_encbyte BYTEOF(PALETTE_#v(15), palpiece / 3), ((palpiece % 3) + 1) / 3; custom palette entry requires run-time computation
                      00562 pal_byte = BYTEOF(PALETTE_#v(CUSTOM_RGBINX), RGB_ORDER(palpiece / 3));
                      00563         ws_encbyte pal_byte, ((palpiece % 3) + 1) / 3; custom palette entry requires run-time computation
                      00564         EMIT return;
                      00565 ;       EXPAND_POP
                      00566 palpiece += 1
                      00567     endw
                      00568 ;    EXPAND_POP
                      00569     endm
                      00570     generate_get_palent; kludge: need macro wrapper for expand push/pop
                          M get_palent_encpiece_0: DROP_CONTEXT
                          M     DROP_BANK
                          M ;    EXPAND_PUSH FALSE
  FFFFFFFF                M BANK_TRACKER = BANK_UNKN  ;forget where latest value came from (used for jump targets)
                          M ;    EXPAND_POP
                          M     DROP_WREG
                          M ;    EXPAND_PUSH FALSE
  40000000                M WREG_TRACKER = WREG_UNKN  ;forget latest value
                          M ;    EXPAND_POP
008A   390F               M     andlw 0x0F
008B   000B               M     brw
008C   3449               M     retlw BRKOUT_BYTE_146
008D   3449               M     retlw BRKOUT_BYTE_146
008E   3449               M     retlw BRKOUT_BYTE_146
008F   3449               M     retlw BRKOUT_BYTE_146
0090   3449               M     retlw BRKOUT_BYTE_146
0091   3449               M     retlw BRKOUT_BYTE_146
0092   3449               M     retlw BRKOUT_BYTE_146
0093   3449               M     retlw BRKOUT_BYTE_146
0094   3207               M     bra custom_palent_encpiece_0
0095   3449               M     retlw BRKOUT_BYTE_146
0096   34DB               M     retlw BRKOUT_BYTE_219
0097   344B               M     retlw BRKOUT_BYTE_210
0098   3449               M     retlw BRKOUT_BYTE_146
0099   3449               M     retlw BRKOUT_BYTE_146
009A   344B               M     retlw BRKOUT_BYTE_210
009B   3459               M     retlw BRKOUT_BYTE_154
                          M custom_palent_encpiece_0: DROP_CONTEXT
                          M     DROP_BANK
                          M ;    EXPAND_PUSH FALSE
  FFFFFFFF                M BANK_TRACKER = BANK_UNKN  ;forget where latest value came from (used for jump targets)
                          M ;    EXPAND_POP
                          M     DROP_WREG
                          M ;    EXPAND_PUSH FALSE
  40000000                M WREG_TRACKER = WREG_UNKN  ;forget latest value
                          M ;    EXPAND_POP
009C   3049               M     movlw BRKOUT_BYTE_146
                          M     iorlw_tracker BRKOUT_BYTE_64
                          M ;    EXPAND_PUSH FALSE
                          M ;    andlw arg
                          M     ERRIF((BRKOUT_BYTE_64) & ~0xFF, [ERROR] extra IOR bits ignored: 0          @2336)
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M     EMIT iorlw BRKOUT_BYTE_64; PROGDCL 0x3800 | value
009E   3802               M     iorlw BRKOUT_BYTE_64
                          M ;    NOEXPAND; reduce clutter
                          M ;don't do this: (doesn't handle STATUS)
                          M     if WREG_TRACKER != WREG_UNKN
  8000004B                M WREG_TRACKER = IIF(ISLIT(WREG_TRACKER), LITERAL(WREG_TRACKER | (BRKOUT_BYTE_64)), WREG_UNKN)
                          M     endif
                          M ;    DROP_WREG
                          M ;    EXPAND_POP
009D                      M     ORG ctx_addr_45
009F                      M     ORG ctx_addr_46
                          M     iorlw_tracker BRKOUT_BYTE_8
                          M ;    EXPAND_PUSH FALSE
                          M ;    andlw arg
                          M     ERRIF((BRKOUT_BYTE_8) & ~0xFF, [ERROR] extra IOR bits ignored: 0           @2336)
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M     EMIT iorlw BRKOUT_BYTE_8; PROGDCL 0x3800 | value
00A0   3810               M     iorlw BRKOUT_BYTE_8
                          M ;    NOEXPAND; reduce clutter
                          M ;don't do this: (doesn't handle STATUS)
                          M     if WREG_TRACKER != WREG_UNKN
  8000005B                M WREG_TRACKER = IIF(ISLIT(WREG_TRACKER), LITERAL(WREG_TRACKER | (BRKOUT_BYTE_8)), WREG_UNKN)
                          M     endif
                          M ;    DROP_WREG
                          M ;    EXPAND_POP
009F                      M     ORG ctx_addr_47
00A1                      M     ORG ctx_addr_48
                          M     iorlw_tracker BRKOUT_BYTE_1
                          M ;    EXPAND_PUSH FALSE
                          M ;    andlw arg
                          M     ERRIF((BRKOUT_BYTE_1) & ~0xFF, [ERROR] extra IOR bits ignored: 0           @2336)
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M     EMIT iorlw BRKOUT_BYTE_1; PROGDCL 0x3800 | value
00A2   3880               M     iorlw BRKOUT_BYTE_1
                          M ;    NOEXPAND; reduce clutter
                          M ;don't do this: (doesn't handle STATUS)
                          M     if WREG_TRACKER != WREG_UNKN
  800000DB                M WREG_TRACKER = IIF(ISLIT(WREG_TRACKER), LITERAL(WREG_TRACKER | (BRKOUT_BYTE_1)), WREG_UNKN)
                          M     endif
                          M ;    DROP_WREG
                          M ;    EXPAND_POP
00A1                      M     ORG ctx_addr_49
00A3                      M     ORG ctx_addr_50
00A3   0008               M     return
                          M get_palent_encpiece_1: DROP_CONTEXT
                          M     DROP_BANK
                          M ;    EXPAND_PUSH FALSE
  FFFFFFFF                M BANK_TRACKER = BANK_UNKN  ;forget where latest value came from (used for jump targets)
                          M ;    EXPAND_POP
                          M     DROP_WREG
                          M ;    EXPAND_PUSH FALSE
  40000000                M WREG_TRACKER = WREG_UNKN  ;forget latest value
                          M ;    EXPAND_POP
00A4   390F               M     andlw 0x0F
00A5   000B               M     brw
00A6   3492               M     retlw BRKOUT_BYTE_73
00A7   3492               M     retlw BRKOUT_BYTE_73
00A8   3492               M     retlw BRKOUT_BYTE_73
00A9   3492               M     retlw BRKOUT_BYTE_73
00AA   3492               M     retlw BRKOUT_BYTE_73
00AB   3492               M     retlw BRKOUT_BYTE_73
00AC   3492               M     retlw BRKOUT_BYTE_73
00AD   3492               M     retlw BRKOUT_BYTE_73
00AE   3207               M     bra custom_palent_encpiece_1
00AF   3492               M     retlw BRKOUT_BYTE_73
00B0   34B6               M     retlw BRKOUT_BYTE_109
00B1   3492               M     retlw BRKOUT_BYTE_73
00B2   3492               M     retlw BRKOUT_BYTE_73
00B3   3492               M     retlw BRKOUT_BYTE_73
00B4   3492               M     retlw BRKOUT_BYTE_73
00B5   3496               M     retlw BRKOUT_BYTE_105
                          M custom_palent_encpiece_1: DROP_CONTEXT
                          M     DROP_BANK
                          M ;    EXPAND_PUSH FALSE
  FFFFFFFF                M BANK_TRACKER = BANK_UNKN  ;forget where latest value came from (used for jump targets)
                          M ;    EXPAND_POP
                          M     DROP_WREG
                          M ;    EXPAND_PUSH FALSE
  40000000                M WREG_TRACKER = WREG_UNKN  ;forget latest value
                          M ;    EXPAND_POP
00B6   3092               M     movlw BRKOUT_BYTE_73
                          M     iorlw_tracker BRKOUT_BYTE_32
                          M ;    EXPAND_PUSH FALSE
                          M ;    andlw arg
                          M     ERRIF((BRKOUT_BYTE_32) & ~0xFF, [ERROR] extra IOR bits ignored: 0          @2336)
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M     EMIT iorlw BRKOUT_BYTE_32; PROGDCL 0x3800 | value
00B8   3804               M     iorlw BRKOUT_BYTE_32
                          M ;    NOEXPAND; reduce clutter
                          M ;don't do this: (doesn't handle STATUS)
                          M     if WREG_TRACKER != WREG_UNKN
  80000096                M WREG_TRACKER = IIF(ISLIT(WREG_TRACKER), LITERAL(WREG_TRACKER | (BRKOUT_BYTE_32)), WREG_UNKN)
                          M     endif
                          M ;    DROP_WREG
                          M ;    EXPAND_POP
00B7                      M     ORG ctx_addr_51
00B9                      M     ORG ctx_addr_52
                          M     iorlw_tracker BRKOUT_BYTE_4
                          M ;    EXPAND_PUSH FALSE
                          M ;    andlw arg
                          M     ERRIF((BRKOUT_BYTE_4) & ~0xFF, [ERROR] extra IOR bits ignored: 0           @2336)
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M     EMIT iorlw BRKOUT_BYTE_4; PROGDCL 0x3800 | value
00BA   3820               M     iorlw BRKOUT_BYTE_4
                          M ;    NOEXPAND; reduce clutter
                          M ;don't do this: (doesn't handle STATUS)
                          M     if WREG_TRACKER != WREG_UNKN
  800000B6                M WREG_TRACKER = IIF(ISLIT(WREG_TRACKER), LITERAL(WREG_TRACKER | (BRKOUT_BYTE_4)), WREG_UNKN)
                          M     endif
                          M ;    DROP_WREG
                          M ;    EXPAND_POP
00B9                      M     ORG ctx_addr_53
00BB                      M     ORG ctx_addr_54
00BB   0008               M     return
                          M get_palent_encpiece_2: DROP_CONTEXT
                          M     DROP_BANK
                          M ;    EXPAND_PUSH FALSE
  FFFFFFFF                M BANK_TRACKER = BANK_UNKN  ;forget where latest value came from (used for jump targets)
                          M ;    EXPAND_POP
                          M     DROP_WREG
                          M ;    EXPAND_PUSH FALSE
  40000000                M WREG_TRACKER = WREG_UNKN  ;forget latest value
                          M ;    EXPAND_POP
00BC   390F               M     andlw 0x0F
00BD   000B               M     brw
00BE   3424               M     retlw BRKOUT_BYTE_36
00BF   3424               M     retlw BRKOUT_BYTE_36
00C0   342C               M     retlw BRKOUT_BYTE_52
00C1   3464               M     retlw BRKOUT_BYTE_38
00C2   3424               M     retlw BRKOUT_BYTE_36
00C3   3424               M     retlw BRKOUT_BYTE_36
00C4   3464               M     retlw BRKOUT_BYTE_38
00C5   3464               M     retlw BRKOUT_BYTE_38
00C6   3207               M     bra custom_palent_encpiece_2
00C7   3424               M     retlw BRKOUT_BYTE_36
00C8   346D               M     retlw BRKOUT_BYTE_182
00C9   3424               M     retlw BRKOUT_BYTE_36
00CA   3424               M     retlw BRKOUT_BYTE_36
00CB   3424               M     retlw BRKOUT_BYTE_36
00CC   3424               M     retlw BRKOUT_BYTE_36
00CD   3465               M     retlw BRKOUT_BYTE_166
                          M custom_palent_encpiece_2: DROP_CONTEXT
                          M     DROP_BANK
                          M ;    EXPAND_PUSH FALSE
  FFFFFFFF                M BANK_TRACKER = BANK_UNKN  ;forget where latest value came from (used for jump targets)
                          M ;    EXPAND_POP
                          M     DROP_WREG
                          M ;    EXPAND_PUSH FALSE
  40000000                M WREG_TRACKER = WREG_UNKN  ;forget latest value
                          M ;    EXPAND_POP
00CE   3024               M     movlw BRKOUT_BYTE_36
                          M     iorlw_tracker BRKOUT_BYTE_128
                          M ;    EXPAND_PUSH FALSE
                          M ;    andlw arg
                          M     ERRIF((BRKOUT_BYTE_128) & ~0xFF, [ERROR] extra IOR bits ignored: 0         @2336)
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M     EMIT iorlw BRKOUT_BYTE_128; PROGDCL 0x3800 | value
00D0   3801               M     iorlw BRKOUT_BYTE_128
                          M ;    NOEXPAND; reduce clutter
                          M ;don't do this: (doesn't handle STATUS)
                          M     if WREG_TRACKER != WREG_UNKN
  80000025                M WREG_TRACKER = IIF(ISLIT(WREG_TRACKER), LITERAL(WREG_TRACKER | (BRKOUT_BYTE_128)), WREG_UNKN)
                          M     endif
                          M ;    DROP_WREG
                          M ;    EXPAND_POP
00CF                      M     ORG ctx_addr_55
00D1                      M     ORG ctx_addr_56
                          M     iorlw_tracker BRKOUT_BYTE_16
                          M ;    EXPAND_PUSH FALSE
                          M ;    andlw arg
                          M     ERRIF((BRKOUT_BYTE_16) & ~0xFF, [ERROR] extra IOR bits ignored: 0          @2336)
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M     EMIT iorlw BRKOUT_BYTE_16; PROGDCL 0x3800 | value
00D2   3808               M     iorlw BRKOUT_BYTE_16
                          M ;    NOEXPAND; reduce clutter
                          M ;don't do this: (doesn't handle STATUS)
                          M     if WREG_TRACKER != WREG_UNKN
  8000002D                M WREG_TRACKER = IIF(ISLIT(WREG_TRACKER), LITERAL(WREG_TRACKER | (BRKOUT_BYTE_16)), WREG_UNKN)
                          M     endif
                          M ;    DROP_WREG
                          M ;    EXPAND_POP
00D1                      M     ORG ctx_addr_57
00D3                      M     ORG ctx_addr_58
                          M     iorlw_tracker BRKOUT_BYTE_2
                          M ;    EXPAND_PUSH FALSE
                          M ;    andlw arg
                          M     ERRIF((BRKOUT_BYTE_2) & ~0xFF, [ERROR] extra IOR bits ignored: 0           @2336)
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M     EMIT iorlw BRKOUT_BYTE_2; PROGDCL 0x3800 | value
00D4   3840               M     iorlw BRKOUT_BYTE_2
                          M ;    NOEXPAND; reduce clutter
                          M ;don't do this: (doesn't handle STATUS)
                          M     if WREG_TRACKER != WREG_UNKN
  8000006D                M WREG_TRACKER = IIF(ISLIT(WREG_TRACKER), LITERAL(WREG_TRACKER | (BRKOUT_BYTE_2)), WREG_UNKN)
                          M     endif
                          M ;    DROP_WREG
                          M ;    EXPAND_POP
00D3                      M     ORG ctx_addr_59
00D5                      M     ORG ctx_addr_60
00D5   0008               M     return
                          M get_palent_encpiece_3: DROP_CONTEXT
                          M     DROP_BANK
                          M ;    EXPAND_PUSH FALSE
  FFFFFFFF                M BANK_TRACKER = BANK_UNKN  ;forget where latest value came from (used for jump targets)
                          M ;    EXPAND_POP
                          M     DROP_WREG
                          M ;    EXPAND_PUSH FALSE
  40000000                M WREG_TRACKER = WREG_UNKN  ;forget latest value
                          M ;    EXPAND_POP
00D6   390F               M     andlw 0x0F
00D7   000B               M     brw
00D8   3449               M     retlw BRKOUT_BYTE_146
00D9   3449               M     retlw BRKOUT_BYTE_146
00DA   3449               M     retlw BRKOUT_BYTE_146
00DB   3449               M     retlw BRKOUT_BYTE_146
00DC   3449               M     retlw BRKOUT_BYTE_146
00DD   3449               M     retlw BRKOUT_BYTE_146
00DE   3449               M     retlw BRKOUT_BYTE_146
00DF   3449               M     retlw BRKOUT_BYTE_146
00E0   3207               M     bra custom_palent_encpiece_3
00E1   3449               M     retlw BRKOUT_BYTE_146
00E2   3449               M     retlw BRKOUT_BYTE_146
00E3   3449               M     retlw BRKOUT_BYTE_146
00E4   34DB               M     retlw BRKOUT_BYTE_219
00E5   344B               M     retlw BRKOUT_BYTE_210
00E6   344B               M     retlw BRKOUT_BYTE_210
00E7   3459               M     retlw BRKOUT_BYTE_154
                          M custom_palent_encpiece_3: DROP_CONTEXT
                          M     DROP_BANK
                          M ;    EXPAND_PUSH FALSE
  FFFFFFFF                M BANK_TRACKER = BANK_UNKN  ;forget where latest value came from (used for jump targets)
                          M ;    EXPAND_POP
                          M     DROP_WREG
                          M ;    EXPAND_PUSH FALSE
  40000000                M WREG_TRACKER = WREG_UNKN  ;forget latest value
                          M ;    EXPAND_POP
00E8   3049               M     movlw BRKOUT_BYTE_146
                          M     iorlw_tracker BRKOUT_BYTE_64
                          M ;    EXPAND_PUSH FALSE
                          M ;    andlw arg
                          M     ERRIF((BRKOUT_BYTE_64) & ~0xFF, [ERROR] extra IOR bits ignored: 0          @2336)
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M     EMIT iorlw BRKOUT_BYTE_64; PROGDCL 0x3800 | value
00EA   3802               M     iorlw BRKOUT_BYTE_64
                          M ;    NOEXPAND; reduce clutter
                          M ;don't do this: (doesn't handle STATUS)
                          M     if WREG_TRACKER != WREG_UNKN
  8000004B                M WREG_TRACKER = IIF(ISLIT(WREG_TRACKER), LITERAL(WREG_TRACKER | (BRKOUT_BYTE_64)), WREG_UNKN)
                          M     endif
                          M ;    DROP_WREG
                          M ;    EXPAND_POP
00E9                      M     ORG ctx_addr_61
00EB                      M     ORG ctx_addr_62
                          M     iorlw_tracker BRKOUT_BYTE_8
                          M ;    EXPAND_PUSH FALSE
                          M ;    andlw arg
                          M     ERRIF((BRKOUT_BYTE_8) & ~0xFF, [ERROR] extra IOR bits ignored: 0           @2336)
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M     EMIT iorlw BRKOUT_BYTE_8; PROGDCL 0x3800 | value
00EC   3810               M     iorlw BRKOUT_BYTE_8
                          M ;    NOEXPAND; reduce clutter
                          M ;don't do this: (doesn't handle STATUS)
                          M     if WREG_TRACKER != WREG_UNKN
  8000005B                M WREG_TRACKER = IIF(ISLIT(WREG_TRACKER), LITERAL(WREG_TRACKER | (BRKOUT_BYTE_8)), WREG_UNKN)
                          M     endif
                          M ;    DROP_WREG
                          M ;    EXPAND_POP
00EB                      M     ORG ctx_addr_63
00ED                      M     ORG ctx_addr_64
                          M     iorlw_tracker BRKOUT_BYTE_1
                          M ;    EXPAND_PUSH FALSE
                          M ;    andlw arg
                          M     ERRIF((BRKOUT_BYTE_1) & ~0xFF, [ERROR] extra IOR bits ignored: 0           @2336)
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M     EMIT iorlw BRKOUT_BYTE_1; PROGDCL 0x3800 | value
00EE   3880               M     iorlw BRKOUT_BYTE_1
                          M ;    NOEXPAND; reduce clutter
                          M ;don't do this: (doesn't handle STATUS)
                          M     if WREG_TRACKER != WREG_UNKN
  800000DB                M WREG_TRACKER = IIF(ISLIT(WREG_TRACKER), LITERAL(WREG_TRACKER | (BRKOUT_BYTE_1)), WREG_UNKN)
                          M     endif
                          M ;    DROP_WREG
                          M ;    EXPAND_POP
00ED                      M     ORG ctx_addr_65
00EF                      M     ORG ctx_addr_66
00EF   0008               M     return
                          M get_palent_encpiece_4: DROP_CONTEXT
                          M     DROP_BANK
                          M ;    EXPAND_PUSH FALSE
  FFFFFFFF                M BANK_TRACKER = BANK_UNKN  ;forget where latest value came from (used for jump targets)
                          M ;    EXPAND_POP
                          M     DROP_WREG
                          M ;    EXPAND_PUSH FALSE
  40000000                M WREG_TRACKER = WREG_UNKN  ;forget latest value
                          M ;    EXPAND_POP
00F0   390F               M     andlw 0x0F
00F1   000B               M     brw
00F2   3492               M     retlw BRKOUT_BYTE_73
00F3   3492               M     retlw BRKOUT_BYTE_73
00F4   3492               M     retlw BRKOUT_BYTE_73
00F5   3492               M     retlw BRKOUT_BYTE_73
00F6   3492               M     retlw BRKOUT_BYTE_73
00F7   3492               M     retlw BRKOUT_BYTE_73
00F8   3492               M     retlw BRKOUT_BYTE_73
00F9   3492               M     retlw BRKOUT_BYTE_73
00FA   3207               M     bra custom_palent_encpiece_4
00FB   3492               M     retlw BRKOUT_BYTE_73
00FC   3492               M     retlw BRKOUT_BYTE_73
00FD   3492               M     retlw BRKOUT_BYTE_73
00FE   34B6               M     retlw BRKOUT_BYTE_109
00FF   3492               M     retlw BRKOUT_BYTE_73
0100   3492               M     retlw BRKOUT_BYTE_73
0101   3496               M     retlw BRKOUT_BYTE_105
                          M custom_palent_encpiece_4: DROP_CONTEXT
                          M     DROP_BANK
                          M ;    EXPAND_PUSH FALSE
  FFFFFFFF                M BANK_TRACKER = BANK_UNKN  ;forget where latest value came from (used for jump targets)
                          M ;    EXPAND_POP
                          M     DROP_WREG
                          M ;    EXPAND_PUSH FALSE
  40000000                M WREG_TRACKER = WREG_UNKN  ;forget latest value
                          M ;    EXPAND_POP
0102   3092               M     movlw BRKOUT_BYTE_73
                          M     iorlw_tracker BRKOUT_BYTE_32
                          M ;    EXPAND_PUSH FALSE
                          M ;    andlw arg
                          M     ERRIF((BRKOUT_BYTE_32) & ~0xFF, [ERROR] extra IOR bits ignored: 0          @2336)
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M     EMIT iorlw BRKOUT_BYTE_32; PROGDCL 0x3800 | value
0104   3804               M     iorlw BRKOUT_BYTE_32
                          M ;    NOEXPAND; reduce clutter
                          M ;don't do this: (doesn't handle STATUS)
                          M     if WREG_TRACKER != WREG_UNKN
  80000096                M WREG_TRACKER = IIF(ISLIT(WREG_TRACKER), LITERAL(WREG_TRACKER | (BRKOUT_BYTE_32)), WREG_UNKN)
                          M     endif
                          M ;    DROP_WREG
                          M ;    EXPAND_POP
0103                      M     ORG ctx_addr_67
0105                      M     ORG ctx_addr_68
                          M     iorlw_tracker BRKOUT_BYTE_4
                          M ;    EXPAND_PUSH FALSE
                          M ;    andlw arg
                          M     ERRIF((BRKOUT_BYTE_4) & ~0xFF, [ERROR] extra IOR bits ignored: 0           @2336)
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M     EMIT iorlw BRKOUT_BYTE_4; PROGDCL 0x3800 | value
0106   3820               M     iorlw BRKOUT_BYTE_4
                          M ;    NOEXPAND; reduce clutter
                          M ;don't do this: (doesn't handle STATUS)
                          M     if WREG_TRACKER != WREG_UNKN
  800000B6                M WREG_TRACKER = IIF(ISLIT(WREG_TRACKER), LITERAL(WREG_TRACKER | (BRKOUT_BYTE_4)), WREG_UNKN)
                          M     endif
                          M ;    DROP_WREG
                          M ;    EXPAND_POP
0105                      M     ORG ctx_addr_69
0107                      M     ORG ctx_addr_70
0107   0008               M     return
                          M get_palent_encpiece_5: DROP_CONTEXT
                          M     DROP_BANK
                          M ;    EXPAND_PUSH FALSE
  FFFFFFFF                M BANK_TRACKER = BANK_UNKN  ;forget where latest value came from (used for jump targets)
                          M ;    EXPAND_POP
                          M     DROP_WREG
                          M ;    EXPAND_PUSH FALSE
  40000000                M WREG_TRACKER = WREG_UNKN  ;forget latest value
                          M ;    EXPAND_POP
0108   390F               M     andlw 0x0F
0109   000B               M     brw
010A   3424               M     retlw BRKOUT_BYTE_36
010B   3424               M     retlw BRKOUT_BYTE_36
010C   3424               M     retlw BRKOUT_BYTE_36
010D   3424               M     retlw BRKOUT_BYTE_36
010E   342C               M     retlw BRKOUT_BYTE_52
010F   3464               M     retlw BRKOUT_BYTE_38
0110   3464               M     retlw BRKOUT_BYTE_38
0111   3464               M     retlw BRKOUT_BYTE_38
0112   3207               M     bra custom_palent_encpiece_5
0113   3424               M     retlw BRKOUT_BYTE_36
0114   3424               M     retlw BRKOUT_BYTE_36
0115   3424               M     retlw BRKOUT_BYTE_36
0116   346D               M     retlw BRKOUT_BYTE_182
0117   3424               M     retlw BRKOUT_BYTE_36
0118   3424               M     retlw BRKOUT_BYTE_36
0119   3465               M     retlw BRKOUT_BYTE_166
                          M custom_palent_encpiece_5: DROP_CONTEXT
                          M     DROP_BANK
                          M ;    EXPAND_PUSH FALSE
  FFFFFFFF                M BANK_TRACKER = BANK_UNKN  ;forget where latest value came from (used for jump targets)
                          M ;    EXPAND_POP
                          M     DROP_WREG
                          M ;    EXPAND_PUSH FALSE
  40000000                M WREG_TRACKER = WREG_UNKN  ;forget latest value
                          M ;    EXPAND_POP
011A   3024               M     movlw BRKOUT_BYTE_36
                          M     iorlw_tracker BRKOUT_BYTE_128
                          M ;    EXPAND_PUSH FALSE
                          M ;    andlw arg
                          M     ERRIF((BRKOUT_BYTE_128) & ~0xFF, [ERROR] extra IOR bits ignored: 0         @2336)
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M     EMIT iorlw BRKOUT_BYTE_128; PROGDCL 0x3800 | value
011C   3801               M     iorlw BRKOUT_BYTE_128
                          M ;    NOEXPAND; reduce clutter
                          M ;don't do this: (doesn't handle STATUS)
                          M     if WREG_TRACKER != WREG_UNKN
  80000025                M WREG_TRACKER = IIF(ISLIT(WREG_TRACKER), LITERAL(WREG_TRACKER | (BRKOUT_BYTE_128)), WREG_UNKN)
                          M     endif
                          M ;    DROP_WREG
                          M ;    EXPAND_POP
011B                      M     ORG ctx_addr_71
011D                      M     ORG ctx_addr_72
                          M     iorlw_tracker BRKOUT_BYTE_16
                          M ;    EXPAND_PUSH FALSE
                          M ;    andlw arg
                          M     ERRIF((BRKOUT_BYTE_16) & ~0xFF, [ERROR] extra IOR bits ignored: 0          @2336)
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M     EMIT iorlw BRKOUT_BYTE_16; PROGDCL 0x3800 | value
011E   3808               M     iorlw BRKOUT_BYTE_16
                          M ;    NOEXPAND; reduce clutter
                          M ;don't do this: (doesn't handle STATUS)
                          M     if WREG_TRACKER != WREG_UNKN
  8000002D                M WREG_TRACKER = IIF(ISLIT(WREG_TRACKER), LITERAL(WREG_TRACKER | (BRKOUT_BYTE_16)), WREG_UNKN)
                          M     endif
                          M ;    DROP_WREG
                          M ;    EXPAND_POP
011D                      M     ORG ctx_addr_73
011F                      M     ORG ctx_addr_74
                          M     iorlw_tracker BRKOUT_BYTE_2
                          M ;    EXPAND_PUSH FALSE
                          M ;    andlw arg
                          M     ERRIF((BRKOUT_BYTE_2) & ~0xFF, [ERROR] extra IOR bits ignored: 0           @2336)
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M     EMIT iorlw BRKOUT_BYTE_2; PROGDCL 0x3800 | value
0120   3840               M     iorlw BRKOUT_BYTE_2
                          M ;    NOEXPAND; reduce clutter
                          M ;don't do this: (doesn't handle STATUS)
                          M     if WREG_TRACKER != WREG_UNKN
  8000006D                M WREG_TRACKER = IIF(ISLIT(WREG_TRACKER), LITERAL(WREG_TRACKER | (BRKOUT_BYTE_2)), WREG_UNKN)
                          M     endif
                          M ;    DROP_WREG
                          M ;    EXPAND_POP
011F                      M     ORG ctx_addr_75
0121                      M     ORG ctx_addr_76
0121   0008               M     return
                          M get_palent_encpiece_6: DROP_CONTEXT
                          M     DROP_BANK
                          M ;    EXPAND_PUSH FALSE
  FFFFFFFF                M BANK_TRACKER = BANK_UNKN  ;forget where latest value came from (used for jump targets)
                          M ;    EXPAND_POP
                          M     DROP_WREG
                          M ;    EXPAND_PUSH FALSE
  40000000                M WREG_TRACKER = WREG_UNKN  ;forget latest value
                          M ;    EXPAND_POP
0122   390F               M     andlw 0x0F
0123   000B               M     brw
0124   3449               M     retlw BRKOUT_BYTE_146
0125   3449               M     retlw BRKOUT_BYTE_146
0126   3449               M     retlw BRKOUT_BYTE_146
0127   3449               M     retlw BRKOUT_BYTE_146
0128   3449               M     retlw BRKOUT_BYTE_146
0129   3449               M     retlw BRKOUT_BYTE_146
012A   3449               M     retlw BRKOUT_BYTE_146
012B   3449               M     retlw BRKOUT_BYTE_146
012C   3207               M     bra custom_palent_encpiece_6
012D   34DB               M     retlw BRKOUT_BYTE_219
012E   3449               M     retlw BRKOUT_BYTE_146
012F   344B               M     retlw BRKOUT_BYTE_210
0130   3449               M     retlw BRKOUT_BYTE_146
0131   344B               M     retlw BRKOUT_BYTE_210
0132   3449               M     retlw BRKOUT_BYTE_146
0133   3459               M     retlw BRKOUT_BYTE_154
                          M custom_palent_encpiece_6: DROP_CONTEXT
                          M     DROP_BANK
                          M ;    EXPAND_PUSH FALSE
  FFFFFFFF                M BANK_TRACKER = BANK_UNKN  ;forget where latest value came from (used for jump targets)
                          M ;    EXPAND_POP
                          M     DROP_WREG
                          M ;    EXPAND_PUSH FALSE
  40000000                M WREG_TRACKER = WREG_UNKN  ;forget latest value
                          M ;    EXPAND_POP
0134   3049               M     movlw BRKOUT_BYTE_146
                          M     iorlw_tracker BRKOUT_BYTE_64
                          M ;    EXPAND_PUSH FALSE
                          M ;    andlw arg
                          M     ERRIF((BRKOUT_BYTE_64) & ~0xFF, [ERROR] extra IOR bits ignored: 0          @2336)
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M     EMIT iorlw BRKOUT_BYTE_64; PROGDCL 0x3800 | value
0136   3802               M     iorlw BRKOUT_BYTE_64
                          M ;    NOEXPAND; reduce clutter
                          M ;don't do this: (doesn't handle STATUS)
                          M     if WREG_TRACKER != WREG_UNKN
  8000004B                M WREG_TRACKER = IIF(ISLIT(WREG_TRACKER), LITERAL(WREG_TRACKER | (BRKOUT_BYTE_64)), WREG_UNKN)
                          M     endif
                          M ;    DROP_WREG
                          M ;    EXPAND_POP
0135                      M     ORG ctx_addr_77
0137                      M     ORG ctx_addr_78
                          M     iorlw_tracker BRKOUT_BYTE_8
                          M ;    EXPAND_PUSH FALSE
                          M ;    andlw arg
                          M     ERRIF((BRKOUT_BYTE_8) & ~0xFF, [ERROR] extra IOR bits ignored: 0           @2336)
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M     EMIT iorlw BRKOUT_BYTE_8; PROGDCL 0x3800 | value
0138   3810               M     iorlw BRKOUT_BYTE_8
                          M ;    NOEXPAND; reduce clutter
                          M ;don't do this: (doesn't handle STATUS)
                          M     if WREG_TRACKER != WREG_UNKN
  8000005B                M WREG_TRACKER = IIF(ISLIT(WREG_TRACKER), LITERAL(WREG_TRACKER | (BRKOUT_BYTE_8)), WREG_UNKN)
                          M     endif
                          M ;    DROP_WREG
                          M ;    EXPAND_POP
0137                      M     ORG ctx_addr_79
0139                      M     ORG ctx_addr_80
                          M     iorlw_tracker BRKOUT_BYTE_1
                          M ;    EXPAND_PUSH FALSE
                          M ;    andlw arg
                          M     ERRIF((BRKOUT_BYTE_1) & ~0xFF, [ERROR] extra IOR bits ignored: 0           @2336)
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M     EMIT iorlw BRKOUT_BYTE_1; PROGDCL 0x3800 | value
013A   3880               M     iorlw BRKOUT_BYTE_1
                          M ;    NOEXPAND; reduce clutter
                          M ;don't do this: (doesn't handle STATUS)
                          M     if WREG_TRACKER != WREG_UNKN
  800000DB                M WREG_TRACKER = IIF(ISLIT(WREG_TRACKER), LITERAL(WREG_TRACKER | (BRKOUT_BYTE_1)), WREG_UNKN)
                          M     endif
                          M ;    DROP_WREG
                          M ;    EXPAND_POP
0139                      M     ORG ctx_addr_81
013B                      M     ORG ctx_addr_82
013B   0008               M     return
                          M get_palent_encpiece_7: DROP_CONTEXT
                          M     DROP_BANK
                          M ;    EXPAND_PUSH FALSE
  FFFFFFFF                M BANK_TRACKER = BANK_UNKN  ;forget where latest value came from (used for jump targets)
                          M ;    EXPAND_POP
                          M     DROP_WREG
                          M ;    EXPAND_PUSH FALSE
  40000000                M WREG_TRACKER = WREG_UNKN  ;forget latest value
                          M ;    EXPAND_POP
013C   390F               M     andlw 0x0F
013D   000B               M     brw
013E   3492               M     retlw BRKOUT_BYTE_73
013F   3492               M     retlw BRKOUT_BYTE_73
0140   3492               M     retlw BRKOUT_BYTE_73
0141   3492               M     retlw BRKOUT_BYTE_73
0142   3492               M     retlw BRKOUT_BYTE_73
0143   3492               M     retlw BRKOUT_BYTE_73
0144   3492               M     retlw BRKOUT_BYTE_73
0145   3492               M     retlw BRKOUT_BYTE_73
0146   3207               M     bra custom_palent_encpiece_7
0147   34B6               M     retlw BRKOUT_BYTE_109
0148   3492               M     retlw BRKOUT_BYTE_73
0149   3492               M     retlw BRKOUT_BYTE_73
014A   3492               M     retlw BRKOUT_BYTE_73
014B   3492               M     retlw BRKOUT_BYTE_73
014C   3492               M     retlw BRKOUT_BYTE_73
014D   3496               M     retlw BRKOUT_BYTE_105
                          M custom_palent_encpiece_7: DROP_CONTEXT
                          M     DROP_BANK
                          M ;    EXPAND_PUSH FALSE
  FFFFFFFF                M BANK_TRACKER = BANK_UNKN  ;forget where latest value came from (used for jump targets)
                          M ;    EXPAND_POP
                          M     DROP_WREG
                          M ;    EXPAND_PUSH FALSE
  40000000                M WREG_TRACKER = WREG_UNKN  ;forget latest value
                          M ;    EXPAND_POP
014E   3092               M     movlw BRKOUT_BYTE_73
                          M     iorlw_tracker BRKOUT_BYTE_32
                          M ;    EXPAND_PUSH FALSE
                          M ;    andlw arg
                          M     ERRIF((BRKOUT_BYTE_32) & ~0xFF, [ERROR] extra IOR bits ignored: 0          @2336)
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M     EMIT iorlw BRKOUT_BYTE_32; PROGDCL 0x3800 | value
0150   3804               M     iorlw BRKOUT_BYTE_32
                          M ;    NOEXPAND; reduce clutter
                          M ;don't do this: (doesn't handle STATUS)
                          M     if WREG_TRACKER != WREG_UNKN
  80000096                M WREG_TRACKER = IIF(ISLIT(WREG_TRACKER), LITERAL(WREG_TRACKER | (BRKOUT_BYTE_32)), WREG_UNKN)
                          M     endif
                          M ;    DROP_WREG
                          M ;    EXPAND_POP
014F                      M     ORG ctx_addr_83
0151                      M     ORG ctx_addr_84
                          M     iorlw_tracker BRKOUT_BYTE_4
                          M ;    EXPAND_PUSH FALSE
                          M ;    andlw arg
                          M     ERRIF((BRKOUT_BYTE_4) & ~0xFF, [ERROR] extra IOR bits ignored: 0           @2336)
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M     EMIT iorlw BRKOUT_BYTE_4; PROGDCL 0x3800 | value
0152   3820               M     iorlw BRKOUT_BYTE_4
                          M ;    NOEXPAND; reduce clutter
                          M ;don't do this: (doesn't handle STATUS)
                          M     if WREG_TRACKER != WREG_UNKN
  800000B6                M WREG_TRACKER = IIF(ISLIT(WREG_TRACKER), LITERAL(WREG_TRACKER | (BRKOUT_BYTE_4)), WREG_UNKN)
                          M     endif
                          M ;    DROP_WREG
                          M ;    EXPAND_POP
0151                      M     ORG ctx_addr_85
0153                      M     ORG ctx_addr_86
0153   0008               M     return
                          M get_palent_encpiece_8: DROP_CONTEXT
                          M     DROP_BANK
                          M ;    EXPAND_PUSH FALSE
  FFFFFFFF                M BANK_TRACKER = BANK_UNKN  ;forget where latest value came from (used for jump targets)
                          M ;    EXPAND_POP
                          M     DROP_WREG
                          M ;    EXPAND_PUSH FALSE
  40000000                M WREG_TRACKER = WREG_UNKN  ;forget latest value
                          M ;    EXPAND_POP
0154   390F               M     andlw 0x0F
0155   000B               M     brw
0156   3424               M     retlw BRKOUT_BYTE_36
0157   342C               M     retlw BRKOUT_BYTE_52
0158   3424               M     retlw BRKOUT_BYTE_36
0159   3464               M     retlw BRKOUT_BYTE_38
015A   3424               M     retlw BRKOUT_BYTE_36
015B   3464               M     retlw BRKOUT_BYTE_38
015C   3424               M     retlw BRKOUT_BYTE_36
015D   3464               M     retlw BRKOUT_BYTE_38
015E   3207               M     bra custom_palent_encpiece_8
015F   346D               M     retlw BRKOUT_BYTE_182
0160   3424               M     retlw BRKOUT_BYTE_36
0161   3424               M     retlw BRKOUT_BYTE_36
0162   3424               M     retlw BRKOUT_BYTE_36
0163   3424               M     retlw BRKOUT_BYTE_36
0164   3424               M     retlw BRKOUT_BYTE_36
0165   3465               M     retlw BRKOUT_BYTE_166
                          M custom_palent_encpiece_8: DROP_CONTEXT
                          M     DROP_BANK
                          M ;    EXPAND_PUSH FALSE
  FFFFFFFF                M BANK_TRACKER = BANK_UNKN  ;forget where latest value came from (used for jump targets)
                          M ;    EXPAND_POP
                          M     DROP_WREG
                          M ;    EXPAND_PUSH FALSE
  40000000                M WREG_TRACKER = WREG_UNKN  ;forget latest value
                          M ;    EXPAND_POP
0166   3024               M     movlw BRKOUT_BYTE_36
                          M     iorlw_tracker BRKOUT_BYTE_128
                          M ;    EXPAND_PUSH FALSE
                          M ;    andlw arg
                          M     ERRIF((BRKOUT_BYTE_128) & ~0xFF, [ERROR] extra IOR bits ignored: 0         @2336)
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M     EMIT iorlw BRKOUT_BYTE_128; PROGDCL 0x3800 | value
0168   3801               M     iorlw BRKOUT_BYTE_128
                          M ;    NOEXPAND; reduce clutter
                          M ;don't do this: (doesn't handle STATUS)
                          M     if WREG_TRACKER != WREG_UNKN
  80000025                M WREG_TRACKER = IIF(ISLIT(WREG_TRACKER), LITERAL(WREG_TRACKER | (BRKOUT_BYTE_128)), WREG_UNKN)
                          M     endif
                          M ;    DROP_WREG
                          M ;    EXPAND_POP
0167                      M     ORG ctx_addr_87
0169                      M     ORG ctx_addr_88
                          M     iorlw_tracker BRKOUT_BYTE_16
                          M ;    EXPAND_PUSH FALSE
                          M ;    andlw arg
                          M     ERRIF((BRKOUT_BYTE_16) & ~0xFF, [ERROR] extra IOR bits ignored: 0          @2336)
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M     EMIT iorlw BRKOUT_BYTE_16; PROGDCL 0x3800 | value
016A   3808               M     iorlw BRKOUT_BYTE_16
                          M ;    NOEXPAND; reduce clutter
                          M ;don't do this: (doesn't handle STATUS)
                          M     if WREG_TRACKER != WREG_UNKN
  8000002D                M WREG_TRACKER = IIF(ISLIT(WREG_TRACKER), LITERAL(WREG_TRACKER | (BRKOUT_BYTE_16)), WREG_UNKN)
                          M     endif
                          M ;    DROP_WREG
                          M ;    EXPAND_POP
0169                      M     ORG ctx_addr_89
016B                      M     ORG ctx_addr_90
                          M     iorlw_tracker BRKOUT_BYTE_2
                          M ;    EXPAND_PUSH FALSE
                          M ;    andlw arg
                          M     ERRIF((BRKOUT_BYTE_2) & ~0xFF, [ERROR] extra IOR bits ignored: 0           @2336)
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M     EMIT iorlw BRKOUT_BYTE_2; PROGDCL 0x3800 | value
016C   3840               M     iorlw BRKOUT_BYTE_2
                          M ;    NOEXPAND; reduce clutter
                          M ;don't do this: (doesn't handle STATUS)
                          M     if WREG_TRACKER != WREG_UNKN
  8000006D                M WREG_TRACKER = IIF(ISLIT(WREG_TRACKER), LITERAL(WREG_TRACKER | (BRKOUT_BYTE_2)), WREG_UNKN)
                          M     endif
                          M ;    DROP_WREG
                          M ;    EXPAND_POP
016B                      M     ORG ctx_addr_91
016D                      M     ORG ctx_addr_92
016D   0008               M     return
                      00571 
                      00572 
                      00573     THREAD_END;
                      00574 
Message[301]: MESSAGE: (end of hoist 5 @577)
Message[301]: MESSAGE: (hoist 6: rcv frame thread (main logic) @179)
                          M         exitm
                      00182 ;; frame rcv thread (main logic) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                      00183 
                      00184 ;    UGLY_PASS12FIX -1
                      00185 ;    messg #thr #v(NUM_THREADS), YIELD @185
                      00186     THREAD_DEF rcv_frame, 4
                          M     CBLOCK NEXT_RAM9999; BOOL2INT(banked))  ;continue where we left off last time
  00000074                M         stkptr_1 
                          M     ENDC  ;can't span macros
Message[301]: MESSAGE: (creating rcv_frame thread# 1 @366, stack size 4, host stack remaining: 8 @1218)
016E   017F               M     banksel STKPTR
                          M     withdest_0 movf STKPTR
016F   086D               M     movf STKPTR, W;
0170   00F4               M     movwf stkptr_1
0174   0008               M     return
002F                      M     ORG ctx_addr_6
002F   2975               M     goto init_4
0175                      M     ORG ctx_addr_94
0175                      M init_4:
0175   2178               M     call stack_alloc_1
0176   217E               M     call rcv_frame
0177   2976               M     goto $-1
0178   017F               M     banksel STKPTR
                          M     withdest_0 movf STKPTR
0179   086D               M     movf STKPTR, W;
017A   00F4               M     movwf stkptr_1
017B   3003               M     movlw 4 - 1
                          M     withdest_1 addwf STKPTR
017C   07ED               M     addwf STKPTR, F;
                      00187 ;    messg #thr #v(NUM_THREADS), YIELD @187
                      00188 
                      00189 ;    init_more TRUE;
                      00190 ;    call brkout_ani; call this during init
                      00191 ;    init_more FALSE;
                      00192 
                      00193 ;blink_1sec: DROP_CONTEXT;
                      00194 rcv_frame: DROP_CONTEXT;
                      00195     CALL brkout_ani
017E   21BE               M     call brkout_ani
                      00196     fps_init 1 sec
Message[301]: MESSAGE: ([TODO] change this to use postscaler 1..16 instead of just powers of 2 (for more accuracy) @1055)
Message[301]: MESSAGE: ([DEBUG] fps_init 1000000 (1111111 tuned) "usec": "prescaler" 15+1, max intv 2097152, actual 1114112, rollover 136 @1071)
017F   3001               M     movlw (((ASM_MSB | (0 | 0 | _4034POSTSCALER << T0OUTPS0))) & ~ASM_MSB)
0180   014B               M     banksel T0CON0
0181   009E               M     movwf T0CON0
0182   304F               M     movlw (((ASM_MSB | (b'010' << T0CS0 | 0 | _4034PRESCALER << T0CKPS0))) & ~ASM_MSB)
0183   009F               M     movwf T0CON1
0184   019C               M     clrf TMR0L
0185   3087               M     movlw (((ASM_MSB | (_4034ROLLOVER - 1))) & ~ASM_MSB)
0186   009D               M     movwf TMR0H
                          M     withbit_7 bsf T0CON0
0187   179E               M     bsf T0CON0, 7
0188   014E               M     banksel PIR0
                          M     withbit_5 bcf PIR0
0189   128C               M     bcf PIR0, 5
                          M             exitm
                      00197 rcv_loop: DROP_CONTEXT;
                      00198     ifbit elapsed_fps, TRUE, CALL fps_update; render FPS 1x/sec during idle time at end of frame
018A   014E               M     banksel PIR0
                          M     call_pagesafe fps_update
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND; hide clutter
                          M     ERRIF(LITPAGEOF(fps_update), [ERROR] fps_update !on page 0: 0       @2912)
                          M ;PAGESEL_DROP += 1
                          M ;    LOCAL WREG_SAVE = WREG_TRACKER
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M ;    messg call dest, page tracker #v(PAGE_TRACKER), need page sel? #v(LITPAGEOF(dest)) != #v(LITPAGEOF(PAGE_TRACKER))? #v(LITPAGEOF(dest) != LITPAGEOF(PAGE_TRACKER))
                          M     if LITPAGEOF(fps_update) != LITPAGEOF(PAGE_TRACKER)
                          M         EMIT CLRF PCLATH; PAGESEL dest; kludge: mpasm doesn't want to pagesel
                          M PAGESEL_KEEP += 1
                          M     else
  0000001F                M PAGESEL_DROP += 1
                          M     endif
                          M     EMIT call fps_update; PROGDCL 0x2000 | (dest); call dest
018C   219D               M     call fps_update
  0000019D                M PAGE_TRACKER = fps_update;
                          M ;    NOEXPAND
                          M     if (fps_update == nop4) || (fps_update == nop8); ; these don't alter BSR or WREG
                          M ;        EXPAND_POP
                          M         exitm
                          M     endif
                          M     DROP_CONTEXT; BSR and WREG unknown here
                          M     DROP_BANK
                          M ;    EXPAND_PUSH FALSE
  FFFFFFFF                M BANK_TRACKER = BANK_UNKN  ;forget where latest value came from (used for jump targets)
                          M ;    EXPAND_POP
                          M     DROP_WREG
                          M ;    EXPAND_PUSH FALSE
  40000000                M WREG_TRACKER = WREG_UNKN  ;forget latest value
                          M ;    EXPAND_POP
                          M ;    if dest == choose_next_color
                          M ;WREG_TRACKER = color; kludge: avoid unknown contents warning
                          M ;    endif
                          M ;#ifdef BITBANG
                          M ;    if dest == bitbang_wreg
                          M ;BANK_TRACKER = LATA; preserve caller context to improve timing
                          M ;    endif
                          M ;#endif
                          M ;    EXPAND_POP
018B                      M     ORG ctx_addr_96
018D                      M     ORG ctx_addr_97
                      00199     INCF FPS, F; assume !overflow; max FPS likely ~ 40 - 50
                          M     withdest_1 incf FPS
018D   0AF5               M     incf FPS, F;
Message[301]: MESSAGE: (TODO: wait for 50 * 1, start rcv/xfr, trigger brkout render @200)
                      00200     messg TODO: wait for 50 usec, start rcv/xfr, trigger brkout render @200
                      00201     setbit LATA, LEDOUT, TRUE;
018E   0140               M     banksel LATA
                          M     withbit_4 bsf LATA
018F   1618               M     bsf LATA, 4
                      00202 ;    movlw 22;
                      00203 ;    BANKSAFE dest_arg(F) addwf FPS_render;
                      00204     wait4frame YIELD, YIELD_AGAIN; 1 sec
0190   216E               M     call yield
0191   014E               M     banksel PIR0
                          M     goto_pagesafe yield_again
                          M ;    EXPAND_PUSH FALSE
                          M ; messg here1 @2947
                          M     ERRIF(LITPAGEOF(yield_again), [ERROR] "dest" yield_again 369 !on page 0: 0          @2948)
                          M ; messg here2 @2949
                          M ;PAGESEL_DROP += 1
                          M ;    messg goto dest, page tracker #v(PAGE_TRACKER), need page sel? #v(LITPAGEOF(dest)) != #v(LITPAGEOF(PAGE_TRACKER))? #v(LITPAGEOF(dest) != LITPAGEOF(PAGE_TRACKER))
                          M     if LITPAGEOF(yield_again) != LITPAGEOF(PAGE_TRACKER)
                          M         EMIT CLRF PCLATH; PAGESEL dest; kludge: mpasm doesn't want to pagesel
                          M PAGESEL_KEEP += 1
                          M     else
  00000021                M PAGESEL_DROP += 1
                          M     endif
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M ; messg here3 @2959
                          M     EMIT goto yield_again; PROGDCL 0x2000 | (dest); call dest
0193   2971               M     goto yield_again
  00000171                M PAGE_TRACKER = yield_again;
                          M ; messg here4 @2962
                          M ;    NOEXPAND
                          M ;not needed: fall-thru would be handled by earlier code    DROP_CONTEXT; BSR and WREG unknown here if dest falls through
                          M ;    EXPAND_POP
0192                      M     ORG ctx_addr_98
0194                      M     ORG ctx_addr_99
                          M     withbit_5 bcf PIR0
0194   128C               M     bcf PIR0, 5
                      00205     setbit LATA, LEDOUT, FALSE;
0195   0140               M     banksel LATA
                          M     withbit_4 bcf LATA
0196   1218               M     bcf LATA, 4
                      00206 ;    movlw 10;
                      00207 ;    BANKSAFE dest_arg(F) addwf FPS_render;
                      00208     wait4frame YIELD, YIELD_AGAIN; 1 sec
0197   216E               M     call yield
0198   014E               M     banksel PIR0
                          M     goto_pagesafe yield_again
                          M ;    EXPAND_PUSH FALSE
                          M ; messg here1 @2947
                          M     ERRIF(LITPAGEOF(yield_again), [ERROR] "dest" yield_again 369 !on page 0: 0          @2948)
                          M ; messg here2 @2949
                          M ;PAGESEL_DROP += 1
                          M ;    messg goto dest, page tracker #v(PAGE_TRACKER), need page sel? #v(LITPAGEOF(dest)) != #v(LITPAGEOF(PAGE_TRACKER))? #v(LITPAGEOF(dest) != LITPAGEOF(PAGE_TRACKER))
                          M     if LITPAGEOF(yield_again) != LITPAGEOF(PAGE_TRACKER)
                          M         EMIT CLRF PCLATH; PAGESEL dest; kludge: mpasm doesn't want to pagesel
                          M PAGESEL_KEEP += 1
                          M     else
  00000023                M PAGESEL_DROP += 1
                          M     endif
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M ; messg here3 @2959
                          M     EMIT goto yield_again; PROGDCL 0x2000 | (dest); call dest
019A   2971               M     goto yield_again
  00000171                M PAGE_TRACKER = yield_again;
                          M ; messg here4 @2962
                          M ;    NOEXPAND
                          M ;not needed: fall-thru would be handled by earlier code    DROP_CONTEXT; BSR and WREG unknown here if dest falls through
                          M ;    EXPAND_POP
0199                      M     ORG ctx_addr_100
019B                      M     ORG ctx_addr_101
                          M     withbit_5 bcf PIR0
019B   128C               M     bcf PIR0, 5
                      00209     GOTO rcv_loop;
019C   298A               M     goto rcv_loop
                      00210 
                      00211 
                      00212     nbDCL FPS,;;
                          M     CBLOCK NEXT_RAM9999; BOOL2INT(banked))  ;continue where we left off last time
  00000075                M         FPS  
                          M     ENDC  ;can't span macros
  0003                00213     CONSTANT FPS_RGBINX = CYAN_RGBINX; FPS
  0005                00214     CONSTANT FPS_RGBINX_ALT = MAGENTA_RGBINX; alternate FPS (heartbeat)
                      00215     ERRIF(!((FPS_RGBINX ^ FPS_RGBINX_ALT) & RED_RGBINX), [ERROR] red bit 4              can''t be used to check frame parity: 6                               @215);;
                      00216 
                      00217 set_fps_pxbit macro bitnum
                      00218     BANKCHK brkoutpx;
                      00219     messg TODO ^^^ fix banksel in ifbit @219
                      00220     ifbit FPS, 7 - bitnum, TRUE, MOVWF brkoutpx + 24 + bitnum;
                      00221     endm
                      00222 
                      00223 ;render FPS breakout px then reset:
                      00224 fps_update: DROP_CONTEXT;
                          M         exitm
                      00226     MOVLW WHITE_RGBINX;
019D   3007               M     movlw WHITE_RGBINX
                      00227     REPEAT LITERAL(8), MOVWF brkoutpx + 24 + REPEATER; set "on" color
  00000008                M _4406COUNT = (((ASM_MSB | (8))) & ~ASM_MSB)
                          M     movwf_banksafe brkoutpx + 24 + REPEATER
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + 24 + REPEATER
019E   0140               M     banksel brkoutpx + 24 + REPEATER
                          M     BANKSAFE EMIT movwf brkoutpx + 24 + REPEATER;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf brkoutpx + 24 + REPEATER
019F   00B8               M     movwf brkoutpx + 24 + REPEATER
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    EXPAND_POP
                          M     movwf_banksafe brkoutpx + 24 + REPEATER
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + 24 + REPEATER
                          M     BANKSAFE EMIT movwf brkoutpx + 24 + REPEATER;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf brkoutpx + 24 + REPEATER
01A0   00B9               M     movwf brkoutpx + 24 + REPEATER
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    EXPAND_POP
                          M     movwf_banksafe brkoutpx + 24 + REPEATER
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + 24 + REPEATER
                          M     BANKSAFE EMIT movwf brkoutpx + 24 + REPEATER;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf brkoutpx + 24 + REPEATER
01A1   00BA               M     movwf brkoutpx + 24 + REPEATER
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    EXPAND_POP
                          M     movwf_banksafe brkoutpx + 24 + REPEATER
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + 24 + REPEATER
                          M     BANKSAFE EMIT movwf brkoutpx + 24 + REPEATER;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf brkoutpx + 24 + REPEATER
01A2   00BB               M     movwf brkoutpx + 24 + REPEATER
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    EXPAND_POP
                          M     movwf_banksafe brkoutpx + 24 + REPEATER
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + 24 + REPEATER
                          M     BANKSAFE EMIT movwf brkoutpx + 24 + REPEATER;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf brkoutpx + 24 + REPEATER
01A3   00BC               M     movwf brkoutpx + 24 + REPEATER
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    EXPAND_POP
                          M     movwf_banksafe brkoutpx + 24 + REPEATER
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + 24 + REPEATER
                          M     BANKSAFE EMIT movwf brkoutpx + 24 + REPEATER;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf brkoutpx + 24 + REPEATER
01A4   00BD               M     movwf brkoutpx + 24 + REPEATER
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    EXPAND_POP
                          M     movwf_banksafe brkoutpx + 24 + REPEATER
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + 24 + REPEATER
                          M     BANKSAFE EMIT movwf brkoutpx + 24 + REPEATER;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf brkoutpx + 24 + REPEATER
01A5   00BE               M     movwf brkoutpx + 24 + REPEATER
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    EXPAND_POP
                          M     movwf_banksafe brkoutpx + 24 + REPEATER
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + 24 + REPEATER
                          M     BANKSAFE EMIT movwf brkoutpx + 24 + REPEATER;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf brkoutpx + 24 + REPEATER
01A6   00BF               M     movwf brkoutpx + 24 + REPEATER
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    EXPAND_POP
                      00228     MOVLW FPS_RGBINX;
01A7   3003               M     movlw FPS_RGBINX
                      00229     ifbit FPS, 7, TRUE, MOVLW FPS_RGBINX_ALT; kludge: use top bit for heartbeat color
                          M     movlw_tracker FPS_RGBINX_ALT
                          M ;    EXPAND_PUSH FALSE
                          M ;    andlw arg
                          M     ERRIF((FPS_RGBINX_ALT) & ~0xFF, [ERROR] extra MOV bits ignored: 0          @2305)
                          M     if WREG_TRACKER != LITERAL(FPS_RGBINX_ALT)
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M ;    messg movlw_tracker: "value" #v(value) value @2308
                          M         EMIT movlw FPS_RGBINX_ALT; #v(value); PROGDCL 0x3000 | (value)
01A9   3005               M     movlw FPS_RGBINX_ALT
                          M ;    NOEXPAND; reduce clutter
  80000005                M WREG_TRACKER = LITERAL(FPS_RGBINX_ALT)
                          M     endif
                          M ;    EXPAND_POP
01A8                      M     ORG ctx_addr_102
01AA                      M     ORG ctx_addr_103
                      00230     REPEAT LITERAL(8), set_fps_pxbit REPEATER; set "off" color
  00000008                M _4596COUNT = (((ASM_MSB | (8))) & ~ASM_MSB)
                          M     set_fps_pxbit REPEATER
                          M     BANKCHK brkoutpx;
Message[301]: MESSAGE: (TODO ^^^ fix banksel in ifbit @219)
                          M     messg TODO ^^^ fix banksel in ifbit @219
                          M     ifbit FPS, 7 - REPEATER, TRUE, MOVWF brkoutpx + 24 + REPEATER;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND  ;reduce clutter
                          M ;    if (SRC == DEST) && ((srcbytes) == (destbytes)) && !(reverse)  ;nothing to do
                          M ;    LOCAL BIT = bit ;kludge; force eval (avoids "missing operand" and "missing argument" errors/MPASM bugs); also helps avoid "line too long" messages (MPASM limit 200)
  0075                    M     LOCAL REG = FPS ;kludge; force eval (avoids "missing operand" and "missing argument" errors/MPASM bugs); also helps avoid "line too long" messages (MPASM limit 200)
                          M ;    messg "mov8", #v(DEST), #v(SRC), #v(ISLIT(SRC)), #v(LIT2VAL(SRC)) @2672
                          M ;    messg src, dest @2673;
                          M     if ISLIT(FPS); ; compile-time check
                          M         if BOOL2INT(LIT2VAL(FPS) & BIT(7 - REPEATER)) == BOOL2INT(1)
                          M ;           EXPAND_PUSH TRUE
                          M             EMIT movwf_banksafe brkoutpx + 24 + REPEATER
                          M ;           EXPAND_POP
                          M         endif
                          M ;        EXPAND_POP
                          M         exitm
                          M     endif
                          M ;    BANKCHK reg;
                          M ;    if BOOL2INT(bitval)
                          M ;       BANKSAFE bitnum_arg(bitnum) btfsc reg;, bitnum;
                          M ;    else
                          M ;       BANKSAFE bitnum_arg(bitnum) btfss reg;, bitnum;
                          M ;    endif
                          M ;;    LOCAL BEFORE_STMT = $
                          M ;;STMT_ADDR#v(STMT_COUNTER) = 0-$
                          M ;    LOCAL STMT_ADDR
                          M ;STMT_INSTR = 0 - $
                          M ;    LOCAL SVWREG = WREG_TRACKER
                          M ;    EXPAND_RESTORE
                          M ;    stmt
                          M ;    NOEXPAND  ;reduce clutter
                          M ;    if WREG_TRACKER != SVWREG
                          M ;       DROP_WREG
                          M ;;      messg WREG unknown here, conditional stmt might have changed it @2699
                          M ;    endif
                          M ;;STMT_ADDR#v(STMT_COUNTER) += $
                          M ;STMT_INSTR += $
                          M ;;    LOCAL STMT_INSTR = STMT_ADDR; #v(STMT_COUNTER)
                          M ;;STMT_COUNTER += 1
                          M ;;    LOCAL AFTER_STMT = 0; $ - (BEFORE_STMT + 1)
                          M ;    WARNIF((STMT_INSTR != 1) && !ISLIT(reg), [ERROR] if-ed stmt !1 opcode: #v(STMT_INSTR), @2706); use warn to allow compile to continue
  0068                    M     LOCAL NUM_IFBIT = NUM_CONTEXT; kludge: need unique symbols
  01AA                    M     LOCAL has_banksel = $
                          M     BANKCHK FPS; do this before allocating fized-sized placeholder
  00000000                M has_banksel -= $
  01AA                    M     LOCAL before_addr = $, before_bank = BANK_TRACKER;, before_wreg = WREG_TRACKER
                          M     CONTEXT_SAVE before_104
  00000068                M before_104 EQU 104; allow context access by caller-supplied name
  00000069                M NUM_CONTEXT += 1
  01AA                    M     VARIABLE ctx_addr_104      = $
  0005                    M     VARIABLE ctx_wreg_104      = WREG_TRACKER
  0038                    M     VARIABLE ctx_bank_104      = BANK_TRACKER
  018A                    M     VARIABLE ctx_page_104      = PAGE_TRACKER
                          M ;no, let stmt change it;    DROP_CONTEXT
                          M ;    messg save ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @1965
01AB                      M     ORG before_addr + 1; leave placeholder for btf; backfill after checking for idler
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf_banksafe brkoutpx + 24 + REPEATER;
                          M     movwf_banksafe brkoutpx + 24 + REPEATER
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + 24 + REPEATER
                          M     BANKSAFE EMIT movwf brkoutpx + 24 + REPEATER;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf brkoutpx + 24 + REPEATER
01AB   00B8               M     movwf brkoutpx + 24 + REPEATER
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    EXPAND_POP
                          M ;    EXPAND_POP
  01AC                    M     LOCAL after_addr = $, after_bank = BANK_TRACKER;, after_wreg = WREG_TRACKER
                          M     CONTEXT_SAVE after_104
  00000069                M after_104 EQU 105; allow context access by caller-supplied name
  0000006A                M NUM_CONTEXT += 1
  01AC                    M     VARIABLE ctx_addr_105      = $
  0005                    M     VARIABLE ctx_wreg_105      = WREG_TRACKER
  0038                    M     VARIABLE ctx_bank_105      = BANK_TRACKER
  018A                    M     VARIABLE ctx_page_105      = PAGE_TRACKER
                          M ;no, let stmt change it;    DROP_CONTEXT
                          M ;    messg save ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @1965
  0000                    M     LOCAL bank_changed = BANKOF(after_bank);;
  00000000                M bank_changed -= BANKOF(before_bank); ; line too long :(
                          M ;    ORG before_addr
                          M ;BANK_TRACKER = before_bank
                          M ;WREG_TRACKER = before_wreg
                          M     CONTEXT_RESTORE before_104
                          M ;    messg restore ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @1969
                          M     EMIT ORG ctx_addr_104;
01AA                      M     ORG ctx_addr_104
  80000005                M WREG_TRACKER = ctx_wreg_104
  00000038                M BANK_TRACKER = ctx_bank_104
  0000018A                M PAGE_TRACKER = ctx_page_104
                          M     if after_addr == before_addr + 1; no stmt
                          M         WARNIF(has_banksel, [INFO] emitted extraneous banksel (no movwf_banksafe brkoutpx + 24 + REPEATER for ifbit) @2726);;
                          M     else; back-fill btf instr
                          M         if BOOL2INT(1)
                          M             BANKSAFE bitnum_arg(7 - REPEATER) btfsc FPS;, bitnum;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     withbit_7 btfsc FPS
01AA   1BF5               M     btfsc FPS, 7
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M         else
                          M             BANKSAFE bitnum_arg(7 - REPEATER) btfss FPS;, bitnum;
                          M         endif
                          M ;       ORG after_addr
                          M ;BANK_TRACKER = after_bank
                          M ;WREG_TRACKER = after_wreg
                          M         CONTEXT_RESTORE after_104
                          M ;    messg restore ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @1969
                          M     EMIT ORG ctx_addr_105;
01AC                      M     ORG ctx_addr_105
  80000005                M WREG_TRACKER = ctx_wreg_105
  00000038                M BANK_TRACKER = ctx_bank_105
  0000018A                M PAGE_TRACKER = ctx_page_105
                          M     endif
                          M ;    EXPAND_POP
  00000069                M NUM_IFBIT += 1; kludge: need unique labels
                          M     set_fps_pxbit REPEATER
                          M     BANKCHK brkoutpx;
Message[301]: MESSAGE: (TODO ^^^ fix banksel in ifbit @219)
                          M     messg TODO ^^^ fix banksel in ifbit @219
                          M     ifbit FPS, 7 - REPEATER, TRUE, MOVWF brkoutpx + 24 + REPEATER;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND  ;reduce clutter
                          M ;    if (SRC == DEST) && ((srcbytes) == (destbytes)) && !(reverse)  ;nothing to do
                          M ;    LOCAL BIT = bit ;kludge; force eval (avoids "missing operand" and "missing argument" errors/MPASM bugs); also helps avoid "line too long" messages (MPASM limit 200)
  0075                    M     LOCAL REG = FPS ;kludge; force eval (avoids "missing operand" and "missing argument" errors/MPASM bugs); also helps avoid "line too long" messages (MPASM limit 200)
                          M ;    messg "mov8", #v(DEST), #v(SRC), #v(ISLIT(SRC)), #v(LIT2VAL(SRC)) @2672
                          M ;    messg src, dest @2673;
                          M     if ISLIT(FPS); ; compile-time check
                          M         if BOOL2INT(LIT2VAL(FPS) & BIT(7 - REPEATER)) == BOOL2INT(1)
                          M ;           EXPAND_PUSH TRUE
                          M             EMIT movwf_banksafe brkoutpx + 24 + REPEATER
                          M ;           EXPAND_POP
                          M         endif
                          M ;        EXPAND_POP
                          M         exitm
                          M     endif
                          M ;    BANKCHK reg;
                          M ;    if BOOL2INT(bitval)
                          M ;       BANKSAFE bitnum_arg(bitnum) btfsc reg;, bitnum;
                          M ;    else
                          M ;       BANKSAFE bitnum_arg(bitnum) btfss reg;, bitnum;
                          M ;    endif
                          M ;;    LOCAL BEFORE_STMT = $
                          M ;;STMT_ADDR#v(STMT_COUNTER) = 0-$
                          M ;    LOCAL STMT_ADDR
                          M ;STMT_INSTR = 0 - $
                          M ;    LOCAL SVWREG = WREG_TRACKER
                          M ;    EXPAND_RESTORE
                          M ;    stmt
                          M ;    NOEXPAND  ;reduce clutter
                          M ;    if WREG_TRACKER != SVWREG
                          M ;       DROP_WREG
                          M ;;      messg WREG unknown here, conditional stmt might have changed it @2699
                          M ;    endif
                          M ;;STMT_ADDR#v(STMT_COUNTER) += $
                          M ;STMT_INSTR += $
                          M ;;    LOCAL STMT_INSTR = STMT_ADDR; #v(STMT_COUNTER)
                          M ;;STMT_COUNTER += 1
                          M ;;    LOCAL AFTER_STMT = 0; $ - (BEFORE_STMT + 1)
                          M ;    WARNIF((STMT_INSTR != 1) && !ISLIT(reg), [ERROR] if-ed stmt !1 opcode: #v(STMT_INSTR), @2706); use warn to allow compile to continue
  006A                    M     LOCAL NUM_IFBIT = NUM_CONTEXT; kludge: need unique symbols
  01AC                    M     LOCAL has_banksel = $
                          M     BANKCHK FPS; do this before allocating fized-sized placeholder
  00000000                M has_banksel -= $
  01AC                    M     LOCAL before_addr = $, before_bank = BANK_TRACKER;, before_wreg = WREG_TRACKER
                          M     CONTEXT_SAVE before_106
  0000006A                M before_106 EQU 106; allow context access by caller-supplied name
  0000006B                M NUM_CONTEXT += 1
  01AC                    M     VARIABLE ctx_addr_106      = $
  0005                    M     VARIABLE ctx_wreg_106      = WREG_TRACKER
  0038                    M     VARIABLE ctx_bank_106      = BANK_TRACKER
  018A                    M     VARIABLE ctx_page_106      = PAGE_TRACKER
                          M ;no, let stmt change it;    DROP_CONTEXT
                          M ;    messg save ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @1965
01AD                      M     ORG before_addr + 1; leave placeholder for btf; backfill after checking for idler
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf_banksafe brkoutpx + 24 + REPEATER;
                          M     movwf_banksafe brkoutpx + 24 + REPEATER
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + 24 + REPEATER
                          M     BANKSAFE EMIT movwf brkoutpx + 24 + REPEATER;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf brkoutpx + 24 + REPEATER
01AD   00B9               M     movwf brkoutpx + 24 + REPEATER
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    EXPAND_POP
                          M ;    EXPAND_POP
  01AE                    M     LOCAL after_addr = $, after_bank = BANK_TRACKER;, after_wreg = WREG_TRACKER
                          M     CONTEXT_SAVE after_106
  0000006B                M after_106 EQU 107; allow context access by caller-supplied name
  0000006C                M NUM_CONTEXT += 1
  01AE                    M     VARIABLE ctx_addr_107      = $
  0005                    M     VARIABLE ctx_wreg_107      = WREG_TRACKER
  0038                    M     VARIABLE ctx_bank_107      = BANK_TRACKER
  018A                    M     VARIABLE ctx_page_107      = PAGE_TRACKER
                          M ;no, let stmt change it;    DROP_CONTEXT
                          M ;    messg save ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @1965
  0000                    M     LOCAL bank_changed = BANKOF(after_bank);;
  00000000                M bank_changed -= BANKOF(before_bank); ; line too long :(
                          M ;    ORG before_addr
                          M ;BANK_TRACKER = before_bank
                          M ;WREG_TRACKER = before_wreg
                          M     CONTEXT_RESTORE before_106
                          M ;    messg restore ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @1969
                          M     EMIT ORG ctx_addr_106;
01AC                      M     ORG ctx_addr_106
  80000005                M WREG_TRACKER = ctx_wreg_106
  00000038                M BANK_TRACKER = ctx_bank_106
  0000018A                M PAGE_TRACKER = ctx_page_106
                          M     if after_addr == before_addr + 1; no stmt
                          M         WARNIF(has_banksel, [INFO] emitted extraneous banksel (no movwf_banksafe brkoutpx + 24 + REPEATER for ifbit) @2726);;
                          M     else; back-fill btf instr
                          M         if BOOL2INT(1)
                          M             BANKSAFE bitnum_arg(7 - REPEATER) btfsc FPS;, bitnum;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     withbit_6 btfsc FPS
01AC   1B75               M     btfsc FPS, 6
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M         else
                          M             BANKSAFE bitnum_arg(7 - REPEATER) btfss FPS;, bitnum;
                          M         endif
                          M ;       ORG after_addr
                          M ;BANK_TRACKER = after_bank
                          M ;WREG_TRACKER = after_wreg
                          M         CONTEXT_RESTORE after_106
                          M ;    messg restore ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @1969
                          M     EMIT ORG ctx_addr_107;
01AE                      M     ORG ctx_addr_107
  80000005                M WREG_TRACKER = ctx_wreg_107
  00000038                M BANK_TRACKER = ctx_bank_107
  0000018A                M PAGE_TRACKER = ctx_page_107
                          M     endif
                          M ;    EXPAND_POP
  0000006B                M NUM_IFBIT += 1; kludge: need unique labels
                          M     set_fps_pxbit REPEATER
                          M     BANKCHK brkoutpx;
Message[301]: MESSAGE: (TODO ^^^ fix banksel in ifbit @219)
                          M     messg TODO ^^^ fix banksel in ifbit @219
                          M     ifbit FPS, 7 - REPEATER, TRUE, MOVWF brkoutpx + 24 + REPEATER;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND  ;reduce clutter
                          M ;    if (SRC == DEST) && ((srcbytes) == (destbytes)) && !(reverse)  ;nothing to do
                          M ;    LOCAL BIT = bit ;kludge; force eval (avoids "missing operand" and "missing argument" errors/MPASM bugs); also helps avoid "line too long" messages (MPASM limit 200)
  0075                    M     LOCAL REG = FPS ;kludge; force eval (avoids "missing operand" and "missing argument" errors/MPASM bugs); also helps avoid "line too long" messages (MPASM limit 200)
                          M ;    messg "mov8", #v(DEST), #v(SRC), #v(ISLIT(SRC)), #v(LIT2VAL(SRC)) @2672
                          M ;    messg src, dest @2673;
                          M     if ISLIT(FPS); ; compile-time check
                          M         if BOOL2INT(LIT2VAL(FPS) & BIT(7 - REPEATER)) == BOOL2INT(1)
                          M ;           EXPAND_PUSH TRUE
                          M             EMIT movwf_banksafe brkoutpx + 24 + REPEATER
                          M ;           EXPAND_POP
                          M         endif
                          M ;        EXPAND_POP
                          M         exitm
                          M     endif
                          M ;    BANKCHK reg;
                          M ;    if BOOL2INT(bitval)
                          M ;       BANKSAFE bitnum_arg(bitnum) btfsc reg;, bitnum;
                          M ;    else
                          M ;       BANKSAFE bitnum_arg(bitnum) btfss reg;, bitnum;
                          M ;    endif
                          M ;;    LOCAL BEFORE_STMT = $
                          M ;;STMT_ADDR#v(STMT_COUNTER) = 0-$
                          M ;    LOCAL STMT_ADDR
                          M ;STMT_INSTR = 0 - $
                          M ;    LOCAL SVWREG = WREG_TRACKER
                          M ;    EXPAND_RESTORE
                          M ;    stmt
                          M ;    NOEXPAND  ;reduce clutter
                          M ;    if WREG_TRACKER != SVWREG
                          M ;       DROP_WREG
                          M ;;      messg WREG unknown here, conditional stmt might have changed it @2699
                          M ;    endif
                          M ;;STMT_ADDR#v(STMT_COUNTER) += $
                          M ;STMT_INSTR += $
                          M ;;    LOCAL STMT_INSTR = STMT_ADDR; #v(STMT_COUNTER)
                          M ;;STMT_COUNTER += 1
                          M ;;    LOCAL AFTER_STMT = 0; $ - (BEFORE_STMT + 1)
                          M ;    WARNIF((STMT_INSTR != 1) && !ISLIT(reg), [ERROR] if-ed stmt !1 opcode: #v(STMT_INSTR), @2706); use warn to allow compile to continue
  006C                    M     LOCAL NUM_IFBIT = NUM_CONTEXT; kludge: need unique symbols
  01AE                    M     LOCAL has_banksel = $
                          M     BANKCHK FPS; do this before allocating fized-sized placeholder
  00000000                M has_banksel -= $
  01AE                    M     LOCAL before_addr = $, before_bank = BANK_TRACKER;, before_wreg = WREG_TRACKER
                          M     CONTEXT_SAVE before_108
  0000006C                M before_108 EQU 108; allow context access by caller-supplied name
  0000006D                M NUM_CONTEXT += 1
  01AE                    M     VARIABLE ctx_addr_108      = $
  0005                    M     VARIABLE ctx_wreg_108      = WREG_TRACKER
  0038                    M     VARIABLE ctx_bank_108      = BANK_TRACKER
  018A                    M     VARIABLE ctx_page_108      = PAGE_TRACKER
                          M ;no, let stmt change it;    DROP_CONTEXT
                          M ;    messg save ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @1965
01AF                      M     ORG before_addr + 1; leave placeholder for btf; backfill after checking for idler
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf_banksafe brkoutpx + 24 + REPEATER;
                          M     movwf_banksafe brkoutpx + 24 + REPEATER
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + 24 + REPEATER
                          M     BANKSAFE EMIT movwf brkoutpx + 24 + REPEATER;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf brkoutpx + 24 + REPEATER
01AF   00BA               M     movwf brkoutpx + 24 + REPEATER
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    EXPAND_POP
                          M ;    EXPAND_POP
  01B0                    M     LOCAL after_addr = $, after_bank = BANK_TRACKER;, after_wreg = WREG_TRACKER
                          M     CONTEXT_SAVE after_108
  0000006D                M after_108 EQU 109; allow context access by caller-supplied name
  0000006E                M NUM_CONTEXT += 1
  01B0                    M     VARIABLE ctx_addr_109      = $
  0005                    M     VARIABLE ctx_wreg_109      = WREG_TRACKER
  0038                    M     VARIABLE ctx_bank_109      = BANK_TRACKER
  018A                    M     VARIABLE ctx_page_109      = PAGE_TRACKER
                          M ;no, let stmt change it;    DROP_CONTEXT
                          M ;    messg save ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @1965
  0000                    M     LOCAL bank_changed = BANKOF(after_bank);;
  00000000                M bank_changed -= BANKOF(before_bank); ; line too long :(
                          M ;    ORG before_addr
                          M ;BANK_TRACKER = before_bank
                          M ;WREG_TRACKER = before_wreg
                          M     CONTEXT_RESTORE before_108
                          M ;    messg restore ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @1969
                          M     EMIT ORG ctx_addr_108;
01AE                      M     ORG ctx_addr_108
  80000005                M WREG_TRACKER = ctx_wreg_108
  00000038                M BANK_TRACKER = ctx_bank_108
  0000018A                M PAGE_TRACKER = ctx_page_108
                          M     if after_addr == before_addr + 1; no stmt
                          M         WARNIF(has_banksel, [INFO] emitted extraneous banksel (no movwf_banksafe brkoutpx + 24 + REPEATER for ifbit) @2726);;
                          M     else; back-fill btf instr
                          M         if BOOL2INT(1)
                          M             BANKSAFE bitnum_arg(7 - REPEATER) btfsc FPS;, bitnum;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     withbit_5 btfsc FPS
01AE   1AF5               M     btfsc FPS, 5
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M         else
                          M             BANKSAFE bitnum_arg(7 - REPEATER) btfss FPS;, bitnum;
                          M         endif
                          M ;       ORG after_addr
                          M ;BANK_TRACKER = after_bank
                          M ;WREG_TRACKER = after_wreg
                          M         CONTEXT_RESTORE after_108
                          M ;    messg restore ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @1969
                          M     EMIT ORG ctx_addr_109;
01B0                      M     ORG ctx_addr_109
  80000005                M WREG_TRACKER = ctx_wreg_109
  00000038                M BANK_TRACKER = ctx_bank_109
  0000018A                M PAGE_TRACKER = ctx_page_109
                          M     endif
                          M ;    EXPAND_POP
  0000006D                M NUM_IFBIT += 1; kludge: need unique labels
                          M     set_fps_pxbit REPEATER
                          M     BANKCHK brkoutpx;
Message[301]: MESSAGE: (TODO ^^^ fix banksel in ifbit @219)
                          M     messg TODO ^^^ fix banksel in ifbit @219
                          M     ifbit FPS, 7 - REPEATER, TRUE, MOVWF brkoutpx + 24 + REPEATER;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND  ;reduce clutter
                          M ;    if (SRC == DEST) && ((srcbytes) == (destbytes)) && !(reverse)  ;nothing to do
                          M ;    LOCAL BIT = bit ;kludge; force eval (avoids "missing operand" and "missing argument" errors/MPASM bugs); also helps avoid "line too long" messages (MPASM limit 200)
  0075                    M     LOCAL REG = FPS ;kludge; force eval (avoids "missing operand" and "missing argument" errors/MPASM bugs); also helps avoid "line too long" messages (MPASM limit 200)
                          M ;    messg "mov8", #v(DEST), #v(SRC), #v(ISLIT(SRC)), #v(LIT2VAL(SRC)) @2672
                          M ;    messg src, dest @2673;
                          M     if ISLIT(FPS); ; compile-time check
                          M         if BOOL2INT(LIT2VAL(FPS) & BIT(7 - REPEATER)) == BOOL2INT(1)
                          M ;           EXPAND_PUSH TRUE
                          M             EMIT movwf_banksafe brkoutpx + 24 + REPEATER
                          M ;           EXPAND_POP
                          M         endif
                          M ;        EXPAND_POP
                          M         exitm
                          M     endif
                          M ;    BANKCHK reg;
                          M ;    if BOOL2INT(bitval)
                          M ;       BANKSAFE bitnum_arg(bitnum) btfsc reg;, bitnum;
                          M ;    else
                          M ;       BANKSAFE bitnum_arg(bitnum) btfss reg;, bitnum;
                          M ;    endif
                          M ;;    LOCAL BEFORE_STMT = $
                          M ;;STMT_ADDR#v(STMT_COUNTER) = 0-$
                          M ;    LOCAL STMT_ADDR
                          M ;STMT_INSTR = 0 - $
                          M ;    LOCAL SVWREG = WREG_TRACKER
                          M ;    EXPAND_RESTORE
                          M ;    stmt
                          M ;    NOEXPAND  ;reduce clutter
                          M ;    if WREG_TRACKER != SVWREG
                          M ;       DROP_WREG
                          M ;;      messg WREG unknown here, conditional stmt might have changed it @2699
                          M ;    endif
                          M ;;STMT_ADDR#v(STMT_COUNTER) += $
                          M ;STMT_INSTR += $
                          M ;;    LOCAL STMT_INSTR = STMT_ADDR; #v(STMT_COUNTER)
                          M ;;STMT_COUNTER += 1
                          M ;;    LOCAL AFTER_STMT = 0; $ - (BEFORE_STMT + 1)
                          M ;    WARNIF((STMT_INSTR != 1) && !ISLIT(reg), [ERROR] if-ed stmt !1 opcode: #v(STMT_INSTR), @2706); use warn to allow compile to continue
  006E                    M     LOCAL NUM_IFBIT = NUM_CONTEXT; kludge: need unique symbols
  01B0                    M     LOCAL has_banksel = $
                          M     BANKCHK FPS; do this before allocating fized-sized placeholder
  00000000                M has_banksel -= $
  01B0                    M     LOCAL before_addr = $, before_bank = BANK_TRACKER;, before_wreg = WREG_TRACKER
                          M     CONTEXT_SAVE before_110
  0000006E                M before_110 EQU 110; allow context access by caller-supplied name
  0000006F                M NUM_CONTEXT += 1
  01B0                    M     VARIABLE ctx_addr_110      = $
  0005                    M     VARIABLE ctx_wreg_110      = WREG_TRACKER
  0038                    M     VARIABLE ctx_bank_110      = BANK_TRACKER
  018A                    M     VARIABLE ctx_page_110      = PAGE_TRACKER
                          M ;no, let stmt change it;    DROP_CONTEXT
                          M ;    messg save ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @1965
01B1                      M     ORG before_addr + 1; leave placeholder for btf; backfill after checking for idler
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf_banksafe brkoutpx + 24 + REPEATER;
                          M     movwf_banksafe brkoutpx + 24 + REPEATER
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + 24 + REPEATER
                          M     BANKSAFE EMIT movwf brkoutpx + 24 + REPEATER;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf brkoutpx + 24 + REPEATER
01B1   00BB               M     movwf brkoutpx + 24 + REPEATER
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    EXPAND_POP
                          M ;    EXPAND_POP
  01B2                    M     LOCAL after_addr = $, after_bank = BANK_TRACKER;, after_wreg = WREG_TRACKER
                          M     CONTEXT_SAVE after_110
  0000006F                M after_110 EQU 111; allow context access by caller-supplied name
  00000070                M NUM_CONTEXT += 1
  01B2                    M     VARIABLE ctx_addr_111      = $
  0005                    M     VARIABLE ctx_wreg_111      = WREG_TRACKER
  0038                    M     VARIABLE ctx_bank_111      = BANK_TRACKER
  018A                    M     VARIABLE ctx_page_111      = PAGE_TRACKER
                          M ;no, let stmt change it;    DROP_CONTEXT
                          M ;    messg save ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @1965
  0000                    M     LOCAL bank_changed = BANKOF(after_bank);;
  00000000                M bank_changed -= BANKOF(before_bank); ; line too long :(
                          M ;    ORG before_addr
                          M ;BANK_TRACKER = before_bank
                          M ;WREG_TRACKER = before_wreg
                          M     CONTEXT_RESTORE before_110
                          M ;    messg restore ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @1969
                          M     EMIT ORG ctx_addr_110;
01B0                      M     ORG ctx_addr_110
  80000005                M WREG_TRACKER = ctx_wreg_110
  00000038                M BANK_TRACKER = ctx_bank_110
  0000018A                M PAGE_TRACKER = ctx_page_110
                          M     if after_addr == before_addr + 1; no stmt
                          M         WARNIF(has_banksel, [INFO] emitted extraneous banksel (no movwf_banksafe brkoutpx + 24 + REPEATER for ifbit) @2726);;
                          M     else; back-fill btf instr
                          M         if BOOL2INT(1)
                          M             BANKSAFE bitnum_arg(7 - REPEATER) btfsc FPS;, bitnum;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     withbit_4 btfsc FPS
01B0   1A75               M     btfsc FPS, 4
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M         else
                          M             BANKSAFE bitnum_arg(7 - REPEATER) btfss FPS;, bitnum;
                          M         endif
                          M ;       ORG after_addr
                          M ;BANK_TRACKER = after_bank
                          M ;WREG_TRACKER = after_wreg
                          M         CONTEXT_RESTORE after_110
                          M ;    messg restore ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @1969
                          M     EMIT ORG ctx_addr_111;
01B2                      M     ORG ctx_addr_111
  80000005                M WREG_TRACKER = ctx_wreg_111
  00000038                M BANK_TRACKER = ctx_bank_111
  0000018A                M PAGE_TRACKER = ctx_page_111
                          M     endif
                          M ;    EXPAND_POP
  0000006F                M NUM_IFBIT += 1; kludge: need unique labels
                          M     set_fps_pxbit REPEATER
                          M     BANKCHK brkoutpx;
Message[301]: MESSAGE: (TODO ^^^ fix banksel in ifbit @219)
                          M     messg TODO ^^^ fix banksel in ifbit @219
                          M     ifbit FPS, 7 - REPEATER, TRUE, MOVWF brkoutpx + 24 + REPEATER;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND  ;reduce clutter
                          M ;    if (SRC == DEST) && ((srcbytes) == (destbytes)) && !(reverse)  ;nothing to do
                          M ;    LOCAL BIT = bit ;kludge; force eval (avoids "missing operand" and "missing argument" errors/MPASM bugs); also helps avoid "line too long" messages (MPASM limit 200)
  0075                    M     LOCAL REG = FPS ;kludge; force eval (avoids "missing operand" and "missing argument" errors/MPASM bugs); also helps avoid "line too long" messages (MPASM limit 200)
                          M ;    messg "mov8", #v(DEST), #v(SRC), #v(ISLIT(SRC)), #v(LIT2VAL(SRC)) @2672
                          M ;    messg src, dest @2673;
                          M     if ISLIT(FPS); ; compile-time check
                          M         if BOOL2INT(LIT2VAL(FPS) & BIT(7 - REPEATER)) == BOOL2INT(1)
                          M ;           EXPAND_PUSH TRUE
                          M             EMIT movwf_banksafe brkoutpx + 24 + REPEATER
                          M ;           EXPAND_POP
                          M         endif
                          M ;        EXPAND_POP
                          M         exitm
                          M     endif
                          M ;    BANKCHK reg;
                          M ;    if BOOL2INT(bitval)
                          M ;       BANKSAFE bitnum_arg(bitnum) btfsc reg;, bitnum;
                          M ;    else
                          M ;       BANKSAFE bitnum_arg(bitnum) btfss reg;, bitnum;
                          M ;    endif
                          M ;;    LOCAL BEFORE_STMT = $
                          M ;;STMT_ADDR#v(STMT_COUNTER) = 0-$
                          M ;    LOCAL STMT_ADDR
                          M ;STMT_INSTR = 0 - $
                          M ;    LOCAL SVWREG = WREG_TRACKER
                          M ;    EXPAND_RESTORE
                          M ;    stmt
                          M ;    NOEXPAND  ;reduce clutter
                          M ;    if WREG_TRACKER != SVWREG
                          M ;       DROP_WREG
                          M ;;      messg WREG unknown here, conditional stmt might have changed it @2699
                          M ;    endif
                          M ;;STMT_ADDR#v(STMT_COUNTER) += $
                          M ;STMT_INSTR += $
                          M ;;    LOCAL STMT_INSTR = STMT_ADDR; #v(STMT_COUNTER)
                          M ;;STMT_COUNTER += 1
                          M ;;    LOCAL AFTER_STMT = 0; $ - (BEFORE_STMT + 1)
                          M ;    WARNIF((STMT_INSTR != 1) && !ISLIT(reg), [ERROR] if-ed stmt !1 opcode: #v(STMT_INSTR), @2706); use warn to allow compile to continue
  0070                    M     LOCAL NUM_IFBIT = NUM_CONTEXT; kludge: need unique symbols
  01B2                    M     LOCAL has_banksel = $
                          M     BANKCHK FPS; do this before allocating fized-sized placeholder
  00000000                M has_banksel -= $
  01B2                    M     LOCAL before_addr = $, before_bank = BANK_TRACKER;, before_wreg = WREG_TRACKER
                          M     CONTEXT_SAVE before_112
  00000070                M before_112 EQU 112; allow context access by caller-supplied name
  00000071                M NUM_CONTEXT += 1
  01B2                    M     VARIABLE ctx_addr_112      = $
  0005                    M     VARIABLE ctx_wreg_112      = WREG_TRACKER
  0038                    M     VARIABLE ctx_bank_112      = BANK_TRACKER
  018A                    M     VARIABLE ctx_page_112      = PAGE_TRACKER
                          M ;no, let stmt change it;    DROP_CONTEXT
                          M ;    messg save ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @1965
01B3                      M     ORG before_addr + 1; leave placeholder for btf; backfill after checking for idler
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf_banksafe brkoutpx + 24 + REPEATER;
                          M     movwf_banksafe brkoutpx + 24 + REPEATER
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + 24 + REPEATER
                          M     BANKSAFE EMIT movwf brkoutpx + 24 + REPEATER;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf brkoutpx + 24 + REPEATER
01B3   00BC               M     movwf brkoutpx + 24 + REPEATER
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    EXPAND_POP
                          M ;    EXPAND_POP
  01B4                    M     LOCAL after_addr = $, after_bank = BANK_TRACKER;, after_wreg = WREG_TRACKER
                          M     CONTEXT_SAVE after_112
  00000071                M after_112 EQU 113; allow context access by caller-supplied name
  00000072                M NUM_CONTEXT += 1
  01B4                    M     VARIABLE ctx_addr_113      = $
  0005                    M     VARIABLE ctx_wreg_113      = WREG_TRACKER
  0038                    M     VARIABLE ctx_bank_113      = BANK_TRACKER
  018A                    M     VARIABLE ctx_page_113      = PAGE_TRACKER
                          M ;no, let stmt change it;    DROP_CONTEXT
                          M ;    messg save ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @1965
  0000                    M     LOCAL bank_changed = BANKOF(after_bank);;
  00000000                M bank_changed -= BANKOF(before_bank); ; line too long :(
                          M ;    ORG before_addr
                          M ;BANK_TRACKER = before_bank
                          M ;WREG_TRACKER = before_wreg
                          M     CONTEXT_RESTORE before_112
                          M ;    messg restore ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @1969
                          M     EMIT ORG ctx_addr_112;
01B2                      M     ORG ctx_addr_112
  80000005                M WREG_TRACKER = ctx_wreg_112
  00000038                M BANK_TRACKER = ctx_bank_112
  0000018A                M PAGE_TRACKER = ctx_page_112
                          M     if after_addr == before_addr + 1; no stmt
                          M         WARNIF(has_banksel, [INFO] emitted extraneous banksel (no movwf_banksafe brkoutpx + 24 + REPEATER for ifbit) @2726);;
                          M     else; back-fill btf instr
                          M         if BOOL2INT(1)
                          M             BANKSAFE bitnum_arg(7 - REPEATER) btfsc FPS;, bitnum;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     withbit_3 btfsc FPS
01B2   19F5               M     btfsc FPS, 3
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M         else
                          M             BANKSAFE bitnum_arg(7 - REPEATER) btfss FPS;, bitnum;
                          M         endif
                          M ;       ORG after_addr
                          M ;BANK_TRACKER = after_bank
                          M ;WREG_TRACKER = after_wreg
                          M         CONTEXT_RESTORE after_112
                          M ;    messg restore ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @1969
                          M     EMIT ORG ctx_addr_113;
01B4                      M     ORG ctx_addr_113
  80000005                M WREG_TRACKER = ctx_wreg_113
  00000038                M BANK_TRACKER = ctx_bank_113
  0000018A                M PAGE_TRACKER = ctx_page_113
                          M     endif
                          M ;    EXPAND_POP
  00000071                M NUM_IFBIT += 1; kludge: need unique labels
                          M     set_fps_pxbit REPEATER
                          M     BANKCHK brkoutpx;
Message[301]: MESSAGE: (TODO ^^^ fix banksel in ifbit @219)
                          M     messg TODO ^^^ fix banksel in ifbit @219
                          M     ifbit FPS, 7 - REPEATER, TRUE, MOVWF brkoutpx + 24 + REPEATER;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND  ;reduce clutter
                          M ;    if (SRC == DEST) && ((srcbytes) == (destbytes)) && !(reverse)  ;nothing to do
                          M ;    LOCAL BIT = bit ;kludge; force eval (avoids "missing operand" and "missing argument" errors/MPASM bugs); also helps avoid "line too long" messages (MPASM limit 200)
  0075                    M     LOCAL REG = FPS ;kludge; force eval (avoids "missing operand" and "missing argument" errors/MPASM bugs); also helps avoid "line too long" messages (MPASM limit 200)
                          M ;    messg "mov8", #v(DEST), #v(SRC), #v(ISLIT(SRC)), #v(LIT2VAL(SRC)) @2672
                          M ;    messg src, dest @2673;
                          M     if ISLIT(FPS); ; compile-time check
                          M         if BOOL2INT(LIT2VAL(FPS) & BIT(7 - REPEATER)) == BOOL2INT(1)
                          M ;           EXPAND_PUSH TRUE
                          M             EMIT movwf_banksafe brkoutpx + 24 + REPEATER
                          M ;           EXPAND_POP
                          M         endif
                          M ;        EXPAND_POP
                          M         exitm
                          M     endif
                          M ;    BANKCHK reg;
                          M ;    if BOOL2INT(bitval)
                          M ;       BANKSAFE bitnum_arg(bitnum) btfsc reg;, bitnum;
                          M ;    else
                          M ;       BANKSAFE bitnum_arg(bitnum) btfss reg;, bitnum;
                          M ;    endif
                          M ;;    LOCAL BEFORE_STMT = $
                          M ;;STMT_ADDR#v(STMT_COUNTER) = 0-$
                          M ;    LOCAL STMT_ADDR
                          M ;STMT_INSTR = 0 - $
                          M ;    LOCAL SVWREG = WREG_TRACKER
                          M ;    EXPAND_RESTORE
                          M ;    stmt
                          M ;    NOEXPAND  ;reduce clutter
                          M ;    if WREG_TRACKER != SVWREG
                          M ;       DROP_WREG
                          M ;;      messg WREG unknown here, conditional stmt might have changed it @2699
                          M ;    endif
                          M ;;STMT_ADDR#v(STMT_COUNTER) += $
                          M ;STMT_INSTR += $
                          M ;;    LOCAL STMT_INSTR = STMT_ADDR; #v(STMT_COUNTER)
                          M ;;STMT_COUNTER += 1
                          M ;;    LOCAL AFTER_STMT = 0; $ - (BEFORE_STMT + 1)
                          M ;    WARNIF((STMT_INSTR != 1) && !ISLIT(reg), [ERROR] if-ed stmt !1 opcode: #v(STMT_INSTR), @2706); use warn to allow compile to continue
  0072                    M     LOCAL NUM_IFBIT = NUM_CONTEXT; kludge: need unique symbols
  01B4                    M     LOCAL has_banksel = $
                          M     BANKCHK FPS; do this before allocating fized-sized placeholder
  00000000                M has_banksel -= $
  01B4                    M     LOCAL before_addr = $, before_bank = BANK_TRACKER;, before_wreg = WREG_TRACKER
                          M     CONTEXT_SAVE before_114
  00000072                M before_114 EQU 114; allow context access by caller-supplied name
  00000073                M NUM_CONTEXT += 1
  01B4                    M     VARIABLE ctx_addr_114      = $
  0005                    M     VARIABLE ctx_wreg_114      = WREG_TRACKER
  0038                    M     VARIABLE ctx_bank_114      = BANK_TRACKER
  018A                    M     VARIABLE ctx_page_114      = PAGE_TRACKER
                          M ;no, let stmt change it;    DROP_CONTEXT
                          M ;    messg save ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @1965
01B5                      M     ORG before_addr + 1; leave placeholder for btf; backfill after checking for idler
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf_banksafe brkoutpx + 24 + REPEATER;
                          M     movwf_banksafe brkoutpx + 24 + REPEATER
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + 24 + REPEATER
                          M     BANKSAFE EMIT movwf brkoutpx + 24 + REPEATER;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf brkoutpx + 24 + REPEATER
01B5   00BD               M     movwf brkoutpx + 24 + REPEATER
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    EXPAND_POP
                          M ;    EXPAND_POP
  01B6                    M     LOCAL after_addr = $, after_bank = BANK_TRACKER;, after_wreg = WREG_TRACKER
                          M     CONTEXT_SAVE after_114
  00000073                M after_114 EQU 115; allow context access by caller-supplied name
  00000074                M NUM_CONTEXT += 1
  01B6                    M     VARIABLE ctx_addr_115      = $
  0005                    M     VARIABLE ctx_wreg_115      = WREG_TRACKER
  0038                    M     VARIABLE ctx_bank_115      = BANK_TRACKER
  018A                    M     VARIABLE ctx_page_115      = PAGE_TRACKER
                          M ;no, let stmt change it;    DROP_CONTEXT
                          M ;    messg save ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @1965
  0000                    M     LOCAL bank_changed = BANKOF(after_bank);;
  00000000                M bank_changed -= BANKOF(before_bank); ; line too long :(
                          M ;    ORG before_addr
                          M ;BANK_TRACKER = before_bank
                          M ;WREG_TRACKER = before_wreg
                          M     CONTEXT_RESTORE before_114
                          M ;    messg restore ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @1969
                          M     EMIT ORG ctx_addr_114;
01B4                      M     ORG ctx_addr_114
  80000005                M WREG_TRACKER = ctx_wreg_114
  00000038                M BANK_TRACKER = ctx_bank_114
  0000018A                M PAGE_TRACKER = ctx_page_114
                          M     if after_addr == before_addr + 1; no stmt
                          M         WARNIF(has_banksel, [INFO] emitted extraneous banksel (no movwf_banksafe brkoutpx + 24 + REPEATER for ifbit) @2726);;
                          M     else; back-fill btf instr
                          M         if BOOL2INT(1)
                          M             BANKSAFE bitnum_arg(7 - REPEATER) btfsc FPS;, bitnum;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     withbit_2 btfsc FPS
01B4   1975               M     btfsc FPS, 2
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M         else
                          M             BANKSAFE bitnum_arg(7 - REPEATER) btfss FPS;, bitnum;
                          M         endif
                          M ;       ORG after_addr
                          M ;BANK_TRACKER = after_bank
                          M ;WREG_TRACKER = after_wreg
                          M         CONTEXT_RESTORE after_114
                          M ;    messg restore ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @1969
                          M     EMIT ORG ctx_addr_115;
01B6                      M     ORG ctx_addr_115
  80000005                M WREG_TRACKER = ctx_wreg_115
  00000038                M BANK_TRACKER = ctx_bank_115
  0000018A                M PAGE_TRACKER = ctx_page_115
                          M     endif
                          M ;    EXPAND_POP
  00000073                M NUM_IFBIT += 1; kludge: need unique labels
                          M     set_fps_pxbit REPEATER
                          M     BANKCHK brkoutpx;
Message[301]: MESSAGE: (TODO ^^^ fix banksel in ifbit @219)
                          M     messg TODO ^^^ fix banksel in ifbit @219
                          M     ifbit FPS, 7 - REPEATER, TRUE, MOVWF brkoutpx + 24 + REPEATER;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND  ;reduce clutter
                          M ;    if (SRC == DEST) && ((srcbytes) == (destbytes)) && !(reverse)  ;nothing to do
                          M ;    LOCAL BIT = bit ;kludge; force eval (avoids "missing operand" and "missing argument" errors/MPASM bugs); also helps avoid "line too long" messages (MPASM limit 200)
  0075                    M     LOCAL REG = FPS ;kludge; force eval (avoids "missing operand" and "missing argument" errors/MPASM bugs); also helps avoid "line too long" messages (MPASM limit 200)
                          M ;    messg "mov8", #v(DEST), #v(SRC), #v(ISLIT(SRC)), #v(LIT2VAL(SRC)) @2672
                          M ;    messg src, dest @2673;
                          M     if ISLIT(FPS); ; compile-time check
                          M         if BOOL2INT(LIT2VAL(FPS) & BIT(7 - REPEATER)) == BOOL2INT(1)
                          M ;           EXPAND_PUSH TRUE
                          M             EMIT movwf_banksafe brkoutpx + 24 + REPEATER
                          M ;           EXPAND_POP
                          M         endif
                          M ;        EXPAND_POP
                          M         exitm
                          M     endif
                          M ;    BANKCHK reg;
                          M ;    if BOOL2INT(bitval)
                          M ;       BANKSAFE bitnum_arg(bitnum) btfsc reg;, bitnum;
                          M ;    else
                          M ;       BANKSAFE bitnum_arg(bitnum) btfss reg;, bitnum;
                          M ;    endif
                          M ;;    LOCAL BEFORE_STMT = $
                          M ;;STMT_ADDR#v(STMT_COUNTER) = 0-$
                          M ;    LOCAL STMT_ADDR
                          M ;STMT_INSTR = 0 - $
                          M ;    LOCAL SVWREG = WREG_TRACKER
                          M ;    EXPAND_RESTORE
                          M ;    stmt
                          M ;    NOEXPAND  ;reduce clutter
                          M ;    if WREG_TRACKER != SVWREG
                          M ;       DROP_WREG
                          M ;;      messg WREG unknown here, conditional stmt might have changed it @2699
                          M ;    endif
                          M ;;STMT_ADDR#v(STMT_COUNTER) += $
                          M ;STMT_INSTR += $
                          M ;;    LOCAL STMT_INSTR = STMT_ADDR; #v(STMT_COUNTER)
                          M ;;STMT_COUNTER += 1
                          M ;;    LOCAL AFTER_STMT = 0; $ - (BEFORE_STMT + 1)
                          M ;    WARNIF((STMT_INSTR != 1) && !ISLIT(reg), [ERROR] if-ed stmt !1 opcode: #v(STMT_INSTR), @2706); use warn to allow compile to continue
  0074                    M     LOCAL NUM_IFBIT = NUM_CONTEXT; kludge: need unique symbols
  01B6                    M     LOCAL has_banksel = $
                          M     BANKCHK FPS; do this before allocating fized-sized placeholder
  00000000                M has_banksel -= $
  01B6                    M     LOCAL before_addr = $, before_bank = BANK_TRACKER;, before_wreg = WREG_TRACKER
                          M     CONTEXT_SAVE before_116
  00000074                M before_116 EQU 116; allow context access by caller-supplied name
  00000075                M NUM_CONTEXT += 1
  01B6                    M     VARIABLE ctx_addr_116      = $
  0005                    M     VARIABLE ctx_wreg_116      = WREG_TRACKER
  0038                    M     VARIABLE ctx_bank_116      = BANK_TRACKER
  018A                    M     VARIABLE ctx_page_116      = PAGE_TRACKER
                          M ;no, let stmt change it;    DROP_CONTEXT
                          M ;    messg save ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @1965
01B7                      M     ORG before_addr + 1; leave placeholder for btf; backfill after checking for idler
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf_banksafe brkoutpx + 24 + REPEATER;
                          M     movwf_banksafe brkoutpx + 24 + REPEATER
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + 24 + REPEATER
                          M     BANKSAFE EMIT movwf brkoutpx + 24 + REPEATER;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf brkoutpx + 24 + REPEATER
01B7   00BE               M     movwf brkoutpx + 24 + REPEATER
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    EXPAND_POP
                          M ;    EXPAND_POP
  01B8                    M     LOCAL after_addr = $, after_bank = BANK_TRACKER;, after_wreg = WREG_TRACKER
                          M     CONTEXT_SAVE after_116
  00000075                M after_116 EQU 117; allow context access by caller-supplied name
  00000076                M NUM_CONTEXT += 1
  01B8                    M     VARIABLE ctx_addr_117      = $
  0005                    M     VARIABLE ctx_wreg_117      = WREG_TRACKER
  0038                    M     VARIABLE ctx_bank_117      = BANK_TRACKER
  018A                    M     VARIABLE ctx_page_117      = PAGE_TRACKER
                          M ;no, let stmt change it;    DROP_CONTEXT
                          M ;    messg save ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @1965
  0000                    M     LOCAL bank_changed = BANKOF(after_bank);;
  00000000                M bank_changed -= BANKOF(before_bank); ; line too long :(
                          M ;    ORG before_addr
                          M ;BANK_TRACKER = before_bank
                          M ;WREG_TRACKER = before_wreg
                          M     CONTEXT_RESTORE before_116
                          M ;    messg restore ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @1969
                          M     EMIT ORG ctx_addr_116;
01B6                      M     ORG ctx_addr_116
  80000005                M WREG_TRACKER = ctx_wreg_116
  00000038                M BANK_TRACKER = ctx_bank_116
  0000018A                M PAGE_TRACKER = ctx_page_116
                          M     if after_addr == before_addr + 1; no stmt
                          M         WARNIF(has_banksel, [INFO] emitted extraneous banksel (no movwf_banksafe brkoutpx + 24 + REPEATER for ifbit) @2726);;
                          M     else; back-fill btf instr
                          M         if BOOL2INT(1)
                          M             BANKSAFE bitnum_arg(7 - REPEATER) btfsc FPS;, bitnum;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     withbit_1 btfsc FPS
01B6   18F5               M     btfsc FPS, 1;
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M         else
                          M             BANKSAFE bitnum_arg(7 - REPEATER) btfss FPS;, bitnum;
                          M         endif
                          M ;       ORG after_addr
                          M ;BANK_TRACKER = after_bank
                          M ;WREG_TRACKER = after_wreg
                          M         CONTEXT_RESTORE after_116
                          M ;    messg restore ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @1969
                          M     EMIT ORG ctx_addr_117;
01B8                      M     ORG ctx_addr_117
  80000005                M WREG_TRACKER = ctx_wreg_117
  00000038                M BANK_TRACKER = ctx_bank_117
  0000018A                M PAGE_TRACKER = ctx_page_117
                          M     endif
                          M ;    EXPAND_POP
  00000075                M NUM_IFBIT += 1; kludge: need unique labels
                          M     set_fps_pxbit REPEATER
                          M     BANKCHK brkoutpx;
Message[301]: MESSAGE: (TODO ^^^ fix banksel in ifbit @219)
                          M     messg TODO ^^^ fix banksel in ifbit @219
                          M     ifbit FPS, 7 - REPEATER, TRUE, MOVWF brkoutpx + 24 + REPEATER;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND  ;reduce clutter
                          M ;    if (SRC == DEST) && ((srcbytes) == (destbytes)) && !(reverse)  ;nothing to do
                          M ;    LOCAL BIT = bit ;kludge; force eval (avoids "missing operand" and "missing argument" errors/MPASM bugs); also helps avoid "line too long" messages (MPASM limit 200)
  0075                    M     LOCAL REG = FPS ;kludge; force eval (avoids "missing operand" and "missing argument" errors/MPASM bugs); also helps avoid "line too long" messages (MPASM limit 200)
                          M ;    messg "mov8", #v(DEST), #v(SRC), #v(ISLIT(SRC)), #v(LIT2VAL(SRC)) @2672
                          M ;    messg src, dest @2673;
                          M     if ISLIT(FPS); ; compile-time check
                          M         if BOOL2INT(LIT2VAL(FPS) & BIT(7 - REPEATER)) == BOOL2INT(1)
                          M ;           EXPAND_PUSH TRUE
                          M             EMIT movwf_banksafe brkoutpx + 24 + REPEATER
                          M ;           EXPAND_POP
                          M         endif
                          M ;        EXPAND_POP
                          M         exitm
                          M     endif
                          M ;    BANKCHK reg;
                          M ;    if BOOL2INT(bitval)
                          M ;       BANKSAFE bitnum_arg(bitnum) btfsc reg;, bitnum;
                          M ;    else
                          M ;       BANKSAFE bitnum_arg(bitnum) btfss reg;, bitnum;
                          M ;    endif
                          M ;;    LOCAL BEFORE_STMT = $
                          M ;;STMT_ADDR#v(STMT_COUNTER) = 0-$
                          M ;    LOCAL STMT_ADDR
                          M ;STMT_INSTR = 0 - $
                          M ;    LOCAL SVWREG = WREG_TRACKER
                          M ;    EXPAND_RESTORE
                          M ;    stmt
                          M ;    NOEXPAND  ;reduce clutter
                          M ;    if WREG_TRACKER != SVWREG
                          M ;       DROP_WREG
                          M ;;      messg WREG unknown here, conditional stmt might have changed it @2699
                          M ;    endif
                          M ;;STMT_ADDR#v(STMT_COUNTER) += $
                          M ;STMT_INSTR += $
                          M ;;    LOCAL STMT_INSTR = STMT_ADDR; #v(STMT_COUNTER)
                          M ;;STMT_COUNTER += 1
                          M ;;    LOCAL AFTER_STMT = 0; $ - (BEFORE_STMT + 1)
                          M ;    WARNIF((STMT_INSTR != 1) && !ISLIT(reg), [ERROR] if-ed stmt !1 opcode: #v(STMT_INSTR), @2706); use warn to allow compile to continue
  0076                    M     LOCAL NUM_IFBIT = NUM_CONTEXT; kludge: need unique symbols
  01B8                    M     LOCAL has_banksel = $
                          M     BANKCHK FPS; do this before allocating fized-sized placeholder
  00000000                M has_banksel -= $
  01B8                    M     LOCAL before_addr = $, before_bank = BANK_TRACKER;, before_wreg = WREG_TRACKER
                          M     CONTEXT_SAVE before_118
  00000076                M before_118 EQU 118; allow context access by caller-supplied name
  00000077                M NUM_CONTEXT += 1
  01B8                    M     VARIABLE ctx_addr_118      = $
  0005                    M     VARIABLE ctx_wreg_118      = WREG_TRACKER
  0038                    M     VARIABLE ctx_bank_118      = BANK_TRACKER
  018A                    M     VARIABLE ctx_page_118      = PAGE_TRACKER
                          M ;no, let stmt change it;    DROP_CONTEXT
                          M ;    messg save ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @1965
01B9                      M     ORG before_addr + 1; leave placeholder for btf; backfill after checking for idler
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf_banksafe brkoutpx + 24 + REPEATER;
                          M     movwf_banksafe brkoutpx + 24 + REPEATER
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + 24 + REPEATER
                          M     BANKSAFE EMIT movwf brkoutpx + 24 + REPEATER;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf brkoutpx + 24 + REPEATER
01B9   00BF               M     movwf brkoutpx + 24 + REPEATER
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    EXPAND_POP
                          M ;    EXPAND_POP
  01BA                    M     LOCAL after_addr = $, after_bank = BANK_TRACKER;, after_wreg = WREG_TRACKER
                          M     CONTEXT_SAVE after_118
  00000077                M after_118 EQU 119; allow context access by caller-supplied name
  00000078                M NUM_CONTEXT += 1
  01BA                    M     VARIABLE ctx_addr_119      = $
  0005                    M     VARIABLE ctx_wreg_119      = WREG_TRACKER
  0038                    M     VARIABLE ctx_bank_119      = BANK_TRACKER
  018A                    M     VARIABLE ctx_page_119      = PAGE_TRACKER
                          M ;no, let stmt change it;    DROP_CONTEXT
                          M ;    messg save ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @1965
  0000                    M     LOCAL bank_changed = BANKOF(after_bank);;
  00000000                M bank_changed -= BANKOF(before_bank); ; line too long :(
                          M ;    ORG before_addr
                          M ;BANK_TRACKER = before_bank
                          M ;WREG_TRACKER = before_wreg
                          M     CONTEXT_RESTORE before_118
                          M ;    messg restore ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @1969
                          M     EMIT ORG ctx_addr_118;
01B8                      M     ORG ctx_addr_118
  80000005                M WREG_TRACKER = ctx_wreg_118
  00000038                M BANK_TRACKER = ctx_bank_118
  0000018A                M PAGE_TRACKER = ctx_page_118
                          M     if after_addr == before_addr + 1; no stmt
                          M         WARNIF(has_banksel, [INFO] emitted extraneous banksel (no movwf_banksafe brkoutpx + 24 + REPEATER for ifbit) @2726);;
                          M     else; back-fill btf instr
                          M         if BOOL2INT(1)
                          M             BANKSAFE bitnum_arg(7 - REPEATER) btfsc FPS;, bitnum;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     withbit_0 btfsc FPS
01B8   1875               M     btfsc FPS, 0;
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M         else
                          M             BANKSAFE bitnum_arg(7 - REPEATER) btfss FPS;, bitnum;
                          M         endif
                          M ;       ORG after_addr
                          M ;BANK_TRACKER = after_bank
                          M ;WREG_TRACKER = after_wreg
                          M         CONTEXT_RESTORE after_118
                          M ;    messg restore ctx_#v(name)_addr #v(ctx_#v(name)_addr), ctx_#v(name)_page #v(ctx_#v(name)_page) @1969
                          M     EMIT ORG ctx_addr_119;
01BA                      M     ORG ctx_addr_119
  80000005                M WREG_TRACKER = ctx_wreg_119
  00000038                M BANK_TRACKER = ctx_bank_119
  0000018A                M PAGE_TRACKER = ctx_page_119
                          M     endif
                          M ;    EXPAND_POP
  00000077                M NUM_IFBIT += 1; kludge: need unique labels
                      00231     CLRF FPS; restart frame count for next 1 sec
01BA   01F5               M     clrf FPS
                      00232     ifbit WREG, log2(RED_RGBINX), FPS_RGBINX & RED_RGBINX, biton_7     FPS; toggle parity
                          M     biton_7 FPS
                          M         setbit FPS, 7, TRUE;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND  ;reduce clutter
                          M ;    if (SRC == DEST) && ((srcbytes) == (destbytes)) && !(reverse)  ;nothing to do
                          M ;    LOCAL BIT = bit ;kludge; force eval (avoids "missing operand" and "missing argument" errors/MPASM bugs); also helps avoid "line too long" messages (MPASM limit 200)
  0075                    M     LOCAL DEST = FPS  ;kludge; force eval (avoids "missing operand" and "missing argument" errors/MPASM bugs); also helps avoid "line too long" messages (MPASM limit 200)
                          M ;    messg "mov8", #v(DEST), #v(SRC), #v(ISLIT(SRC)), #v(LIT2VAL(SRC)) @2560
                          M ;    messg src, dest @2561;
                          M ;    BANKCHK dest;
  0007                    M     LOCAL BITNUM = 7
                          M     if BOOL2INT(1)
                          M ;        BANKSAFE bitnum_arg(BITNUM) bsf dest;, bit;
                          M ;        EMIT bitnum_arg(BITNUM) BSF dest;, bit;
                          M         BSF FPS,  7;
                          M ;    EXPAND_PUSH FALSE
                          M     ERRIF((7)      & ~7, [ERROR] invalid 7      ignored: 7          @2384)
                          M     BANKCHK FPS
                          M     BANKSAFE EMIT bitnum_arg(7)      bsf FPS
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT withbit_7 bsf FPS
                          M     withbit_7 bsf FPS
01BC   17F5               M     bsf FPS, 7
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M     if FPS == WREG
                          M WREG_TRACKER = IIF(ISLIT(WREG_TRACKER), LITERAL(WREG_TRACKER | BIT(7)),      WREG_UNKN)
                          M     endif
                          M ;    EXPAND_POP
                          M     else
                          M ;       BANKSAFE bitnum_arg(BITNUM) bcf dest;, bit;
                          M ;       EMIT bitnum_arg(BITNUM) BCF dest;, bit;
                          M         BCF FPS,  7;
                          M     endif
                          M     if FPS  == WREG
                          M ;       if ISLIT(WREG_TRACKER)
                          M ;           if BOOL2INT(bitval)
                          M ;WREG_TRACKER |= BIT(bit)
                          M ;           else
                          M ;WREG_TRACKER &= ~BIT(bit)
                          M ;           endif
                          M ;       else
                          M ;WREG_TRACKER = WREG_UNK
                          M ;       endif
                          M         if BOOL2INT(1)
                          M WREG_TRACKER = IIF(ISLIT(WREG_TRACKER, WREG_TRACKER | BIT(7),   WREG_UNKN);;
                          M         else
                          M WREG_TRACKER = IIF(ISLIT(WREG_TRACKER, WREG_TRACKER & ~BIT(7),   WREG_UNKN);;
                          M         endif
                          M     endif
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
01BB                      M     ORG ctx_addr_120
01BD                      M     ORG ctx_addr_121
                      00233 ;    setbit elapsed_fps, FALSE;
                          M         exitm
01BD   0008           00235     return;
                      00236 ;even_frame:
                      00237 ;use cyan for even frames (heartbeat):
                      00238 ;    set_brkout_px 24+0, FPS, 7, WHITE_RGBINX, CYAN_RGBINX;
                      00239 ;    set_brkout_px 24+1, FPS, 6, WHITE_RGBINX, CYAN_RGBINX;
                      00240 ;    set_brkout_px 24+2, FPS, 5, WHITE_RGBINX, CYAN_RGBINX;
                      00241 ;    set_brkout_px 24+3, FPS, 4, WHITE_RGBINX, CYAN_RGBINX;
                      00242 ;    set_brkout_px 24+4, FPS, 3, WHITE_RGBINX, CYAN_RGBINX;
                      00243 ;    set_brkout_px 24+5, FPS, 2, WHITE_RGBINX, CYAN_RGBINX;
                      00244 ;    set_brkout_px 24+6, FPS, 1, WHITE_RGBINX, CYAN_RGBINX;
                      00245 ;    set_brkout_px 24+7, FPS, 0, WHITE_RGBINX, CYAN_RGBINX;
                      00246 ;    mov8 FPS, LITERAL(0);
                      00247 ;    wait4frame YIELD, YIELD_AGAIN; 1 sec
                      00248 ;    wait4render YIELD, YIELD_AGAIN; don't change breakout px while being rendered
                      00249 ;use magenta for odd frames (heartbeat):
                      00250 ;    set_brkout_px 24+0, FPS, 7, WHITE_RGBINX, MAGENTA_RGBINX;
                      00251 ;    set_brkout_px 24+1, FPS, 6, WHITE_RGBINX, MAGENTA_RGBINX;
                      00252 ;    set_brkout_px 24+2, FPS, 5, WHITE_RGBINX, MAGENTA_RGBINX;
                      00253 ;    set_brkout_px 24+3, FPS, 4, WHITE_RGBINX, MAGENTA_RGBINX;
                      00254 ;    set_brkout_px 24+4, FPS, 3, WHITE_RGBINX, MAGENTA_RGBINX;
                      00255 ;    set_brkout_px 24+5, FPS, 2, WHITE_RGBINX, MAGENTA_RGBINX;
                      00256 ;    set_brkout_px 24+6, FPS, 1, WHITE_RGBINX, MAGENTA_RGBINX;
                      00257 ;    set_brkout_px 24+7, FPS, 0, WHITE_RGBINX, MAGENTA_RGBINX;
                      00258 
                      00259 
                      00260 ;show a little animation on power-up:
                      00261 ;NOTE: this interferes with FPS tracking; use only at startup
                      00262 ;use FSR1 to set animation, FSR0 to send it
                      00263 brkout_ani: DROP_CONTEXT;
                      00264 ;    call blink2;
                      00265 ;    call breakout_reset;
                      00266 ;    call wait_1sec;
                      00267 ;    call blink2;
                      00268 ;    fps_init 250 msec;
                      00269     fps_init 100 msec; CAUTION: reusing FPS timer
Message[301]: MESSAGE: ([TODO] change this to use postscaler 1..16 instead of just powers of 2 (for more accuracy) @1055)
Message[301]: MESSAGE: ([DEBUG] fps_init 100000 (111111 tuned) "usec": "prescaler" 12+0, max intv 131072, actual 111104, rollover 217 @1071)
01BE   014B               M     banksel T0CON0
01BF   019E               M     clrf T0CON0
01C0   304C               M     movlw (((ASM_MSB | (b'010' << T0CS0 | 0 | _5064PRESCALER << T0CKPS0))) & ~ASM_MSB)
01C1   009F               M     movwf T0CON1
01C2   019C               M     clrf TMR0L
01C3   30D8               M     movlw (((ASM_MSB | (_5064ROLLOVER - 1))) & ~ASM_MSB)
01C4   009D               M     movwf TMR0H
                          M     withbit_7 bsf T0CON0
01C5   179E               M     bsf T0CON0, 7
01C6   014E               M     banksel PIR0
                          M     withbit_5 bcf PIR0
01C7   128C               M     bcf PIR0, 5
                          M             exitm
                      00270     mov16 FSR1, LITERAL(brkoutpx);;
01C8   3020               M     movlw (((ASM_MSB | (_5175SRC & 0xFF))) & ~ASM_MSB)
01C9   0086               M     movwf FSR1
01CA   0187               M     clrf FSR10hi
                      00271     MOVLW OFF_RGBINX;
01CB   3000               M     movlw OFF_RGBINX
01CC                  00272 off_loop: ;DROP_CONTEXT;
                      00273     mov8 INDF1_postinc, WREG; LITERAL(OFF_RGBINX);
01CC   001E               M     MOVWI_1_2
                      00274 ;    ifbit FSR0L, log2(END_DETECT), !(ENDOF(brkoutpx) & END_DETECT), goto off_loop;
                      00275     ifbit FSR1L, breakout_eof(FALSE), GOTO off_loop;
                          M     goto_pagesafe off_loop
                          M ;    EXPAND_PUSH FALSE
                          M ; messg here1 @2947
                          M     ERRIF(LITPAGEOF(off_loop), [ERROR] "dest" off_loop 460 !on page 0: 0                @2948)
                          M ; messg here2 @2949
                          M ;PAGESEL_DROP += 1
                          M ;    messg goto dest, page tracker #v(PAGE_TRACKER), need page sel? #v(LITPAGEOF(dest)) != #v(LITPAGEOF(PAGE_TRACKER))? #v(LITPAGEOF(dest) != LITPAGEOF(PAGE_TRACKER))
                          M     if LITPAGEOF(off_loop) != LITPAGEOF(PAGE_TRACKER)
                          M         EMIT CLRF PCLATH; PAGESEL dest; kludge: mpasm doesn't want to pagesel
                          M PAGESEL_KEEP += 1
                          M     else
  00000025                M PAGESEL_DROP += 1
                          M     endif
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M ; messg here3 @2959
                          M     EMIT goto off_loop; PROGDCL 0x2000 | (dest); call dest
01CE   29CC               M     goto off_loop
  000001CC                M PAGE_TRACKER = off_loop;
                          M ; messg here4 @2962
                          M ;    NOEXPAND
                          M ;not needed: fall-thru would be handled by earlier code    DROP_CONTEXT; BSR and WREG unknown here if dest falls through
                          M ;    EXPAND_POP
01CD                      M     ORG ctx_addr_122
01CF                      M     ORG ctx_addr_123
                      00276     CALL ani_delay;
01CF   2289               M     call ani_delay
                      00277 #if 0
                      00278     messg REMOVE THIS
                      00279     mov8 brkoutpx+0, LITERAL(RED_RGBINX);;
                      00280     CALL ani_delay;
                      00281     mov8 brkoutpx+8, LITERAL(GREEN_RGBINX);;
                      00282     CALL ani_delay;
                      00283     mov8 brkoutpx+16, LITERAL(BLUE_RGBINX);;
                      00284     CALL ani_delay;
                      00285     mov8 brkoutpx+24, LITERAL(YELLOW_RGBINX);;
                      00286     CALL ani_delay;
                      00287     mov8 brkoutpx+0, LITERAL(OFF_RGBINX);;
                      00288     mov8 brkoutpx+8, LITERAL(OFF_RGBINX);;
                      00289     mov8 brkoutpx+16, LITERAL(OFF_RGBINX);;
                      00290     mov8 brkoutpx+24, LITERAL(OFF_RGBINX);;
                      00291     return;
                      00292 #endif
                      00293     mov16 FSR1, LITERAL(brkoutpx);;
01D0   3020               M     movlw (((ASM_MSB | (_5270SRC & 0xFF))) & ~ASM_MSB)
01D1   0086               M     movwf FSR1
01D2   0187               M     clrf FSR10hi
01D3                  00294 red_ani: ;DROP_CONTEXT;
                      00295     mov8 INDF1_postinc, LITERAL(RED_RGBINX);;
01D3   3004               M     movlw (((ASM_MSB | (RED_RGBINX))) & ~ASM_MSB)
01D4   001E               M     MOVWI_1_2
                      00296     CALL ani_delay;
01D5   2289               M     call ani_delay
                      00297     ifbit FSR1L, log2(8), !((brkoutpx + 8) & 8), GOTO red_ani; still doing first byte
                          M     goto_pagesafe red_ani
                          M ;    EXPAND_PUSH FALSE
                          M ; messg here1 @2947
                          M     ERRIF(LITPAGEOF(red_ani), [ERROR] "dest" red_ani 467 !on page 0: 0                  @2948)
                          M ; messg here2 @2949
                          M ;PAGESEL_DROP += 1
                          M ;    messg goto dest, page tracker #v(PAGE_TRACKER), need page sel? #v(LITPAGEOF(dest)) != #v(LITPAGEOF(PAGE_TRACKER))? #v(LITPAGEOF(dest) != LITPAGEOF(PAGE_TRACKER))
                          M     if LITPAGEOF(red_ani) != LITPAGEOF(PAGE_TRACKER)
                          M         EMIT CLRF PCLATH; PAGESEL dest; kludge: mpasm doesn't want to pagesel
                          M PAGESEL_KEEP += 1
                          M     else
  00000028                M PAGESEL_DROP += 1
                          M     endif
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M ; messg here3 @2959
                          M     EMIT goto red_ani; PROGDCL 0x2000 | (dest); call dest
01D7   29D3               M     goto red_ani
  000001D3                M PAGE_TRACKER = red_ani;
                          M ; messg here4 @2962
                          M ;    NOEXPAND
                          M ;not needed: fall-thru would be handled by earlier code    DROP_CONTEXT; BSR and WREG unknown here if dest falls through
                          M ;    EXPAND_POP
01D6                      M     ORG ctx_addr_124
01D8                      M     ORG ctx_addr_125
01D8                  00298 green_ani: ;DROP_CONTEXT;
                      00299     mov8 INDF1_postinc, LITERAL(GREEN_RGBINX);;
01D8   3002               M     movlw (((ASM_MSB | (GREEN_RGBINX))) & ~ASM_MSB)
01D9   001E               M     MOVWI_1_2
                      00300     CALL ani_delay;
01DA   2289               M     call ani_delay
                      00301     ifbit FSR1L, log2(16), !((brkoutpx + 16) & 16), GOTO green_ani; still doing second byte
                          M     goto_pagesafe green_ani
                          M ;    EXPAND_PUSH FALSE
                          M ; messg here1 @2947
                          M     ERRIF(LITPAGEOF(green_ani), [ERROR] "dest" green_ani 472 !on page 0: 0              @2948)
                          M ; messg here2 @2949
                          M ;PAGESEL_DROP += 1
                          M ;    messg goto dest, page tracker #v(PAGE_TRACKER), need page sel? #v(LITPAGEOF(dest)) != #v(LITPAGEOF(PAGE_TRACKER))? #v(LITPAGEOF(dest) != LITPAGEOF(PAGE_TRACKER))
                          M     if LITPAGEOF(green_ani) != LITPAGEOF(PAGE_TRACKER)
                          M         EMIT CLRF PCLATH; PAGESEL dest; kludge: mpasm doesn't want to pagesel
                          M PAGESEL_KEEP += 1
                          M     else
  0000002A                M PAGESEL_DROP += 1
                          M     endif
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M ; messg here3 @2959
                          M     EMIT goto green_ani; PROGDCL 0x2000 | (dest); call dest
01DC   29D8               M     goto green_ani
  000001D8                M PAGE_TRACKER = green_ani;
                          M ; messg here4 @2962
                          M ;    NOEXPAND
                          M ;not needed: fall-thru would be handled by earlier code    DROP_CONTEXT; BSR and WREG unknown here if dest falls through
                          M ;    EXPAND_POP
01DB                      M     ORG ctx_addr_126
01DD                      M     ORG ctx_addr_127
01DD                  00302 blue_ani: ;DROP_CONTEXT;
                      00303     mov8 INDF1_postinc, LITERAL(BLUE_RGBINX);;
01DD   3001               M     movlw (((ASM_MSB | (BLUE_RGBINX))) & ~ASM_MSB)
01DE   001E               M     MOVWI_1_2
                      00304     CALL ani_delay;
01DF   2289               M     call ani_delay
                      00305     ifbit FSR1L, log2(8), !((brkoutpx + 24) & 8), GOTO blue_ani; still doing third byte
                          M     goto_pagesafe blue_ani
                          M ;    EXPAND_PUSH FALSE
                          M ; messg here1 @2947
                          M     ERRIF(LITPAGEOF(blue_ani), [ERROR] "dest" blue_ani 477 !on page 0: 0                @2948)
                          M ; messg here2 @2949
                          M ;PAGESEL_DROP += 1
                          M ;    messg goto dest, page tracker #v(PAGE_TRACKER), need page sel? #v(LITPAGEOF(dest)) != #v(LITPAGEOF(PAGE_TRACKER))? #v(LITPAGEOF(dest) != LITPAGEOF(PAGE_TRACKER))
                          M     if LITPAGEOF(blue_ani) != LITPAGEOF(PAGE_TRACKER)
                          M         EMIT CLRF PCLATH; PAGESEL dest; kludge: mpasm doesn't want to pagesel
                          M PAGESEL_KEEP += 1
                          M     else
  0000002C                M PAGESEL_DROP += 1
                          M     endif
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M ; messg here3 @2959
                          M     EMIT goto blue_ani; PROGDCL 0x2000 | (dest); call dest
01E1   29DD               M     goto blue_ani
  000001DD                M PAGE_TRACKER = blue_ani;
                          M ; messg here4 @2962
                          M ;    NOEXPAND
                          M ;not needed: fall-thru would be handled by earlier code    DROP_CONTEXT; BSR and WREG unknown here if dest falls through
                          M ;    EXPAND_POP
01E0                      M     ORG ctx_addr_128
01E2                      M     ORG ctx_addr_129
01E2                  00306 fps_ani: ;DROP_CONTEXT;
                      00307     mov8 INDF1_postinc, LITERAL(FPS_RGBINX);;
01E2   3003               M     movlw (((ASM_MSB | (FPS_RGBINX))) & ~ASM_MSB)
01E3   001E               M     MOVWI_1_2
                      00308     CALL ani_delay;
01E4   2289               M     call ani_delay
                      00309     ifbit FSR1L, log2(64), !((brkoutpx + 32) & 64), GOTO fps_ani; still doing fourth byte
                          M     goto_pagesafe fps_ani
                          M ;    EXPAND_PUSH FALSE
                          M ; messg here1 @2947
                          M     ERRIF(LITPAGEOF(fps_ani), [ERROR] "dest" fps_ani 482 !on page 0: 0                  @2948)
                          M ; messg here2 @2949
                          M ;PAGESEL_DROP += 1
                          M ;    messg goto dest, page tracker #v(PAGE_TRACKER), need page sel? #v(LITPAGEOF(dest)) != #v(LITPAGEOF(PAGE_TRACKER))? #v(LITPAGEOF(dest) != LITPAGEOF(PAGE_TRACKER))
                          M     if LITPAGEOF(fps_ani) != LITPAGEOF(PAGE_TRACKER)
                          M         EMIT CLRF PCLATH; PAGESEL dest; kludge: mpasm doesn't want to pagesel
                          M PAGESEL_KEEP += 1
                          M     else
  0000002E                M PAGESEL_DROP += 1
                          M     endif
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M ; messg here3 @2959
                          M     EMIT goto fps_ani; PROGDCL 0x2000 | (dest); call dest
01E6   29E2               M     goto fps_ani
  000001E2                M PAGE_TRACKER = fps_ani;
                          M ; messg here4 @2962
                          M ;    NOEXPAND
                          M ;not needed: fall-thru would be handled by earlier code    DROP_CONTEXT; BSR and WREG unknown here if dest falls through
                          M ;    EXPAND_POP
01E5                      M     ORG ctx_addr_130
01E7                      M     ORG ctx_addr_131
                      00310     fps_init 500 msec;
Message[301]: MESSAGE: ([TODO] change this to use postscaler 1..16 instead of just powers of 2 (for more accuracy) @1055)
Message[301]: MESSAGE: ([DEBUG] fps_init 500000 (555555 tuned) "usec": "prescaler" 15+0, max intv 1048576, actual 557056, rollover 136 @1071)
01E7   014B               M     banksel T0CON0
01E8   019E               M     clrf T0CON0
01E9   304F               M     movlw (((ASM_MSB | (b'010' << T0CS0 | 0 | _5539PRESCALER << T0CKPS0))) & ~ASM_MSB)
01EA   009F               M     movwf T0CON1
01EB   019C               M     clrf TMR0L
01EC   3087               M     movlw (((ASM_MSB | (_5539ROLLOVER - 1))) & ~ASM_MSB)
01ED   009D               M     movwf TMR0H
                          M     withbit_7 bsf T0CON0
01EE   179E               M     bsf T0CON0, 7
01EF   014E               M     banksel PIR0
                          M     withbit_5 bcf PIR0
01F0   128C               M     bcf PIR0, 5
                          M             exitm
01F1                  00311 alt_loop:
                      00312     MOVLW WHITE_RGBINX;
01F1   3007               M     movlw WHITE_RGBINX
                      00313     REPEAT LITERAL(32/2), MOVWF brkoutpx + REPEATER * 2; set "on" color every other px
  00000010                M _5657COUNT = (((ASM_MSB | (32/2))) & ~ASM_MSB)
                          M     movwf_banksafe brkoutpx + REPEATER * 2
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + REPEATER * 2
01F2   0140               M     banksel brkoutpx + REPEATER * 2
                          M     BANKSAFE EMIT movwf brkoutpx + REPEATER * 2;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf brkoutpx + REPEATER * 2
01F3   00A0               M     movwf brkoutpx + REPEATER * 2
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    EXPAND_POP
                          M     movwf_banksafe brkoutpx + REPEATER * 2
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + REPEATER * 2
                          M     BANKSAFE EMIT movwf brkoutpx + REPEATER * 2;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf brkoutpx + REPEATER * 2
01F4   00A2               M     movwf brkoutpx + REPEATER * 2
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    EXPAND_POP
                          M     movwf_banksafe brkoutpx + REPEATER * 2
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + REPEATER * 2
                          M     BANKSAFE EMIT movwf brkoutpx + REPEATER * 2;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf brkoutpx + REPEATER * 2
01F5   00A4               M     movwf brkoutpx + REPEATER * 2
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    EXPAND_POP
                          M     movwf_banksafe brkoutpx + REPEATER * 2
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + REPEATER * 2
                          M     BANKSAFE EMIT movwf brkoutpx + REPEATER * 2;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf brkoutpx + REPEATER * 2
01F6   00A6               M     movwf brkoutpx + REPEATER * 2
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    EXPAND_POP
                          M     movwf_banksafe brkoutpx + REPEATER * 2
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + REPEATER * 2
                          M     BANKSAFE EMIT movwf brkoutpx + REPEATER * 2;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf brkoutpx + REPEATER * 2
01F7   00A8               M     movwf brkoutpx + REPEATER * 2
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    EXPAND_POP
                          M     movwf_banksafe brkoutpx + REPEATER * 2
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + REPEATER * 2
                          M     BANKSAFE EMIT movwf brkoutpx + REPEATER * 2;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf brkoutpx + REPEATER * 2
01F8   00AA               M     movwf brkoutpx + REPEATER * 2
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    EXPAND_POP
                          M     movwf_banksafe brkoutpx + REPEATER * 2
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + REPEATER * 2
                          M     BANKSAFE EMIT movwf brkoutpx + REPEATER * 2;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf brkoutpx + REPEATER * 2
01F9   00AC               M     movwf brkoutpx + REPEATER * 2
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    EXPAND_POP
                          M     movwf_banksafe brkoutpx + REPEATER * 2
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + REPEATER * 2
                          M     BANKSAFE EMIT movwf brkoutpx + REPEATER * 2;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf brkoutpx + REPEATER * 2
01FA   00AE               M     movwf brkoutpx + REPEATER * 2
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    EXPAND_POP
                          M     movwf_banksafe brkoutpx + REPEATER * 2
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + REPEATER * 2
                          M     BANKSAFE EMIT movwf brkoutpx + REPEATER * 2;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf brkoutpx + REPEATER * 2
01FB   00B0               M     movwf brkoutpx + REPEATER * 2
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    EXPAND_POP
                          M     movwf_banksafe brkoutpx + REPEATER * 2
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + REPEATER * 2
                          M     BANKSAFE EMIT movwf brkoutpx + REPEATER * 2;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf brkoutpx + REPEATER * 2
01FC   00B2               M     movwf brkoutpx + REPEATER * 2
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    EXPAND_POP
                          M     movwf_banksafe brkoutpx + REPEATER * 2
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + REPEATER * 2
                          M     BANKSAFE EMIT movwf brkoutpx + REPEATER * 2;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf brkoutpx + REPEATER * 2
01FD   00B4               M     movwf brkoutpx + REPEATER * 2
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    EXPAND_POP
                          M     movwf_banksafe brkoutpx + REPEATER * 2
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + REPEATER * 2
                          M     BANKSAFE EMIT movwf brkoutpx + REPEATER * 2;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf brkoutpx + REPEATER * 2
01FE   00B6               M     movwf brkoutpx + REPEATER * 2
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    EXPAND_POP
                          M     movwf_banksafe brkoutpx + REPEATER * 2
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + REPEATER * 2
                          M     BANKSAFE EMIT movwf brkoutpx + REPEATER * 2;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf brkoutpx + REPEATER * 2
01FF   00B8               M     movwf brkoutpx + REPEATER * 2
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    EXPAND_POP
                          M     movwf_banksafe brkoutpx + REPEATER * 2
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + REPEATER * 2
                          M     BANKSAFE EMIT movwf brkoutpx + REPEATER * 2;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf brkoutpx + REPEATER * 2
0200   00BA               M     movwf brkoutpx + REPEATER * 2
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    EXPAND_POP
                          M     movwf_banksafe brkoutpx + REPEATER * 2
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + REPEATER * 2
                          M     BANKSAFE EMIT movwf brkoutpx + REPEATER * 2;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf brkoutpx + REPEATER * 2
0201   00BC               M     movwf brkoutpx + REPEATER * 2
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    EXPAND_POP
                          M     movwf_banksafe brkoutpx + REPEATER * 2
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + REPEATER * 2
                          M     BANKSAFE EMIT movwf brkoutpx + REPEATER * 2;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT movwf brkoutpx + REPEATER * 2
0202   00BE               M     movwf brkoutpx + REPEATER * 2
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    EXPAND_POP
                      00314     CALL ani_delay;
0203   2289               M     call ani_delay
                      00315     REPEAT LITERAL(32/2), swap_pair REPEATER * 2; alternate
  00000010                M _5952COUNT = (((ASM_MSB | (32/2))) & ~ASM_MSB)
                          M     swap_pair REPEATER * 2
                          M     swapreg brkoutpx + REPEATER * 2, brkoutpx + (REPEATER * 2 ^ 1)
                          M ;    EXPAND_PUSH FALSE
                          M     if (brkoutpx + (REPEATER * 2 ^ 1)) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; reg ^ WREG
                          M         XORWF brkoutpx + REPEATER * 2, F; reg ^ (reg ^ WREG) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; WREG ^ (reg ^ WREG) == reg
                          M     else
                          M         if (brkoutpx + REPEATER * 2) != WREG
                          M             MOVF brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + REPEATER * 2
0204   0140               M     banksel brkoutpx + REPEATER * 2
                          M     BANKSAFE EMIT dest_arg(W)    movf brkoutpx + REPEATER * 2;, dest;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT withdest_0 movf brkoutpx + REPEATER * 2
                          M     withdest_0 movf brkoutpx + REPEATER * 2
0205   0820               M     movf brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    if (reg == WREG) || !BOOL2INT(dest)
                          M     if !BOOL2INT(W)
  00000020                M WREG_TRACKER = brkoutpx + REPEATER * 2; IIF(ISLIT(WREG_TRACKER), WREG_TRACKER + 1, WREG_UNKN)
                          M     endif
                          M ;    EXPAND_POP
                          M         endif
0206   0621               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), W; reg ^ WREG
0207   06A1               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), F; reg ^ (reg ^ WREG) == WREG
0208   06A0               M         XORWF brkoutpx + REPEATER * 2, F; WREG ^ (reg ^ WREG) == reg
                          M     endif
                          M ;    EXPAND_POP
                          M     swap_pair REPEATER * 2
                          M     swapreg brkoutpx + REPEATER * 2, brkoutpx + (REPEATER * 2 ^ 1)
                          M ;    EXPAND_PUSH FALSE
                          M     if (brkoutpx + (REPEATER * 2 ^ 1)) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; reg ^ WREG
                          M         XORWF brkoutpx + REPEATER * 2, F; reg ^ (reg ^ WREG) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; WREG ^ (reg ^ WREG) == reg
                          M     else
                          M         if (brkoutpx + REPEATER * 2) != WREG
                          M             MOVF brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + REPEATER * 2
                          M     BANKSAFE EMIT dest_arg(W)    movf brkoutpx + REPEATER * 2;, dest;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT withdest_0 movf brkoutpx + REPEATER * 2
                          M     withdest_0 movf brkoutpx + REPEATER * 2
0209   0822               M     movf brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    if (reg == WREG) || !BOOL2INT(dest)
                          M     if !BOOL2INT(W)
  00000022                M WREG_TRACKER = brkoutpx + REPEATER * 2; IIF(ISLIT(WREG_TRACKER), WREG_TRACKER + 1, WREG_UNKN)
                          M     endif
                          M ;    EXPAND_POP
                          M         endif
020A   0623               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), W; reg ^ WREG
020B   06A3               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), F; reg ^ (reg ^ WREG) == WREG
020C   06A2               M         XORWF brkoutpx + REPEATER * 2, F; WREG ^ (reg ^ WREG) == reg
                          M     endif
                          M ;    EXPAND_POP
                          M     swap_pair REPEATER * 2
                          M     swapreg brkoutpx + REPEATER * 2, brkoutpx + (REPEATER * 2 ^ 1)
                          M ;    EXPAND_PUSH FALSE
                          M     if (brkoutpx + (REPEATER * 2 ^ 1)) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; reg ^ WREG
                          M         XORWF brkoutpx + REPEATER * 2, F; reg ^ (reg ^ WREG) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; WREG ^ (reg ^ WREG) == reg
                          M     else
                          M         if (brkoutpx + REPEATER * 2) != WREG
                          M             MOVF brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + REPEATER * 2
                          M     BANKSAFE EMIT dest_arg(W)    movf brkoutpx + REPEATER * 2;, dest;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT withdest_0 movf brkoutpx + REPEATER * 2
                          M     withdest_0 movf brkoutpx + REPEATER * 2
020D   0824               M     movf brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    if (reg == WREG) || !BOOL2INT(dest)
                          M     if !BOOL2INT(W)
  00000024                M WREG_TRACKER = brkoutpx + REPEATER * 2; IIF(ISLIT(WREG_TRACKER), WREG_TRACKER + 1, WREG_UNKN)
                          M     endif
                          M ;    EXPAND_POP
                          M         endif
020E   0625               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), W; reg ^ WREG
020F   06A5               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), F; reg ^ (reg ^ WREG) == WREG
0210   06A4               M         XORWF brkoutpx + REPEATER * 2, F; WREG ^ (reg ^ WREG) == reg
                          M     endif
                          M ;    EXPAND_POP
                          M     swap_pair REPEATER * 2
                          M     swapreg brkoutpx + REPEATER * 2, brkoutpx + (REPEATER * 2 ^ 1)
                          M ;    EXPAND_PUSH FALSE
                          M     if (brkoutpx + (REPEATER * 2 ^ 1)) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; reg ^ WREG
                          M         XORWF brkoutpx + REPEATER * 2, F; reg ^ (reg ^ WREG) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; WREG ^ (reg ^ WREG) == reg
                          M     else
                          M         if (brkoutpx + REPEATER * 2) != WREG
                          M             MOVF brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + REPEATER * 2
                          M     BANKSAFE EMIT dest_arg(W)    movf brkoutpx + REPEATER * 2;, dest;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT withdest_0 movf brkoutpx + REPEATER * 2
                          M     withdest_0 movf brkoutpx + REPEATER * 2
0211   0826               M     movf brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    if (reg == WREG) || !BOOL2INT(dest)
                          M     if !BOOL2INT(W)
  00000026                M WREG_TRACKER = brkoutpx + REPEATER * 2; IIF(ISLIT(WREG_TRACKER), WREG_TRACKER + 1, WREG_UNKN)
                          M     endif
                          M ;    EXPAND_POP
                          M         endif
0212   0627               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), W; reg ^ WREG
0213   06A7               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), F; reg ^ (reg ^ WREG) == WREG
0214   06A6               M         XORWF brkoutpx + REPEATER * 2, F; WREG ^ (reg ^ WREG) == reg
                          M     endif
                          M ;    EXPAND_POP
                          M     swap_pair REPEATER * 2
                          M     swapreg brkoutpx + REPEATER * 2, brkoutpx + (REPEATER * 2 ^ 1)
                          M ;    EXPAND_PUSH FALSE
                          M     if (brkoutpx + (REPEATER * 2 ^ 1)) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; reg ^ WREG
                          M         XORWF brkoutpx + REPEATER * 2, F; reg ^ (reg ^ WREG) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; WREG ^ (reg ^ WREG) == reg
                          M     else
                          M         if (brkoutpx + REPEATER * 2) != WREG
                          M             MOVF brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + REPEATER * 2
                          M     BANKSAFE EMIT dest_arg(W)    movf brkoutpx + REPEATER * 2;, dest;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT withdest_0 movf brkoutpx + REPEATER * 2
                          M     withdest_0 movf brkoutpx + REPEATER * 2
0215   0828               M     movf brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    if (reg == WREG) || !BOOL2INT(dest)
                          M     if !BOOL2INT(W)
  00000028                M WREG_TRACKER = brkoutpx + REPEATER * 2; IIF(ISLIT(WREG_TRACKER), WREG_TRACKER + 1, WREG_UNKN)
                          M     endif
                          M ;    EXPAND_POP
                          M         endif
0216   0629               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), W; reg ^ WREG
0217   06A9               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), F; reg ^ (reg ^ WREG) == WREG
0218   06A8               M         XORWF brkoutpx + REPEATER * 2, F; WREG ^ (reg ^ WREG) == reg
                          M     endif
                          M ;    EXPAND_POP
                          M     swap_pair REPEATER * 2
                          M     swapreg brkoutpx + REPEATER * 2, brkoutpx + (REPEATER * 2 ^ 1)
                          M ;    EXPAND_PUSH FALSE
                          M     if (brkoutpx + (REPEATER * 2 ^ 1)) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; reg ^ WREG
                          M         XORWF brkoutpx + REPEATER * 2, F; reg ^ (reg ^ WREG) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; WREG ^ (reg ^ WREG) == reg
                          M     else
                          M         if (brkoutpx + REPEATER * 2) != WREG
                          M             MOVF brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + REPEATER * 2
                          M     BANKSAFE EMIT dest_arg(W)    movf brkoutpx + REPEATER * 2;, dest;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT withdest_0 movf brkoutpx + REPEATER * 2
                          M     withdest_0 movf brkoutpx + REPEATER * 2
0219   082A               M     movf brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    if (reg == WREG) || !BOOL2INT(dest)
                          M     if !BOOL2INT(W)
  0000002A                M WREG_TRACKER = brkoutpx + REPEATER * 2; IIF(ISLIT(WREG_TRACKER), WREG_TRACKER + 1, WREG_UNKN)
                          M     endif
                          M ;    EXPAND_POP
                          M         endif
021A   062B               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), W; reg ^ WREG
021B   06AB               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), F; reg ^ (reg ^ WREG) == WREG
021C   06AA               M         XORWF brkoutpx + REPEATER * 2, F; WREG ^ (reg ^ WREG) == reg
                          M     endif
                          M ;    EXPAND_POP
                          M     swap_pair REPEATER * 2
                          M     swapreg brkoutpx + REPEATER * 2, brkoutpx + (REPEATER * 2 ^ 1)
                          M ;    EXPAND_PUSH FALSE
                          M     if (brkoutpx + (REPEATER * 2 ^ 1)) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; reg ^ WREG
                          M         XORWF brkoutpx + REPEATER * 2, F; reg ^ (reg ^ WREG) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; WREG ^ (reg ^ WREG) == reg
                          M     else
                          M         if (brkoutpx + REPEATER * 2) != WREG
                          M             MOVF brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + REPEATER * 2
                          M     BANKSAFE EMIT dest_arg(W)    movf brkoutpx + REPEATER * 2;, dest;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT withdest_0 movf brkoutpx + REPEATER * 2
                          M     withdest_0 movf brkoutpx + REPEATER * 2
021D   082C               M     movf brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    if (reg == WREG) || !BOOL2INT(dest)
                          M     if !BOOL2INT(W)
  0000002C                M WREG_TRACKER = brkoutpx + REPEATER * 2; IIF(ISLIT(WREG_TRACKER), WREG_TRACKER + 1, WREG_UNKN)
                          M     endif
                          M ;    EXPAND_POP
                          M         endif
021E   062D               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), W; reg ^ WREG
021F   06AD               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), F; reg ^ (reg ^ WREG) == WREG
0220   06AC               M         XORWF brkoutpx + REPEATER * 2, F; WREG ^ (reg ^ WREG) == reg
                          M     endif
                          M ;    EXPAND_POP
                          M     swap_pair REPEATER * 2
                          M     swapreg brkoutpx + REPEATER * 2, brkoutpx + (REPEATER * 2 ^ 1)
                          M ;    EXPAND_PUSH FALSE
                          M     if (brkoutpx + (REPEATER * 2 ^ 1)) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; reg ^ WREG
                          M         XORWF brkoutpx + REPEATER * 2, F; reg ^ (reg ^ WREG) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; WREG ^ (reg ^ WREG) == reg
                          M     else
                          M         if (brkoutpx + REPEATER * 2) != WREG
                          M             MOVF brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + REPEATER * 2
                          M     BANKSAFE EMIT dest_arg(W)    movf brkoutpx + REPEATER * 2;, dest;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT withdest_0 movf brkoutpx + REPEATER * 2
                          M     withdest_0 movf brkoutpx + REPEATER * 2
0221   082E               M     movf brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    if (reg == WREG) || !BOOL2INT(dest)
                          M     if !BOOL2INT(W)
  0000002E                M WREG_TRACKER = brkoutpx + REPEATER * 2; IIF(ISLIT(WREG_TRACKER), WREG_TRACKER + 1, WREG_UNKN)
                          M     endif
                          M ;    EXPAND_POP
                          M         endif
0222   062F               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), W; reg ^ WREG
0223   06AF               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), F; reg ^ (reg ^ WREG) == WREG
0224   06AE               M         XORWF brkoutpx + REPEATER * 2, F; WREG ^ (reg ^ WREG) == reg
                          M     endif
                          M ;    EXPAND_POP
                          M     swap_pair REPEATER * 2
                          M     swapreg brkoutpx + REPEATER * 2, brkoutpx + (REPEATER * 2 ^ 1)
                          M ;    EXPAND_PUSH FALSE
                          M     if (brkoutpx + (REPEATER * 2 ^ 1)) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; reg ^ WREG
                          M         XORWF brkoutpx + REPEATER * 2, F; reg ^ (reg ^ WREG) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; WREG ^ (reg ^ WREG) == reg
                          M     else
                          M         if (brkoutpx + REPEATER * 2) != WREG
                          M             MOVF brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + REPEATER * 2
                          M     BANKSAFE EMIT dest_arg(W)    movf brkoutpx + REPEATER * 2;, dest;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT withdest_0 movf brkoutpx + REPEATER * 2
                          M     withdest_0 movf brkoutpx + REPEATER * 2
0225   0830               M     movf brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    if (reg == WREG) || !BOOL2INT(dest)
                          M     if !BOOL2INT(W)
  00000030                M WREG_TRACKER = brkoutpx + REPEATER * 2; IIF(ISLIT(WREG_TRACKER), WREG_TRACKER + 1, WREG_UNKN)
                          M     endif
                          M ;    EXPAND_POP
                          M         endif
0226   0631               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), W; reg ^ WREG
0227   06B1               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), F; reg ^ (reg ^ WREG) == WREG
0228   06B0               M         XORWF brkoutpx + REPEATER * 2, F; WREG ^ (reg ^ WREG) == reg
                          M     endif
                          M ;    EXPAND_POP
                          M     swap_pair REPEATER * 2
                          M     swapreg brkoutpx + REPEATER * 2, brkoutpx + (REPEATER * 2 ^ 1)
                          M ;    EXPAND_PUSH FALSE
                          M     if (brkoutpx + (REPEATER * 2 ^ 1)) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; reg ^ WREG
                          M         XORWF brkoutpx + REPEATER * 2, F; reg ^ (reg ^ WREG) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; WREG ^ (reg ^ WREG) == reg
                          M     else
                          M         if (brkoutpx + REPEATER * 2) != WREG
                          M             MOVF brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + REPEATER * 2
                          M     BANKSAFE EMIT dest_arg(W)    movf brkoutpx + REPEATER * 2;, dest;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT withdest_0 movf brkoutpx + REPEATER * 2
                          M     withdest_0 movf brkoutpx + REPEATER * 2
0229   0832               M     movf brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    if (reg == WREG) || !BOOL2INT(dest)
                          M     if !BOOL2INT(W)
  00000032                M WREG_TRACKER = brkoutpx + REPEATER * 2; IIF(ISLIT(WREG_TRACKER), WREG_TRACKER + 1, WREG_UNKN)
                          M     endif
                          M ;    EXPAND_POP
                          M         endif
022A   0633               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), W; reg ^ WREG
022B   06B3               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), F; reg ^ (reg ^ WREG) == WREG
022C   06B2               M         XORWF brkoutpx + REPEATER * 2, F; WREG ^ (reg ^ WREG) == reg
                          M     endif
                          M ;    EXPAND_POP
                          M     swap_pair REPEATER * 2
                          M     swapreg brkoutpx + REPEATER * 2, brkoutpx + (REPEATER * 2 ^ 1)
                          M ;    EXPAND_PUSH FALSE
                          M     if (brkoutpx + (REPEATER * 2 ^ 1)) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; reg ^ WREG
                          M         XORWF brkoutpx + REPEATER * 2, F; reg ^ (reg ^ WREG) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; WREG ^ (reg ^ WREG) == reg
                          M     else
                          M         if (brkoutpx + REPEATER * 2) != WREG
                          M             MOVF brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + REPEATER * 2
                          M     BANKSAFE EMIT dest_arg(W)    movf brkoutpx + REPEATER * 2;, dest;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT withdest_0 movf brkoutpx + REPEATER * 2
                          M     withdest_0 movf brkoutpx + REPEATER * 2
022D   0834               M     movf brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    if (reg == WREG) || !BOOL2INT(dest)
                          M     if !BOOL2INT(W)
  00000034                M WREG_TRACKER = brkoutpx + REPEATER * 2; IIF(ISLIT(WREG_TRACKER), WREG_TRACKER + 1, WREG_UNKN)
                          M     endif
                          M ;    EXPAND_POP
                          M         endif
022E   0635               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), W; reg ^ WREG
022F   06B5               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), F; reg ^ (reg ^ WREG) == WREG
0230   06B4               M         XORWF brkoutpx + REPEATER * 2, F; WREG ^ (reg ^ WREG) == reg
                          M     endif
                          M ;    EXPAND_POP
                          M     swap_pair REPEATER * 2
                          M     swapreg brkoutpx + REPEATER * 2, brkoutpx + (REPEATER * 2 ^ 1)
                          M ;    EXPAND_PUSH FALSE
                          M     if (brkoutpx + (REPEATER * 2 ^ 1)) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; reg ^ WREG
                          M         XORWF brkoutpx + REPEATER * 2, F; reg ^ (reg ^ WREG) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; WREG ^ (reg ^ WREG) == reg
                          M     else
                          M         if (brkoutpx + REPEATER * 2) != WREG
                          M             MOVF brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + REPEATER * 2
                          M     BANKSAFE EMIT dest_arg(W)    movf brkoutpx + REPEATER * 2;, dest;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT withdest_0 movf brkoutpx + REPEATER * 2
                          M     withdest_0 movf brkoutpx + REPEATER * 2
0231   0836               M     movf brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    if (reg == WREG) || !BOOL2INT(dest)
                          M     if !BOOL2INT(W)
  00000036                M WREG_TRACKER = brkoutpx + REPEATER * 2; IIF(ISLIT(WREG_TRACKER), WREG_TRACKER + 1, WREG_UNKN)
                          M     endif
                          M ;    EXPAND_POP
                          M         endif
0232   0637               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), W; reg ^ WREG
0233   06B7               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), F; reg ^ (reg ^ WREG) == WREG
0234   06B6               M         XORWF brkoutpx + REPEATER * 2, F; WREG ^ (reg ^ WREG) == reg
                          M     endif
                          M ;    EXPAND_POP
                          M     swap_pair REPEATER * 2
                          M     swapreg brkoutpx + REPEATER * 2, brkoutpx + (REPEATER * 2 ^ 1)
                          M ;    EXPAND_PUSH FALSE
                          M     if (brkoutpx + (REPEATER * 2 ^ 1)) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; reg ^ WREG
                          M         XORWF brkoutpx + REPEATER * 2, F; reg ^ (reg ^ WREG) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; WREG ^ (reg ^ WREG) == reg
                          M     else
                          M         if (brkoutpx + REPEATER * 2) != WREG
                          M             MOVF brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + REPEATER * 2
                          M     BANKSAFE EMIT dest_arg(W)    movf brkoutpx + REPEATER * 2;, dest;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT withdest_0 movf brkoutpx + REPEATER * 2
                          M     withdest_0 movf brkoutpx + REPEATER * 2
0235   0838               M     movf brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    if (reg == WREG) || !BOOL2INT(dest)
                          M     if !BOOL2INT(W)
  00000038                M WREG_TRACKER = brkoutpx + REPEATER * 2; IIF(ISLIT(WREG_TRACKER), WREG_TRACKER + 1, WREG_UNKN)
                          M     endif
                          M ;    EXPAND_POP
                          M         endif
0236   0639               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), W; reg ^ WREG
0237   06B9               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), F; reg ^ (reg ^ WREG) == WREG
0238   06B8               M         XORWF brkoutpx + REPEATER * 2, F; WREG ^ (reg ^ WREG) == reg
                          M     endif
                          M ;    EXPAND_POP
                          M     swap_pair REPEATER * 2
                          M     swapreg brkoutpx + REPEATER * 2, brkoutpx + (REPEATER * 2 ^ 1)
                          M ;    EXPAND_PUSH FALSE
                          M     if (brkoutpx + (REPEATER * 2 ^ 1)) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; reg ^ WREG
                          M         XORWF brkoutpx + REPEATER * 2, F; reg ^ (reg ^ WREG) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; WREG ^ (reg ^ WREG) == reg
                          M     else
                          M         if (brkoutpx + REPEATER * 2) != WREG
                          M             MOVF brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + REPEATER * 2
                          M     BANKSAFE EMIT dest_arg(W)    movf brkoutpx + REPEATER * 2;, dest;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT withdest_0 movf brkoutpx + REPEATER * 2
                          M     withdest_0 movf brkoutpx + REPEATER * 2
0239   083A               M     movf brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    if (reg == WREG) || !BOOL2INT(dest)
                          M     if !BOOL2INT(W)
  0000003A                M WREG_TRACKER = brkoutpx + REPEATER * 2; IIF(ISLIT(WREG_TRACKER), WREG_TRACKER + 1, WREG_UNKN)
                          M     endif
                          M ;    EXPAND_POP
                          M         endif
023A   063B               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), W; reg ^ WREG
023B   06BB               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), F; reg ^ (reg ^ WREG) == WREG
023C   06BA               M         XORWF brkoutpx + REPEATER * 2, F; WREG ^ (reg ^ WREG) == reg
                          M     endif
                          M ;    EXPAND_POP
                          M     swap_pair REPEATER * 2
                          M     swapreg brkoutpx + REPEATER * 2, brkoutpx + (REPEATER * 2 ^ 1)
                          M ;    EXPAND_PUSH FALSE
                          M     if (brkoutpx + (REPEATER * 2 ^ 1)) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; reg ^ WREG
                          M         XORWF brkoutpx + REPEATER * 2, F; reg ^ (reg ^ WREG) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; WREG ^ (reg ^ WREG) == reg
                          M     else
                          M         if (brkoutpx + REPEATER * 2) != WREG
                          M             MOVF brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + REPEATER * 2
                          M     BANKSAFE EMIT dest_arg(W)    movf brkoutpx + REPEATER * 2;, dest;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT withdest_0 movf brkoutpx + REPEATER * 2
                          M     withdest_0 movf brkoutpx + REPEATER * 2
023D   083C               M     movf brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    if (reg == WREG) || !BOOL2INT(dest)
                          M     if !BOOL2INT(W)
  0000003C                M WREG_TRACKER = brkoutpx + REPEATER * 2; IIF(ISLIT(WREG_TRACKER), WREG_TRACKER + 1, WREG_UNKN)
                          M     endif
                          M ;    EXPAND_POP
                          M         endif
023E   063D               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), W; reg ^ WREG
023F   06BD               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), F; reg ^ (reg ^ WREG) == WREG
0240   06BC               M         XORWF brkoutpx + REPEATER * 2, F; WREG ^ (reg ^ WREG) == reg
                          M     endif
                          M ;    EXPAND_POP
                          M     swap_pair REPEATER * 2
                          M     swapreg brkoutpx + REPEATER * 2, brkoutpx + (REPEATER * 2 ^ 1)
                          M ;    EXPAND_PUSH FALSE
                          M     if (brkoutpx + (REPEATER * 2 ^ 1)) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; reg ^ WREG
                          M         XORWF brkoutpx + REPEATER * 2, F; reg ^ (reg ^ WREG) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; WREG ^ (reg ^ WREG) == reg
                          M     else
                          M         if (brkoutpx + REPEATER * 2) != WREG
                          M             MOVF brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + REPEATER * 2
                          M     BANKSAFE EMIT dest_arg(W)    movf brkoutpx + REPEATER * 2;, dest;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT withdest_0 movf brkoutpx + REPEATER * 2
                          M     withdest_0 movf brkoutpx + REPEATER * 2
0241   083E               M     movf brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    if (reg == WREG) || !BOOL2INT(dest)
                          M     if !BOOL2INT(W)
  0000003E                M WREG_TRACKER = brkoutpx + REPEATER * 2; IIF(ISLIT(WREG_TRACKER), WREG_TRACKER + 1, WREG_UNKN)
                          M     endif
                          M ;    EXPAND_POP
                          M         endif
0242   063F               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), W; reg ^ WREG
0243   06BF               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), F; reg ^ (reg ^ WREG) == WREG
0244   06BE               M         XORWF brkoutpx + REPEATER * 2, F; WREG ^ (reg ^ WREG) == reg
                          M     endif
                          M ;    EXPAND_POP
                      00316     CALL ani_delay;
0245   2289               M     call ani_delay
                      00317     REPEAT LITERAL(32/2), swap_pair REPEATER * 2; alternate
  00000010                M _6295COUNT = (((ASM_MSB | (32/2))) & ~ASM_MSB)
                          M     swap_pair REPEATER * 2
                          M     swapreg brkoutpx + REPEATER * 2, brkoutpx + (REPEATER * 2 ^ 1)
                          M ;    EXPAND_PUSH FALSE
                          M     if (brkoutpx + (REPEATER * 2 ^ 1)) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; reg ^ WREG
                          M         XORWF brkoutpx + REPEATER * 2, F; reg ^ (reg ^ WREG) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; WREG ^ (reg ^ WREG) == reg
                          M     else
                          M         if (brkoutpx + REPEATER * 2) != WREG
                          M             MOVF brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + REPEATER * 2
0246   0140               M     banksel brkoutpx + REPEATER * 2
                          M     BANKSAFE EMIT dest_arg(W)    movf brkoutpx + REPEATER * 2;, dest;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT withdest_0 movf brkoutpx + REPEATER * 2
                          M     withdest_0 movf brkoutpx + REPEATER * 2
0247   0820               M     movf brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    if (reg == WREG) || !BOOL2INT(dest)
                          M     if !BOOL2INT(W)
  00000020                M WREG_TRACKER = brkoutpx + REPEATER * 2; IIF(ISLIT(WREG_TRACKER), WREG_TRACKER + 1, WREG_UNKN)
                          M     endif
                          M ;    EXPAND_POP
                          M         endif
0248   0621               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), W; reg ^ WREG
0249   06A1               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), F; reg ^ (reg ^ WREG) == WREG
024A   06A0               M         XORWF brkoutpx + REPEATER * 2, F; WREG ^ (reg ^ WREG) == reg
                          M     endif
                          M ;    EXPAND_POP
                          M     swap_pair REPEATER * 2
                          M     swapreg brkoutpx + REPEATER * 2, brkoutpx + (REPEATER * 2 ^ 1)
                          M ;    EXPAND_PUSH FALSE
                          M     if (brkoutpx + (REPEATER * 2 ^ 1)) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; reg ^ WREG
                          M         XORWF brkoutpx + REPEATER * 2, F; reg ^ (reg ^ WREG) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; WREG ^ (reg ^ WREG) == reg
                          M     else
                          M         if (brkoutpx + REPEATER * 2) != WREG
                          M             MOVF brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + REPEATER * 2
                          M     BANKSAFE EMIT dest_arg(W)    movf brkoutpx + REPEATER * 2;, dest;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT withdest_0 movf brkoutpx + REPEATER * 2
                          M     withdest_0 movf brkoutpx + REPEATER * 2
024B   0822               M     movf brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    if (reg == WREG) || !BOOL2INT(dest)
                          M     if !BOOL2INT(W)
  00000022                M WREG_TRACKER = brkoutpx + REPEATER * 2; IIF(ISLIT(WREG_TRACKER), WREG_TRACKER + 1, WREG_UNKN)
                          M     endif
                          M ;    EXPAND_POP
                          M         endif
024C   0623               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), W; reg ^ WREG
024D   06A3               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), F; reg ^ (reg ^ WREG) == WREG
024E   06A2               M         XORWF brkoutpx + REPEATER * 2, F; WREG ^ (reg ^ WREG) == reg
                          M     endif
                          M ;    EXPAND_POP
                          M     swap_pair REPEATER * 2
                          M     swapreg brkoutpx + REPEATER * 2, brkoutpx + (REPEATER * 2 ^ 1)
                          M ;    EXPAND_PUSH FALSE
                          M     if (brkoutpx + (REPEATER * 2 ^ 1)) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; reg ^ WREG
                          M         XORWF brkoutpx + REPEATER * 2, F; reg ^ (reg ^ WREG) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; WREG ^ (reg ^ WREG) == reg
                          M     else
                          M         if (brkoutpx + REPEATER * 2) != WREG
                          M             MOVF brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + REPEATER * 2
                          M     BANKSAFE EMIT dest_arg(W)    movf brkoutpx + REPEATER * 2;, dest;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT withdest_0 movf brkoutpx + REPEATER * 2
                          M     withdest_0 movf brkoutpx + REPEATER * 2
024F   0824               M     movf brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    if (reg == WREG) || !BOOL2INT(dest)
                          M     if !BOOL2INT(W)
  00000024                M WREG_TRACKER = brkoutpx + REPEATER * 2; IIF(ISLIT(WREG_TRACKER), WREG_TRACKER + 1, WREG_UNKN)
                          M     endif
                          M ;    EXPAND_POP
                          M         endif
0250   0625               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), W; reg ^ WREG
0251   06A5               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), F; reg ^ (reg ^ WREG) == WREG
0252   06A4               M         XORWF brkoutpx + REPEATER * 2, F; WREG ^ (reg ^ WREG) == reg
                          M     endif
                          M ;    EXPAND_POP
                          M     swap_pair REPEATER * 2
                          M     swapreg brkoutpx + REPEATER * 2, brkoutpx + (REPEATER * 2 ^ 1)
                          M ;    EXPAND_PUSH FALSE
                          M     if (brkoutpx + (REPEATER * 2 ^ 1)) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; reg ^ WREG
                          M         XORWF brkoutpx + REPEATER * 2, F; reg ^ (reg ^ WREG) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; WREG ^ (reg ^ WREG) == reg
                          M     else
                          M         if (brkoutpx + REPEATER * 2) != WREG
                          M             MOVF brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + REPEATER * 2
                          M     BANKSAFE EMIT dest_arg(W)    movf brkoutpx + REPEATER * 2;, dest;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT withdest_0 movf brkoutpx + REPEATER * 2
                          M     withdest_0 movf brkoutpx + REPEATER * 2
0253   0826               M     movf brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    if (reg == WREG) || !BOOL2INT(dest)
                          M     if !BOOL2INT(W)
  00000026                M WREG_TRACKER = brkoutpx + REPEATER * 2; IIF(ISLIT(WREG_TRACKER), WREG_TRACKER + 1, WREG_UNKN)
                          M     endif
                          M ;    EXPAND_POP
                          M         endif
0254   0627               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), W; reg ^ WREG
0255   06A7               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), F; reg ^ (reg ^ WREG) == WREG
0256   06A6               M         XORWF brkoutpx + REPEATER * 2, F; WREG ^ (reg ^ WREG) == reg
                          M     endif
                          M ;    EXPAND_POP
                          M     swap_pair REPEATER * 2
                          M     swapreg brkoutpx + REPEATER * 2, brkoutpx + (REPEATER * 2 ^ 1)
                          M ;    EXPAND_PUSH FALSE
                          M     if (brkoutpx + (REPEATER * 2 ^ 1)) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; reg ^ WREG
                          M         XORWF brkoutpx + REPEATER * 2, F; reg ^ (reg ^ WREG) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; WREG ^ (reg ^ WREG) == reg
                          M     else
                          M         if (brkoutpx + REPEATER * 2) != WREG
                          M             MOVF brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + REPEATER * 2
                          M     BANKSAFE EMIT dest_arg(W)    movf brkoutpx + REPEATER * 2;, dest;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT withdest_0 movf brkoutpx + REPEATER * 2
                          M     withdest_0 movf brkoutpx + REPEATER * 2
0257   0828               M     movf brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    if (reg == WREG) || !BOOL2INT(dest)
                          M     if !BOOL2INT(W)
  00000028                M WREG_TRACKER = brkoutpx + REPEATER * 2; IIF(ISLIT(WREG_TRACKER), WREG_TRACKER + 1, WREG_UNKN)
                          M     endif
                          M ;    EXPAND_POP
                          M         endif
0258   0629               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), W; reg ^ WREG
0259   06A9               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), F; reg ^ (reg ^ WREG) == WREG
025A   06A8               M         XORWF brkoutpx + REPEATER * 2, F; WREG ^ (reg ^ WREG) == reg
                          M     endif
                          M ;    EXPAND_POP
                          M     swap_pair REPEATER * 2
                          M     swapreg brkoutpx + REPEATER * 2, brkoutpx + (REPEATER * 2 ^ 1)
                          M ;    EXPAND_PUSH FALSE
                          M     if (brkoutpx + (REPEATER * 2 ^ 1)) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; reg ^ WREG
                          M         XORWF brkoutpx + REPEATER * 2, F; reg ^ (reg ^ WREG) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; WREG ^ (reg ^ WREG) == reg
                          M     else
                          M         if (brkoutpx + REPEATER * 2) != WREG
                          M             MOVF brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + REPEATER * 2
                          M     BANKSAFE EMIT dest_arg(W)    movf brkoutpx + REPEATER * 2;, dest;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT withdest_0 movf brkoutpx + REPEATER * 2
                          M     withdest_0 movf brkoutpx + REPEATER * 2
025B   082A               M     movf brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    if (reg == WREG) || !BOOL2INT(dest)
                          M     if !BOOL2INT(W)
  0000002A                M WREG_TRACKER = brkoutpx + REPEATER * 2; IIF(ISLIT(WREG_TRACKER), WREG_TRACKER + 1, WREG_UNKN)
                          M     endif
                          M ;    EXPAND_POP
                          M         endif
025C   062B               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), W; reg ^ WREG
025D   06AB               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), F; reg ^ (reg ^ WREG) == WREG
025E   06AA               M         XORWF brkoutpx + REPEATER * 2, F; WREG ^ (reg ^ WREG) == reg
                          M     endif
                          M ;    EXPAND_POP
                          M     swap_pair REPEATER * 2
                          M     swapreg brkoutpx + REPEATER * 2, brkoutpx + (REPEATER * 2 ^ 1)
                          M ;    EXPAND_PUSH FALSE
                          M     if (brkoutpx + (REPEATER * 2 ^ 1)) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; reg ^ WREG
                          M         XORWF brkoutpx + REPEATER * 2, F; reg ^ (reg ^ WREG) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; WREG ^ (reg ^ WREG) == reg
                          M     else
                          M         if (brkoutpx + REPEATER * 2) != WREG
                          M             MOVF brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + REPEATER * 2
                          M     BANKSAFE EMIT dest_arg(W)    movf brkoutpx + REPEATER * 2;, dest;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT withdest_0 movf brkoutpx + REPEATER * 2
                          M     withdest_0 movf brkoutpx + REPEATER * 2
025F   082C               M     movf brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    if (reg == WREG) || !BOOL2INT(dest)
                          M     if !BOOL2INT(W)
  0000002C                M WREG_TRACKER = brkoutpx + REPEATER * 2; IIF(ISLIT(WREG_TRACKER), WREG_TRACKER + 1, WREG_UNKN)
                          M     endif
                          M ;    EXPAND_POP
                          M         endif
0260   062D               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), W; reg ^ WREG
0261   06AD               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), F; reg ^ (reg ^ WREG) == WREG
0262   06AC               M         XORWF brkoutpx + REPEATER * 2, F; WREG ^ (reg ^ WREG) == reg
                          M     endif
                          M ;    EXPAND_POP
                          M     swap_pair REPEATER * 2
                          M     swapreg brkoutpx + REPEATER * 2, brkoutpx + (REPEATER * 2 ^ 1)
                          M ;    EXPAND_PUSH FALSE
                          M     if (brkoutpx + (REPEATER * 2 ^ 1)) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; reg ^ WREG
                          M         XORWF brkoutpx + REPEATER * 2, F; reg ^ (reg ^ WREG) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; WREG ^ (reg ^ WREG) == reg
                          M     else
                          M         if (brkoutpx + REPEATER * 2) != WREG
                          M             MOVF brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + REPEATER * 2
                          M     BANKSAFE EMIT dest_arg(W)    movf brkoutpx + REPEATER * 2;, dest;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT withdest_0 movf brkoutpx + REPEATER * 2
                          M     withdest_0 movf brkoutpx + REPEATER * 2
0263   082E               M     movf brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    if (reg == WREG) || !BOOL2INT(dest)
                          M     if !BOOL2INT(W)
  0000002E                M WREG_TRACKER = brkoutpx + REPEATER * 2; IIF(ISLIT(WREG_TRACKER), WREG_TRACKER + 1, WREG_UNKN)
                          M     endif
                          M ;    EXPAND_POP
                          M         endif
0264   062F               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), W; reg ^ WREG
0265   06AF               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), F; reg ^ (reg ^ WREG) == WREG
0266   06AE               M         XORWF brkoutpx + REPEATER * 2, F; WREG ^ (reg ^ WREG) == reg
                          M     endif
                          M ;    EXPAND_POP
                          M     swap_pair REPEATER * 2
                          M     swapreg brkoutpx + REPEATER * 2, brkoutpx + (REPEATER * 2 ^ 1)
                          M ;    EXPAND_PUSH FALSE
                          M     if (brkoutpx + (REPEATER * 2 ^ 1)) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; reg ^ WREG
                          M         XORWF brkoutpx + REPEATER * 2, F; reg ^ (reg ^ WREG) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; WREG ^ (reg ^ WREG) == reg
                          M     else
                          M         if (brkoutpx + REPEATER * 2) != WREG
                          M             MOVF brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + REPEATER * 2
                          M     BANKSAFE EMIT dest_arg(W)    movf brkoutpx + REPEATER * 2;, dest;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT withdest_0 movf brkoutpx + REPEATER * 2
                          M     withdest_0 movf brkoutpx + REPEATER * 2
0267   0830               M     movf brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    if (reg == WREG) || !BOOL2INT(dest)
                          M     if !BOOL2INT(W)
  00000030                M WREG_TRACKER = brkoutpx + REPEATER * 2; IIF(ISLIT(WREG_TRACKER), WREG_TRACKER + 1, WREG_UNKN)
                          M     endif
                          M ;    EXPAND_POP
                          M         endif
0268   0631               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), W; reg ^ WREG
0269   06B1               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), F; reg ^ (reg ^ WREG) == WREG
026A   06B0               M         XORWF brkoutpx + REPEATER * 2, F; WREG ^ (reg ^ WREG) == reg
                          M     endif
                          M ;    EXPAND_POP
                          M     swap_pair REPEATER * 2
                          M     swapreg brkoutpx + REPEATER * 2, brkoutpx + (REPEATER * 2 ^ 1)
                          M ;    EXPAND_PUSH FALSE
                          M     if (brkoutpx + (REPEATER * 2 ^ 1)) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; reg ^ WREG
                          M         XORWF brkoutpx + REPEATER * 2, F; reg ^ (reg ^ WREG) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; WREG ^ (reg ^ WREG) == reg
                          M     else
                          M         if (brkoutpx + REPEATER * 2) != WREG
                          M             MOVF brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + REPEATER * 2
                          M     BANKSAFE EMIT dest_arg(W)    movf brkoutpx + REPEATER * 2;, dest;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT withdest_0 movf brkoutpx + REPEATER * 2
                          M     withdest_0 movf brkoutpx + REPEATER * 2
026B   0832               M     movf brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    if (reg == WREG) || !BOOL2INT(dest)
                          M     if !BOOL2INT(W)
  00000032                M WREG_TRACKER = brkoutpx + REPEATER * 2; IIF(ISLIT(WREG_TRACKER), WREG_TRACKER + 1, WREG_UNKN)
                          M     endif
                          M ;    EXPAND_POP
                          M         endif
026C   0633               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), W; reg ^ WREG
026D   06B3               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), F; reg ^ (reg ^ WREG) == WREG
026E   06B2               M         XORWF brkoutpx + REPEATER * 2, F; WREG ^ (reg ^ WREG) == reg
                          M     endif
                          M ;    EXPAND_POP
                          M     swap_pair REPEATER * 2
                          M     swapreg brkoutpx + REPEATER * 2, brkoutpx + (REPEATER * 2 ^ 1)
                          M ;    EXPAND_PUSH FALSE
                          M     if (brkoutpx + (REPEATER * 2 ^ 1)) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; reg ^ WREG
                          M         XORWF brkoutpx + REPEATER * 2, F; reg ^ (reg ^ WREG) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; WREG ^ (reg ^ WREG) == reg
                          M     else
                          M         if (brkoutpx + REPEATER * 2) != WREG
                          M             MOVF brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + REPEATER * 2
                          M     BANKSAFE EMIT dest_arg(W)    movf brkoutpx + REPEATER * 2;, dest;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT withdest_0 movf brkoutpx + REPEATER * 2
                          M     withdest_0 movf brkoutpx + REPEATER * 2
026F   0834               M     movf brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    if (reg == WREG) || !BOOL2INT(dest)
                          M     if !BOOL2INT(W)
  00000034                M WREG_TRACKER = brkoutpx + REPEATER * 2; IIF(ISLIT(WREG_TRACKER), WREG_TRACKER + 1, WREG_UNKN)
                          M     endif
                          M ;    EXPAND_POP
                          M         endif
0270   0635               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), W; reg ^ WREG
0271   06B5               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), F; reg ^ (reg ^ WREG) == WREG
0272   06B4               M         XORWF brkoutpx + REPEATER * 2, F; WREG ^ (reg ^ WREG) == reg
                          M     endif
                          M ;    EXPAND_POP
                          M     swap_pair REPEATER * 2
                          M     swapreg brkoutpx + REPEATER * 2, brkoutpx + (REPEATER * 2 ^ 1)
                          M ;    EXPAND_PUSH FALSE
                          M     if (brkoutpx + (REPEATER * 2 ^ 1)) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; reg ^ WREG
                          M         XORWF brkoutpx + REPEATER * 2, F; reg ^ (reg ^ WREG) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; WREG ^ (reg ^ WREG) == reg
                          M     else
                          M         if (brkoutpx + REPEATER * 2) != WREG
                          M             MOVF brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + REPEATER * 2
                          M     BANKSAFE EMIT dest_arg(W)    movf brkoutpx + REPEATER * 2;, dest;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT withdest_0 movf brkoutpx + REPEATER * 2
                          M     withdest_0 movf brkoutpx + REPEATER * 2
0273   0836               M     movf brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    if (reg == WREG) || !BOOL2INT(dest)
                          M     if !BOOL2INT(W)
  00000036                M WREG_TRACKER = brkoutpx + REPEATER * 2; IIF(ISLIT(WREG_TRACKER), WREG_TRACKER + 1, WREG_UNKN)
                          M     endif
                          M ;    EXPAND_POP
                          M         endif
0274   0637               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), W; reg ^ WREG
0275   06B7               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), F; reg ^ (reg ^ WREG) == WREG
0276   06B6               M         XORWF brkoutpx + REPEATER * 2, F; WREG ^ (reg ^ WREG) == reg
                          M     endif
                          M ;    EXPAND_POP
                          M     swap_pair REPEATER * 2
                          M     swapreg brkoutpx + REPEATER * 2, brkoutpx + (REPEATER * 2 ^ 1)
                          M ;    EXPAND_PUSH FALSE
                          M     if (brkoutpx + (REPEATER * 2 ^ 1)) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; reg ^ WREG
                          M         XORWF brkoutpx + REPEATER * 2, F; reg ^ (reg ^ WREG) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; WREG ^ (reg ^ WREG) == reg
                          M     else
                          M         if (brkoutpx + REPEATER * 2) != WREG
                          M             MOVF brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + REPEATER * 2
                          M     BANKSAFE EMIT dest_arg(W)    movf brkoutpx + REPEATER * 2;, dest;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT withdest_0 movf brkoutpx + REPEATER * 2
                          M     withdest_0 movf brkoutpx + REPEATER * 2
0277   0838               M     movf brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    if (reg == WREG) || !BOOL2INT(dest)
                          M     if !BOOL2INT(W)
  00000038                M WREG_TRACKER = brkoutpx + REPEATER * 2; IIF(ISLIT(WREG_TRACKER), WREG_TRACKER + 1, WREG_UNKN)
                          M     endif
                          M ;    EXPAND_POP
                          M         endif
0278   0639               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), W; reg ^ WREG
0279   06B9               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), F; reg ^ (reg ^ WREG) == WREG
027A   06B8               M         XORWF brkoutpx + REPEATER * 2, F; WREG ^ (reg ^ WREG) == reg
                          M     endif
                          M ;    EXPAND_POP
                          M     swap_pair REPEATER * 2
                          M     swapreg brkoutpx + REPEATER * 2, brkoutpx + (REPEATER * 2 ^ 1)
                          M ;    EXPAND_PUSH FALSE
                          M     if (brkoutpx + (REPEATER * 2 ^ 1)) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; reg ^ WREG
                          M         XORWF brkoutpx + REPEATER * 2, F; reg ^ (reg ^ WREG) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; WREG ^ (reg ^ WREG) == reg
                          M     else
                          M         if (brkoutpx + REPEATER * 2) != WREG
                          M             MOVF brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + REPEATER * 2
                          M     BANKSAFE EMIT dest_arg(W)    movf brkoutpx + REPEATER * 2;, dest;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT withdest_0 movf brkoutpx + REPEATER * 2
                          M     withdest_0 movf brkoutpx + REPEATER * 2
027B   083A               M     movf brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    if (reg == WREG) || !BOOL2INT(dest)
                          M     if !BOOL2INT(W)
  0000003A                M WREG_TRACKER = brkoutpx + REPEATER * 2; IIF(ISLIT(WREG_TRACKER), WREG_TRACKER + 1, WREG_UNKN)
                          M     endif
                          M ;    EXPAND_POP
                          M         endif
027C   063B               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), W; reg ^ WREG
027D   06BB               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), F; reg ^ (reg ^ WREG) == WREG
027E   06BA               M         XORWF brkoutpx + REPEATER * 2, F; WREG ^ (reg ^ WREG) == reg
                          M     endif
                          M ;    EXPAND_POP
                          M     swap_pair REPEATER * 2
                          M     swapreg brkoutpx + REPEATER * 2, brkoutpx + (REPEATER * 2 ^ 1)
                          M ;    EXPAND_PUSH FALSE
                          M     if (brkoutpx + (REPEATER * 2 ^ 1)) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; reg ^ WREG
                          M         XORWF brkoutpx + REPEATER * 2, F; reg ^ (reg ^ WREG) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; WREG ^ (reg ^ WREG) == reg
                          M     else
                          M         if (brkoutpx + REPEATER * 2) != WREG
                          M             MOVF brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + REPEATER * 2
                          M     BANKSAFE EMIT dest_arg(W)    movf brkoutpx + REPEATER * 2;, dest;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT withdest_0 movf brkoutpx + REPEATER * 2
                          M     withdest_0 movf brkoutpx + REPEATER * 2
027F   083C               M     movf brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    if (reg == WREG) || !BOOL2INT(dest)
                          M     if !BOOL2INT(W)
  0000003C                M WREG_TRACKER = brkoutpx + REPEATER * 2; IIF(ISLIT(WREG_TRACKER), WREG_TRACKER + 1, WREG_UNKN)
                          M     endif
                          M ;    EXPAND_POP
                          M         endif
0280   063D               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), W; reg ^ WREG
0281   06BD               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), F; reg ^ (reg ^ WREG) == WREG
0282   06BC               M         XORWF brkoutpx + REPEATER * 2, F; WREG ^ (reg ^ WREG) == reg
                          M     endif
                          M ;    EXPAND_POP
                          M     swap_pair REPEATER * 2
                          M     swapreg brkoutpx + REPEATER * 2, brkoutpx + (REPEATER * 2 ^ 1)
                          M ;    EXPAND_PUSH FALSE
                          M     if (brkoutpx + (REPEATER * 2 ^ 1)) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; reg ^ WREG
                          M         XORWF brkoutpx + REPEATER * 2, F; reg ^ (reg ^ WREG) == WREG
                          M         XORWF brkoutpx + REPEATER * 2, W; WREG ^ (reg ^ WREG) == reg
                          M     else
                          M         if (brkoutpx + REPEATER * 2) != WREG
                          M             MOVF brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK brkoutpx + REPEATER * 2
                          M     BANKSAFE EMIT dest_arg(W)    movf brkoutpx + REPEATER * 2;, dest;
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND
                          M     errorlevel -302  ;this is a useless/annoying message because the assembler doesn't handle it well (always generates warning when accessing registers in bank 1, even if 
                          M ;    messg BANKSAFE: stmt @1873
                          M ;        EXPAND_RESTORE
                          M ;    EXPAND_PUSH TRUE
                          M     EMIT withdest_0 movf brkoutpx + REPEATER * 2
                          M     withdest_0 movf brkoutpx + REPEATER * 2
0283   083E               M     movf brkoutpx + REPEATER * 2, W;
                          M ;    EXPAND_POP
                          M ;       NOEXPAND
                          M     errorlevel +302 ;kludge: re-Enable bank switch warning
                          M ;    EXPAND_RESTORE
                          M ;    EXPAND_POP
                          M ;    if (reg == WREG) || !BOOL2INT(dest)
                          M     if !BOOL2INT(W)
  0000003E                M WREG_TRACKER = brkoutpx + REPEATER * 2; IIF(ISLIT(WREG_TRACKER), WREG_TRACKER + 1, WREG_UNKN)
                          M     endif
                          M ;    EXPAND_POP
                          M         endif
0284   063F               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), W; reg ^ WREG
0285   06BF               M         XORWF brkoutpx + (REPEATER * 2 ^ 1), F; reg ^ (reg ^ WREG) == WREG
0286   06BE               M         XORWF brkoutpx + REPEATER * 2, F; WREG ^ (reg ^ WREG) == reg
                          M     endif
                          M ;    EXPAND_POP
                      00318     CALL ani_delay;
0287   2289               M     call ani_delay
                      00319 ;    goto breakout_reset; leave brkoutpx initialized to "off" color
                      00320 ;    fps_init 1 sec; restore FPS timer
0288   0008           00321     return;
                      00322 
                      00323 
                      00324 ;send breakout px then delay for animation:
                      00325 ani_delay: DROP_CONTEXT;
                      00326 ;    call brkoutpx_sendall;
                      00327 ;    mov16 FSR0, LITERAL(brkoutpx);
                      00328     render_busy TRUE;
0289   3020               M     movlw (((ASM_MSB | (_6642SRC & 0xFF))) & ~ASM_MSB)
028A   0084               M     movwf FSR0
028B   0185               M     clrf FSR00hi
                      00329 ;ani_loop: DROP_CONTEXT
                      00330 ;    mov8 WREG, INDF0_postinc
                      00331 ;    call ws_send_palette
                      00332 ;    wait_msec 100,; animation speed
                      00333 ;    whilebit elapsed_fps, FALSE, ;goto no_fps_update
                      00334     wait4frame YIELD, YIELD_AGAIN; 1/10 sec; assume breakout is written by now (takes < 1 msec)
028C   216E               M     call yield
028D   014E               M     banksel PIR0
                          M     goto_pagesafe yield_again
                          M ;    EXPAND_PUSH FALSE
                          M ; messg here1 @2947
                          M     ERRIF(LITPAGEOF(yield_again), [ERROR] "dest" yield_again 369 !on page 0: 0          @2948)
                          M ; messg here2 @2949
                          M ;PAGESEL_DROP += 1
                          M ;    messg goto dest, page tracker #v(PAGE_TRACKER), need page sel? #v(LITPAGEOF(dest)) != #v(LITPAGEOF(PAGE_TRACKER))? #v(LITPAGEOF(dest) != LITPAGEOF(PAGE_TRACKER))
                          M     if LITPAGEOF(yield_again) != LITPAGEOF(PAGE_TRACKER)
                          M         EMIT CLRF PCLATH; PAGESEL dest; kludge: mpasm doesn't want to pagesel
                          M PAGESEL_KEEP += 1
                          M     else
  00000033                M PAGESEL_DROP += 1
                          M     endif
                          M ;    EXPAND_RESTORE; NOEXPAND
                          M ; messg here3 @2959
                          M     EMIT goto yield_again; PROGDCL 0x2000 | (dest); call dest
028F   2971               M     goto yield_again
  00000171                M PAGE_TRACKER = yield_again;
                          M ; messg here4 @2962
                          M ;    NOEXPAND
                          M ;not needed: fall-thru would be handled by earlier code    DROP_CONTEXT; BSR and WREG unknown here if dest falls through
                          M ;    EXPAND_POP
028E                      M     ORG ctx_addr_132
0290                      M     ORG ctx_addr_133
                          M     withbit_5 bcf PIR0
0290   128C               M     bcf PIR0, 5
                      00335 ;    ifbit FSR0L, log2(64), !((brkoutpx + 32) & 64), goto ani_loop; send more breakout px
0291   0008           00336     return;
                      00337 
                      00338     THREAD_END;
                      00339 
Message[301]: MESSAGE: (end of hoist 6 @342)
Message[301]: MESSAGE: (epilog @3602)
017D                      M     ORG ctx_addr_95
017D   2A92               M     goto init_5
0292                      M     ORG ctx_addr_134
0292                      M init_5:
0292                      M at_eof_0:
Message[301]: MESSAGE: ([WARNING] macro expand stack not empty @eof: -1")
0292                      M at_eof_1:
0292                      M at_eof_2:
Message[301]: MESSAGE: ([INFO] optimization stats: @3590)
0292                      M at_eof_3:
Message[301]: MESSAGE: ([INFO] bank sel: 47 (30%), dropped: 109 (70%) @1856)
0292                      M at_eof_4:
Message[301]: MESSAGE: ([INFO] bank0 used: 32/80 (40%) @2032)
Message[301]: MESSAGE: ([INFO] bank1 used: 0/80 (0%) @2033)
Message[301]: MESSAGE: ([INFO] non-banked used: 6/16 (38%) @2034)
0292                      M at_eof_5:
Message[301]: MESSAGE: ([INFO] page sel: 1 (2%), dropped: 52 (98%) @2970)
Message[301]: MESSAGE: ([INFO] page0 used: 658/2048 (32%) @2971)
0292                      M at_eof_6:
Message[301]: MESSAGE: ([INFO] Ugly fixups pass1: 0:0, pass2: 0:0 @3073)
0292                      M at_eof_7:
Message[301]: MESSAGE: ([INFO] #threads: 2, stack space needed: 8, unalloc: 8 @1369)
0292                      M start_threads:
                          M     withdest_0 movf stkptr_0
0292   0873               M     movf stkptr_0, W;
0293   017F               M     banksel STKPTR
0294   00ED               M     movwf STKPTR
0295   0008               M     return
0023                      M     ORG ctx_addr_4
                          M     withdest_0 movf stkptr_1
0023   0874               M     movf stkptr_1, W;
0024   017F               M     banksel STKPTR
0025   00ED               M     movwf STKPTR
0171                      M     ORG ctx_addr_93
                          M     withdest_0 movf stkptr_0
0171   0873               M     movf stkptr_0, W;
0172   017F               M     banksel STKPTR
0173   00ED               M     movwf STKPTR
0296                      M     ORG ctx_addr_135
Message[301]: MESSAGE: (end of epilog @3637)
MPASM 5.87  /HOME/DJ/MPLABXPROJECTS/WSSPLITT   11-10-2021  22:05:05         PAGE  3
WS281X-Splitter - WS281X segment splitter/breakout/debug for Microchip PIC

SYMBOL TABLE
  LABEL                             VALUE 

ADDLW                             addlw_tracker
ADDWF                             addwf_banksafe
ALLOC_GPR                         
ANDLW                             andlw_tracker
ASM_MSB                           80000000
BANKCHK                           
BANKLEN                           0x80
BANKOF                            IIF(ISBANKED(reg), REG2ADDR(reg) / BANKLEN, BANK_UNKN)
BANKOFS                           ((reg) % BANKLEN)
BANKSAFE                          
BANKSEL_DROP                      0000006D
BANKSEL_KEEP                      00000032
BANK_TRACKER                      00001FED
BANK_UNKN                         -1
BCF                               bcf_tracker
BIT                               (1 << (n))
BLUE_RGBINX                       00000001
BOOL2INT                          ((val) != 0)
BORROW                            STATUS, C, !
BREAKOUT                          RA0
BRIGHT                            ((rgb) + 8)
BRKOUT_BITREV                     
BRKOUT_BYTE                       BRKOUT_BYTE_#v(byte)
BSF                               bsf_tracker
BYTEOF                            IIF(ISLIT(val), BYTEOF_LIT(val, which), BYTEOF_REG(val, which))
BYTEOF_LIT                        LITERAL(((val) >> (8 * (which))) & 0xFF)
BYTEOF_REG                        REGISTER((val) + (which))
CALL                              call_pagesafe
CARRY                             STATUS, C,
CLRF                              clrf_tracker
CLRW                              CLRF WREG
COMMON_END                        0xC
CONTEXT_RESTORE                   
CONTEXT_SAVE                      
CUSTOM_RGBINX                     00000008
CYAN_RGBINX                       00000003
DECF                              decf_banksafe
DISABLED                          BIT(n)
DISABLED_ALL                      0xFF
DROP_BANK                         
DROP_CONTEXT                      
DROP_WREG                         
EMIT                              
EMITL                             
ENABLED                           NOBIT(n)
ENABLED_ALL                       0
ENDOF                             (name + SIZEOF(name))
EOF_ADDR                          00000292
EOF_COUNT                         00000008
EQUALS                            STATUS, Z,
ERRIF                             ERRIF_#v(((assert) != 0))  msg
ERRIF_0                           IGNORE_EOL
ERRIF_1                           error
EXPAND_CTL                        
EXPAND_POP                        EXPAND_CTL -1
EXPAND_PUSH                       EXPAND_CTL
EXPAND_RESTORE                    EXPAND_CTL 0xf00d
FALSE                             0
FOSC_FREQ                         (32 MHz)
FOUND_MSB                         00000040
FPS                               00000075
FPS0size                          00000001
FPS_RGBINX                        00000003
FPS_RGBINX_ALT                    00000005
FSR00hi                           00000005
FSR10hi                           00000007
GOTO                              goto_pagesafe
GPR_END                           0x70
GPR_START                         0x20
GREEN_RGBINX                      00000002
HIBYTE                            BYTEOF(val, 2)
HOST_STKLEN                       16-0
IGNORE_EOL                        
IIF                               (BOOL2INT(TF) * ((tval) - (fval)) + (fval))
IIFDEBUG                          expr_true
INCF                              incf_banksafe
INDF0_postdec                     00020003
INDF0_postinc                     00020002
INDF0_predec                      00020001
INDF0_preinc                      00020000
INDF0_special                     00020000
INDF1_postdec                     00010003
INDF1_postinc                     00010002
INDF1_predec                      00010001
INDF1_preinc                      00010000
INDF1_special                     00010000
INIT_COUNT                        00000005
IN_THREAD                         00000000
IORLW                             iorlw_tracker
ISBANKED                          ((BANKOFS(reg) >= COMMON_END) && (BANKOFS(reg) < GPR_END))
ISLIT                             ((val) & ASM_MSB)
ISR_VECTOR                        (RESET_VECTOR + 4)
KHz                               * 1000
LAST_INIT                         0000017E
LATEST_RAM1                       00000073
LATEST_RAM2                       00000040
LATEST_RAM3                       00000074
LATEST_RAM4                       00000075
LATEST_RAM5                       00000076
LEDOUT                            IIFDEBUG(SEG4OUT, -1)
LISTCTL                           
LIST_POP                          LISTCTL -1
LIST_PUSH                         LISTCTL
LIST_RESTORE                      LISTCTL 0xfeed
LIT2VAL                           ((n) & ~ASM_MSB)
LITBIT                            LITERAL(BIT(n))
LITERAL                           (ASM_MSB | (n))
LITPAGEOF                         ((addr) / LIT_PAGELEN)
LIT_PAGELEN                       0x800
LOBYTE                            BYTEOF(val, 0)
LSTCTL_DEEPEST                    00000003
LSTCTL_DEPTH                      00000000
LSTCTL_STACK                      00000000
MAGENTA_RGBINX                    00000005
MAX                               IIF((x) > (y), x, y)
MAX_RAM0                          00000070
MAX_RAM1                          000000F0
MAX_RAM9999                       00000080
MAX_T0POSTSC                      00000004
MAX_T0PRESCALER                   0000000F
MEXPAND_DEEPEST                   00000005
MEXPAND_DEPTH                     00000000
MEXPAND_STACK                     00000001
MHz                               * 1000000
MIDBYTE                           BYTEOF(val, 1)
MIN                               IIF((x) < (y), x, y)
MIN_STACK                         2
MIPS                              * 4 MHz
MOVF                              movf_banksafe
MOVIW_0_0                         MOVIW ++FSR0
MOVIW_0_1                         MOVIW --FSR0
MOVIW_0_2                         MOVIW FSR0++
MOVIW_0_3                         MOVIW FSR0--
MOVIW_1_0                         MOVIW ++FSR1
MOVIW_1_1                         MOVIW --FSR1
MOVIW_1_2                         MOVIW FSR1++
MOVIW_1_3                         MOVIW FSR1--
MOVIW_opc                         MOVIW_#v((fsr) == FSR1)_#v((mode) & 3)
MOVLW                             movlw_tracker
MOVWF                             movwf_banksafe
MOVWI_0_0                         MOVWI ++FSR0
MOVWI_0_1                         MOVWI --FSR0
MOVWI_0_2                         MOVWI FSR0++
MOVWI_0_3                         MOVWI FSR0--
MOVWI_1_0                         MOVWI ++FSR1
MOVWI_1_1                         MOVWI --FSR1
MOVWI_1_2                         MOVWI FSR1++
MOVWI_1_3                         MOVWI FSR1--
MOVWI_opc                         MOVWI_#v((fsr) == FSR1)_#v((mode) & 3)
MY_BRG                            (FOSC_FREQ / (freq) / 4 - 1)
MY_CONFIG1                        0000178C
MY_CONFIG2                        00002FFE
MY_CONFIG3                        00003F9F
MY_CONFIG4                        00001FFF
MY_CONFIG5                        00003FFF
NEXT_RAM0                         00000040
NEXT_RAM1                         000000A0
NEXT_RAM9999                      00000076
NOBANK                            0000270F
NOBIT                             0
NOP                               nop_multi
NULL_STMT                         ORG $
NUM_CONTEXT                       00000088
NUM_THREADS                       00000002
OFF_RGBINX                        00000000
OUTPPS_DT1                        0x10
OUTPPS_TX1_CK1                    0x0F
PAGESEL_DROP                      00000034
PAGESEL_KEEP                      00000001
PAGE_TRACKER                      0000017E
PASS1_FIXUPS                      00000000
PASS2_FIXUPS                      00000000
PINK_RGBINX                       00000005
PLL                               * 2
POP                               
PUSH                              
RAM_BLOCK                         00000005
RAM_LEN0                          00000050
RAM_LEN1                          00000050
RAM_LEN9999                       00000010
RAM_START0                        00000020
RAM_START1                        000000A0
RAM_START9999                     00000070
RAM_USED0                         00000020
RAM_USED1                         00000000
RAM_USED9999                      00000006
RED_RGBINX                        00000004
REG2ADDR                          (a)
REGHI                             name#v(0)hi
REGISTER                          (a)
REGLO                             name
REGMID                            name#v(0)mid
REGPAGEOF                         ((addr) / REG_PAGELEN)
REG_PAGELEN                       0x100
REPEAT                            
REPEATER                          00000010
RERUN_THREADS                     TRUE
RESET_VECTOR                      0
REVBIT                            (0x80 >> (n))
RGB_ORDER                         RGB_#v(n)
RGSWAP                            0x321
SEG1OUT                           RA1
SEG2OUT                           RA2
SEG3OUT                           RA#v(3+2)
SEG4OUT                           RA4
SETUP_FULL                        00000080
SETUP_ONLY                        00000010
SETUP_PART                        00000040
SIZEOF                            name#v(0)size
SP1BRG0hi                         0000011C
SPI3x_0                           SPI3x_FIRST(byte)
SPI3x_1                           SPI3x_MID(byte)
SPI3x_2                           SPI3x_LAST(byte)
SPI3x_FIRST                       BRKOUT_BYTE(b'10010010' | BOOL2INT((byte) & BIT(7)) << 6 | BOOL2INT((byte) & BIT(6)) << 3 | BOOL2I
SPI3x_LAST                        BRKOUT_BYTE(b'00100100' | BOOL2INT((byte) & BIT(2)) << 7 | BOOL2INT((byte) & BIT(1)) << 4 | BOOL2I
SPI3x_MID                         BRKOUT_BYTE(b'01001001' | BOOL2INT((byte) & BIT(4)) << 5 | BOOL2INT((byte) & BIT(3)) << 2)
STK_ALLOC                         00000008
T0SRC_FOSC4                       b'010'
T0_prescaler                      prescaler(FOSC_FREQ/4, freq)
T1GATE_LC1OUT                     b'01101'
T1GATE_LC4OUT                     b'10000'
T1SRC_HFINTOSC                    b'0011'
T1SRC_LC3OUT                      b'1100'
T1_prescale                       log2(1)
THREAD_DEF                        
THREAD_END                        
TOS                               00001FEE
TOS0hi                            00001FEF
TRUE                              1
TUNED                             ((freq) * 10/9)
UGLY_PASS12FIX                    
UNTUNED                           ((freq) * 9/10)
USE_HFFRQ                         b'110'
WAIT_4PX                          00000002
WANT_BIT                          00000001
WANT_DEBUG                        
WARNIF                            WARNIF_#v(((assert) != 0))  msg
WARNIF_0                          IGNORE_EOL
WARNIF_1                          messg
WHITE_RGBINX                      00000007
WREG_TRACKER                      00000073
WREG_UNKN                         40000000
WSBIT_FREQ                        (800 KHz)
WSBIT_THRESHOLD                   (FOSC_FREQ / (2 MHz))
WSDI                              RA3
WSENC_TEMP                        FFFFFFFF
WSLATCH                           (50 -20 usec)
XBIT                              NOBIT(n)
XORLW                             xorlw_tracker
YELLOW_RGBINX                     00000006
YESNO                             YESNO_#v(((val) != 0))
YESNO_0                           false
YESNO_1                           true
__16F15313                        00000001
addlw_tracker                     
addwf_banksafe                    
alt_loop                          000001F1
andlw_tracker                     
ani_delay                         00000289
asmbit                            00000020
asmpower2                         00000000
at_eof                            
b0DCL                             ALLOC_GPR 0,
b0DCL16                           
b0DCL24                           
bcf_tracker                       
before_yield                      00000087
bitnum_arg                        withbit_#v(argg)
bitoff_0                          
bitoff_1                          
bitoff_2                          
bitoff_3                          
bitoff_4                          
bitoff_5                          
bitoff_6                          
bitoff_7                          
biton_0                           
biton_1                           
biton_2                           
biton_3                           
biton_4                           
biton_5                           
biton_6                           
biton_7                           
blue_ani                          000001DD
breakout_eof                      log2(ENDOF(brkoutpx)), IIF(brkoutpx & ENDOF(brkoutpx), !(yesno), yesno)
brkout_ani                        000001BE
brkout_loop                       00000047
brkout_render                     00000030
brkoutpx                          00000020
brkoutpx0size                     00000020
bsf_tracker                       
call_pagesafe                     
ccolor                            00000070
ccolor0hi                         00000072
ccolor0mid                        00000071
ccolor0size                       00000003
clrf_tracker                      
clrw                              clrf WREG
comf2s                            
decf_banksafe                     
dest_arg                          withdest_#v(argg)
elapsed_fps                       PIR0, TMR0IF
eof                               00000292
eof_0                             
eof_1                             
eof_2                             
eof_3                             
eof_4                             
eof_5                             
eof_6                             
eof_7                             
find_msb                          
fosc_init                         
fps_ani                           000001E2
fps_init                          
fps_update                        0000019D
generate_brkout_bytes             
generate_get_palent               
goto_pagesafe                     
green_ani                         000001D8
ifbit                             
incf_banksafe                     
init_more                         
iopin_init                        
iorlw_tracker                     
khz                               rdiv(freq, 1000)
log2                              LOG2_#v(n)
mhz                               rdiv(freq, 1000000)
mov16                             mov_mb 16,
mov24                             mov_mb 24,
mov8                              
mov_mb                            
movf_banksafe                     
movlw_tracker                     
movwf_banksafe                    
msec                              * 1000
nbDCL                             ALLOC_GPR NOBANK,
nbDCL16                           
nbDCL24                           
nop16                             00000004
nop32                             00000003
nop4                              00000006
nop8                              00000005
nop_multi                         
off_loop                          000001CC
pal_byte                          00000070
palent                            00000090
palpiece                          00000009
pct                               rdiv(100 * (num), den)
pmd_init                          
pps_lock                          
prescaler                         log2((base_freq) / (want_freq))
pxpiece                           00000009
rcv_frame                         0000017E
rcv_loop                          0000018A
rdiv                              (((num)+(den)/2)/MAX(den, 1))
red_ani                           000001D3
render_busy                       
scale                             (BIT(prescale) KHz / khz(freq))
sec                               * 1000000
set_fps_pxbit                     
setbit                            
showarg_0                         
start_threads                     00000292
stkptr_00size                     00000001
stkptr_10size                     00000001
swap_pair                         
swapreg                           
usec                              * 1
val_arg                           showarg_#v(argg)
wait2render                       
wait2xmit                         
wait4frame                        
wait4px                           
waitpx                            
whilebit                          
withbit_0                         
withbit_1                         
withbit_2                         
withbit_3                         
withbit_4                         
withbit_5                         
withbit_6                         
withbit_7                         
withdest_0                        
withdest_1                        
ws_breakout_setup                 
ws_decode                         
ws_encbyte                        
ws_send_byte                      
ws_send_px                        
xmit_ready                        PIR3, TX1IF, yesno
xorlw_tracker                     
yield                             0000016E
yield_again                       00000171


MEMORY USAGE MAP ('X' = Used,  '-' = Unused)

0000 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0040 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0080 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
00C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0100 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0140 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0180 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
01C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0200 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0240 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0280 : XXXXXXXXXXXXXXXX XXXXXXX--------- ---------------- ----------------
8000 : -------XXXXX---- ---------------- ---------------- ----------------

All other memory blocks unused.

Program Memory Words Used:   668
Program Memory Words Free:  1380


Errors   :     0
Warnings :     0 reported,     0 suppressed
Messages :    54 reported,    73 suppressed


