MPASM 5.87  /HOME/DJ/MPLABXPROJECTS/WSSPLITT   12-13-2021  0:07:08         PAGE  1


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00001     title  "WS281X-Splitter - WS281X segment splitter/breakout/debug for Microchip PIC"
                      00002 ;================================================================================
                      00003 ; File:     wssplitter.asm
                      00004 ; Date:     8/11/2021
                      00005 ; Version:  0.21.10
                      00006 ; Author:   djulien@thejuliens.net, (c)2021 djulien@thejuliens.net
                      00007 ; Device:   PIC16F15313 (midrange Microchip 8-pin PIC) or equivalent running @8 MIPS
                      00008 ; Peripherals used: Timer0, Timer1 (gated), Timer2, no-MSSP, EUSART, no-PWM, CLC
                      00009 ; Compiler: mpasmx(v5.35), NOT pic-as; NOTE: custom build line is used for source code fixups
                      00010 ; IDE:      MPLABX v5.35 (last one to include mpasm)
                      00011 ; Description:
                      00012 ;   WS281X-Splitter can be used for the following purposes:
                      00013 ;   1. split a single WS281X data stream into <= 4 separate segments; 
                      00014 ;     creates a virtual daisy chain of LED strings instead of using null pixels between
                      00015 ;   2. debugger or signal integrity checker; show 24-bit WS pixel data at end of string
                      00016 ;   3. timing checker; display frame rate (FPS received); alternating color is used as heartbeat
                      00017 ; Build instructions:
                      00018 ;no   ?Add this line in the project properties box, pic-as Global Options -> Additional options:
                      00019 ;no   -Wa,-a -Wl,-pPor_Vec=0h,-pIsr_Vec=4h
                      00020 ;   - use PICKit2 or 3 or equivalent programmer (PICKit2 requires PICKitPlus for newer PICs)
                      00021 ; Wiring:
                      00022 ;  RA0 = debug output (32 px WS281X):
                      00023 ;        - first 24 px shows segment 1/2/3 quad px length (0 = 1K)
                      00024 ;        - next 8 px = FPS (255 max), msb first
                      00025 ;  RA1 = output segment 1
                      00026 ;  RA2 = output segment 2
                      00027 ;  RA3 = WS281X input stream
                      00028 ;        - first/second/third byte = segment 1/2/3 quad pixel length
                      00029 ;        - first segment data follows immediately
                      00030 ;  RA4 = output segment 4; receives anything after segment 1/2/3
                      00031 ;  RA5 = output segment 3
                      00032 ; TODO:
                      00033 ;  - use PPS to set RA3 as segment 3 out and RA5 as WS input?
                      00034 ;  - uart bootloader; ground segment 0 out to enable? auto-baud detect; verify
                      00035 ;  - custom pixel dup/skip, enforce max brightness limit?
                      00036 ;================================================================================
Message[301]: MESSAGE: (hoist 0: generic pic/asm helpers @3904)
Message[301]: MESSAGE: (TODO: fix this ^^^ vvv)
Message[301]: MESSAGE: (end of hoist 0 @4428)
Message[301]: MESSAGE: (no hoist, app config/defs @47)
                          M         exitm
                      00050 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                      00051 
                      00052 ;//compile-time options:
                      00053 ;#define BITBANG; //dev/test only
                      00054 ;;#define SPI_TEST
                      00055 #define WANT_DEBUG; //DEV/TEST ONLY!
                      00056 ;#define WANT_ISR; //ISR not used; uncomment to reserve space for ISR (or jump to)
                      00057 #define WSBIT_FREQ  (800 KHz); //WS281X "high" speed
                      00058 #define WSLATCH  (50 -20 usec); //end-of-frame latch time; "cheat" by using shorter interval and use the
                             extra time for processing overhead
MPASM 5.87  /HOME/DJ/MPLABXPROJECTS/WSSPLITT   12-13-2021  0:07:08         PAGE  2
WS281X-Splitter - WS281X segment splitter/breakout/debug for Microchip PIC

LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00059 ;#define MAX_THREADS  2; //anim xmit or frame rcv, breakout xmit
                      00060 #define FOSC_FREQ  (32 MHz); //max speed; NOTE: SPI 3x requires max speed, otherwise lower speed might w
                            ork
                      00061 
                      00062 ;//pin assignments:
                      00063 #define WSDI  RA3; //RA3 = WS input stream (from controller or previous WS281X pixels)
                      00064 #define BREAKOUT  RA0; //RA0 = WS breakout pixels, or simple LED for dev/debug
                      00065 #define LEDOUT  IIFDEBUG(SEG4OUT, -1); //RA5 = simple LED output; ONLY FOR DEV/DEBUG
                      00066 ;#define WSCLK  4-2; //RA4 = WS input clock (recovered from WS input data signal); EUSART sync rcv clock
                             needs a real I/O pin?
                      00067 #define SEG1OUT  RA1; //RA1 = WS output segment 1
                      00068 #define SEG2OUT  RA2; //RA2 = WS output segment 2
                      00069 #define SEG3OUT  RA#v(3+2); //RA5 = WS output segment 3; RA3 is input-only, use alternate pin for segmen
                            t 3
                      00070 #define SEG4OUT  RA4; //RA4 = WS output segment 4
                      00071 ;#define RGSWAP  0x321; //3 = R, 2 = G, 1 = B; default = 0x321 = RGB
                      00072 #define RGSWAP  0x231; //3 = R, 2 = G, 1 = B; default = 0x321 = RGB
                      00073 ;//             default    test strip
                      00074 ;//order 0x123: RGBYMCW => BRGMCYW
                      00075 ;//order 0x132: RGBYMCW => RBGMYCW
                      00076 ;//order 0x213: RGBYMCW => BGRCMYW
                      00077 ;//order 0x231: RGBYMCW => RGBYMCW ==
                      00078 ;//order 0x312: RGBYMCW => GBRCYMW
                      00079 ;//order 0x321: RGBYMCW => GRBYCMW
Message[301]: MESSAGE: ([TODO] R is sending blue(3rd byte), G is sending red(first byte), B is sending green(second byte))
                      00080  messg [TODO] R is sending blue(3rd byte), G is sending red(first byte), B is sending green(second byte)
                      00081 ;test strip is GRB order
                      00082 
Message[301]: MESSAGE: (end of !hoist @85)
Message[301]: MESSAGE: (hoist 1: custom opc @2380)
Message[301]: MESSAGE: ([INFO] COMPILED FOR DEV/DEBUG! @2394)
  80000000                M ASM_MSB EQU -2147483648
Message[301]: MESSAGE: ([TODO]: need to UNLIT WREG_TRACKER when used in arith (else upper bits might be affected))
0000                      M init_0:
0000                      M     ORG 0
                          M     nop_multi 1
0000   0000               M     nop
Message[301]: MESSAGE: (end of hoist 1 @3900)
Message[301]: MESSAGE: (hoist 2: cooperative multi-tasking ukernel @1860)
0001                      M     ORG ctx_addr_0
                          M     clrf_tracker PCLATH
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK PCLATH
0001   018A               M     clrf PCLATH
0002   2809               M     goto init_1
0009                      M     ORG ctx_addr_1
0009                      M init_1:
                      02896     iopin_init;
                          M     mov8 ANSELA, LITERAL(0); ; //all digital; CAUTION: do this before pin I/O
                          M ;    EXPAND_PUSH FALSE
                          M ;    NOEXPAND  ;reduce clutter
                          M ;    if (SRC == DEST) && ((srcbytes) == (destbytes)) && !(reverse)  ;nothing to do
  0000                    M     LOCAL SRC = (ASM_MSB | (0)) ;kludge; force eval (avoids "missing operand" and "missing argument" errors/MPASM bugs); also helps avoid "line too long" messages (MPASM li
  1F38                    M     LOCAL DEST = ANSELA ;kludge; force eval (avoids "missing operand" and "missing argument" errors/MPASM bugs); also helps avoid "line too long" messages (MPASM limit 200)
                          M     WARNIF(DEST == SRC, [WARNING] useless mov8 from ANSELA to (ASM_MSB | (0)) @2820);;
                          M ;    messg "mov8", #v(DEST), #v(SRC), #v(ISLIT(SRC)), #v(LIT2VAL(SRC)) @2821
                          M ;    messg src, dest @2822;
                          M     if ISLIT(SRC)  ;unpack SRC bytes
                          M ; messg dest, #v(!LIT2VAL(SRC)), #v(DEST != WREG), #v(!(DEST & INDF0_special)), #v(!(DEST & INDF1_special)) @2824
                          M         if !LIT2VAL(SRC) && (DEST != WREG) && !(DEST & INDF0_special) && !(DEST & INDF1_special)
                          M ;           BANKCHK dest;
                          M ;           BANKSAFE clrf dest; special case
                          M ;           EMIT CLRF dest;
                          M             CLRF ANSELA;
                          M ;    EXPAND_PUSH FALSE
                          M     BANKCHK ANSELA
0009   017E               M     banksel ANSELA
000A   01B8               M     clrf ANSELA
000B   3008               M     movlw (((ASM_MSB | ((1 << (RA3))))) & ~ASM_MSB)
000C   00B9               M     movwf WPUA
000D   0140               M     banksel LATA
000E   0198               M     clrf LATA
000F   0092               M     movwf TRISA
0010   0151               M     banksel OSCCON3
                          M     withbit_7 bcf OSCCON3
0011   138F               M     bcf OSCCON3, 7
0012   3060               M     movlw (((ASM_MSB | (b'110' << NOSC0 | 0 << NDIV0))) & ~ASM_MSB)
0013   008D               M     movwf OSCCON1
0014   3006               M     movlw (((ASM_MSB | (HFFRQ_32000000))) & ~ASM_MSB)
0015   0093               M     movwf OSCFRQ
0016   307F               M     movlw (((ASM_MSB | (0xFF ^ (1 << (SYSCMD))))) & ~ASM_MSB)
0017   014F               M     banksel PMD0
0018   0096               M     movwf PMD0
0019   30F8               M     movlw (((ASM_MSB | (0xFF ^ (1 << (TMR2MD)) ^ (1 << (TMR1MD)) ^ (1 << (TMR0MD))))) & ~ASM_MSB)
001A   0097               M     movwf PMD1
001B   30FF               M     movlw (((ASM_MSB | (0xFF))) & ~ASM_MSB)
001C   0098               M     movwf PMD2
001D   0099               M     movwf PMD3
001E   30BF               M     movlw (((ASM_MSB | (0xFF ^ (1 << (UART1MD))))) & ~ASM_MSB)
001F   009A               M     movwf PMD4
0020   019B               M     clrf PMD5
Message[301]: MESSAGE: ([TODO] use RSTOSC HFINT 1MHz? @2326)
Message[301]: MESSAGE: ([TODO] boot loader + LVP? @2345)
8007   178C           02967     __config _CONFIG1, MY_CONFIG1
8008   2FFE           02968     __config _CONFIG2, MY_CONFIG2
8009   3F9F           02969     __config _CONFIG3, MY_CONFIG3
800A   1FFF           02970     __config _CONFIG4, MY_CONFIG4
800B   3FFF           02971     __config _CONFIG5, MY_CONFIG5
Message[301]: MESSAGE: (end of hoist 2 @2376)
Message[301]: MESSAGE: (hoist 3: app helpers @1247)
Message[301]: MESSAGE: ([INFO] uart 16-bit brg ((32 * 1000000) / (2400 * 1000) / 4 - 1)) = 2 @1373)
Message[301]: MESSAGE: ([DEBUG] rgb order 0x231, R = 1, G = 2, B = 0 @1431)
Message[301]: MESSAGE: ([INFO] reversing breakout bit order (EUSART sends lsb first) @1552)
Message[301]: MESSAGE: (TODO: should do byte re-order in here @1606)
Message[301]: MESSAGE: (end of hoist 3 @1856)
Message[301]: MESSAGE: (hoist 4: HACK: 8-bit parallel wsplayer @89)
                          M         exitm
                      00092 ;; 8-bit parallel wsplayer ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                      00093 
                      00094 #define PXOUT  RA0
                      00095 #define UNIV_LEN  1600; //33; //10; //<= 2x banked GPRAM (for in-memory bitmaps), else prog space
                      00096 ;#define RGB_ORDER  213; //0x213; //GRB (normal is 0x123 = RGB)
                      00097 #define WS_ENV  235; // 2/3/5 @ 8MIPS completely meets WS2811 + WS2812 specs
                      00098 ;//#define WS_ENV  334; //make start pulse longer
                      00099 
                      00100 #ifdef LEDOUT
                      00101  #undefine LEDOUT
                      00102 #endif
                      00103 #define LEDOUT  RA4
                      00104 
                      00105 ;send 1 WS data bit to each IO pin:
                      00106 ;bits are assumed to be in WREG
                      00107 ;2/3/5 env @8 MIPS uses 30% CPU time (3 instr), leaves 70% for caller (7 instr)
                      00108 ;    doing_init TRUE
                      00109 ;not needed: IO pin init does this
                      00110 ;    mov8 LATA, LITERAL(0); //start with WS data lines low; NOTE: this is required for correct send startup
                      00111 ;    doing_init FALSE
                      00112 ;ws8_sendbit_wreg macro glue_reserved
                      00113 ;    ws8_sendbit ORG$, ORG$, NOP #v(4 - ABS(glue_reserved))
                      00114 ;    endm
                      00115 ws8_sendbit macro idler1, idler2, idler4
                      00116     ERRIF((WS_ENV != 235) || (FOSC_FREQ != 8 MIPS), [ERROR] WS envelope WS_ENV !implemented @ fosc FOSC_FREQ - use 235 @8MIPS @116)
                      00117     COMF LATA, F; //bit start; CAUTION: LATA must be 0 prior (which it should be)
                      00118 ;    ORG $+1; placeholder
                      00119     LOCAL here1 = $
                      00120     idler1
                      00121     nopif $ == here1, 1
                      00122     MOVWF LATA; //bit data
                      00123 ;    ORG $+2; placeholder
                      00124     LOCAL here2 = $
                      00125     idler2
                      00126     nopif $ == here2, 2
                      00127     CLRF LATA; //bit end
                      00128 ;    ORG $+4; placeholder
                      00129     LOCAL here3 = $
                      00130     idler4
                      00131     nopif $ == here3, 4
                      00132     endm
                      00133 
                      00134 
                      00135 ;//send var bit, byte, or pixel:
                      00136 ;//FSR0 or 1 points to parallel pixel data
                      00137 ;//by convention, FSR0 is bg color, FSR1 is fg color
                      00138 ;//NOTE: FSR changes after each call (auto-inc)
  0000                00139     CONSTANT BG = 0, FG = 1
                      00140     BANKCHK LATA; caller must set BSR; makes timing uniform in here
0022   0140               M     banksel LATA
0023                  00141 ws8_sendFGbyte:
                      00142 ws8_sendFGbit_8:     ws8_sendbit MOVIW INDF1++, ORG$, ORG$;;
0025   0098               M     movwf LATA
0026   2827               M     goto $+1
0027   0198               M     clrf LATA
0028   2008               M     call nop4
                      00143 ws8_sendFGbit_7:     ws8_sendbit MOVIW INDF1++, ORG$, ORG$;;
002B   0098               M     movwf LATA
002C   282D               M     goto $+1
002D   0198               M     clrf LATA
002E   2008               M     call nop4
                      00144 ws8_sendFGbit_6:     ws8_sendbit MOVIW INDF1++, ORG$, ORG$;;
0031   0098               M     movwf LATA
0032   2833               M     goto $+1
0033   0198               M     clrf LATA
0034   2008               M     call nop4
                      00145 ws8_sendFGbit_5:     ws8_sendbit MOVIW INDF1++, ORG$, ORG$;;
0037   0098               M     movwf LATA
0038   2839               M     goto $+1
0039   0198               M     clrf LATA
003A   2008               M     call nop4
                      00146 ws8_sendFGbit_4:     ws8_sendbit MOVIW INDF1++, ORG$, ORG$;;
003D   0098               M     movwf LATA
003E   283F               M     goto $+1
003F   0198               M     clrf LATA
0040   2008               M     call nop4
                      00147 ws8_sendFGbit_3:     ws8_sendbit MOVIW INDF1++, ORG$, ORG$;;
0043   0098               M     movwf LATA
0044   2845               M     goto $+1
0045   0198               M     clrf LATA
0046   2008               M     call nop4
                      00148 ws8_sendFGbit_2:     ws8_sendbit MOVIW INDF1++, ORG$, ORG$;;
0049   0098               M     movwf LATA
004A   284B               M     goto $+1
004B   0198               M     clrf LATA
004C   2008               M     call nop4
                      00149 ws8_sendFGbit_1:     ws8_sendbit MOVIW INDF1++, ORG$, return; //return + next call takes 4 instr
004F   0098               M     movwf LATA
0050   2851               M     goto $+1
0051   0198               M     clrf LATA
0053                  00150 ws8_sendBGbyte:
                      00151 ws8_sendBGbit_8:     ws8_sendbit MOVIW INDF0++, ORG$, ORG$;;
0055   0098               M     movwf LATA
0056   2857               M     goto $+1
0057   0198               M     clrf LATA
0058   2008               M     call nop4
                      00152 ws8_sendBGbit_7:     ws8_sendbit MOVIW INDF0++, ORG$, ORG$;;
005B   0098               M     movwf LATA
005C   285D               M     goto $+1
005D   0198               M     clrf LATA
005E   2008               M     call nop4
                      00153 ws8_sendBGbit_6:     ws8_sendbit MOVIW INDF0++, ORG$, ORG$;;
0061   0098               M     movwf LATA
0062   2863               M     goto $+1
0063   0198               M     clrf LATA
0064   2008               M     call nop4
                      00154 ws8_sendBGbit_5:     ws8_sendbit MOVIW INDF0++, ORG$, ORG$;;
0067   0098               M     movwf LATA
0068   2869               M     goto $+1
0069   0198               M     clrf LATA
006A   2008               M     call nop4
                      00155 ws8_sendBGbit_4:     ws8_sendbit MOVIW INDF0++, ORG$, ORG$;;
006D   0098               M     movwf LATA
006E   286F               M     goto $+1
006F   0198               M     clrf LATA
0070   2008               M     call nop4
                      00156 ws8_sendBGbit_3:     ws8_sendbit MOVIW INDF0++, ORG$, ORG$;;
0073   0098               M     movwf LATA
0074   2875               M     goto $+1
0075   0198               M     clrf LATA
0076   2008               M     call nop4
                      00157 ws8_sendBGbit_2:     ws8_sendbit MOVIW INDF0++, ORG$, ORG$;;
0079   0098               M     movwf LATA
007A   287B               M     goto $+1
007B   0198               M     clrf LATA
007C   2008               M     call nop4
                      00158 ws8_sendBGbit_1:     ws8_sendbit MOVIW INDF0++, ORG$, return; //return + next call takes 4 instr
007F   0098               M     movwf LATA
0080   2881               M     goto $+1
0081   0198               M     clrf LATA
                      00159 ;lamba wrapper for ws_sendbit:
                      00160 ;uses NOP 2 timeslot
                      00161 rewindpx macro fgbg
                      00162     addfsr FSR#v(fgbg), -24+1; first bit was already sent, only need 23 more
                      00163     NOP 1
                      00164     endm
0083                  00165 ws8_resendFGpx:
                      00166     ws8_sendbit MOVIW -24[FSR1],      rewindpx FG, goto ws8_sendFG_23bits; //goto+call = 4 instr
0085   0098               M     movwf LATA
0087   0000               M     nop
0088   0198               M     clrf LATA
008A                  00167 ws8_sendFGpx:
                      00168     ws8_sendbit MOVIW INDF1++,      ORG$, NOP 2; //reserve 2 instr for next call
008C   0098               M     movwf LATA
008D   288E               M     goto $+1
008E   0198               M     clrf LATA
008F   2890               M     goto $+1
0090                  00169 ws8_sendFG_23bits:
0090   2029           00170     call ws8_sendFGbit_7; //custom bit above
0091   2023           00171     call ws8_sendFGbit_8;
0092   2029           00172     call ws8_sendFGbit_7; //custom bit below
                      00173     NOP 2; //replaces "call" (next bit is inlined)
0093   2894               M     goto $+1
                      00174     ws8_sendbit MOVIW INDF1++,      ORG$, return; //return + next call takes 4 instr
0096   0098               M     movwf LATA
0097   2898               M     goto $+1
0098   0198               M     clrf LATA
009A                  00175 ws8_resendBGpx:
                      00176     ws8_sendbit MOVIW -24[FSR0],      rewindpx BG, goto ws8_sendBG_23bits; //goto+call = 4 instr
009C   0098               M     movwf LATA
009E   0000               M     nop
009F   0198               M     clrf LATA
00A1                  00177 ws8_sendBGpx:
                      00178     ws8_sendbit MOVIW INDF0++,      ORG$, NOP 2; //reserve 2 instr for next call
00A3   0098               M     movwf LATA
00A4   28A5               M     goto $+1
00A5   0198               M     clrf LATA
00A6   28A7               M     goto $+1
00A7                  00179 ws8_sendBG_23bits:
00A7   2059           00180     call ws8_sendBGbit_7; //custom bit above
00A8   2053           00181     call ws8_sendBGbit_8;
00A9   2059           00182     call ws8_sendBGbit_7; //custom bit below
                      00183     NOP 2; //replaces "call" (next bit is inlined)
00AA   28AB               M     goto $+1
                      00184     ws8_sendbit MOVIW INDF0++,      ORG$, return; //return + next call takes 4 instr
00AD   0098               M     movwf LATA
00AE   28AF               M     goto $+1
00AF   0198               M     clrf LATA
                      00185 
                      00186 
                      00187     nbDCL count,;;
                          M     CBLOCK NEXT_RAM9999; BOOL2INT(banked))  ;continue where we left off last time
  00000070                M         count 
                          M     ENDC  ;can't span macros
  0007                00188     constant UNIV_SCALE = divup(UNIV_LEN, 256); ; //8; //octal nodes to scale UNIV_LEN down to 8 bits
  00E5                00189     constant SEND_COUNT = divup(UNIV_LEN, UNIV_SCALE);;
                      00190 ;    messg [INFO] univ len #v(UNIV_LEN), sends #v(SEND_COUNT * UNIV_SCALE) nodes with granularity #v(UNIV_SCALE) nodes @190
Message[301]: MESSAGE: ([WARNING] univ len 1600 rounds to 1603 during send  @191)
                      00191     WARNIF(SEND_COUNT * UNIV_SCALE != UNIV_LEN, [WARNING] univ len 1600         rounds to 1603                        during send  @191)
                      00192 ;TODO: fix ^^^ by adding 1x send after loop
                      00193 ws_fillbg: DROP_CONTEXT;
                      00194     mov8 count, LITERAL(SEND_COUNT); ; //divup(UNIV_LEN / UNIV_SCALE)); //scale to fit in 8-bit counter
00B1   30E5               M     movlw (((ASM_MSB | (SEND_COUNT))) & ~ASM_MSB)
00B2   00F0               M     movwf count
                      00195 ;    addfsr FSR#v(BG), 24; //compensate for first rewind
                      00196     mov16 FSR0,      LITERAL(bgcolor + 24); ; //point to END of palette entry (compensate for resend)
00B3   3050               M     movlw (((ASM_MSB | (_1581SRC & 0xFF))) & ~ASM_MSB)
00B4   0084               M     movwf FSR0
00B5   0185               M     clrf FSR00hi
                      00197     BANKCHK LATA; //pre-select BSR to simplify timing
00B6   0140               M     banksel LATA
00B7                  00198 fill_loop: ;CAUTION: do not yield within this loop - will interfere with timing
                      00199     if UNIV_SCALE > 0
                      00200         REPEAT LITERAL(UNIV_SCALE - 1), call ws8_resendBGpx
  00000006                M _1628COUNT = (((ASM_MSB | (UNIV_SCALE - 1))) & ~ASM_MSB)
00B7   209A               M     call ws8_resendBGpx
00B8   209A               M     call ws8_resendBGpx
00B9   209A               M     call ws8_resendBGpx
00BA   209A               M     call ws8_resendBGpx
00BB   209A               M     call ws8_resendBGpx
00BC   209A               M     call ws8_resendBGpx
                      00201         NOP 2; //replaces "call" (next bit is inlined)
00BD   28BE               M     goto $+1
                      00202     endif
                      00203 ;rewindpx with custom last bit:
                      00204     ws8_sendbit MOVIW -24[FSR0],      rewindpx BG, call ws8_sendBGbit_7; //call+call = 4 instr
00C0   0098               M     movwf LATA
00C2   0000               M     nop
00C3   0198               M     clrf LATA
00C5   2053           00205     call ws8_sendBGbit_8;
00C6   2059           00206     call ws8_sendBGbit_7; //custom bit below
                      00207     NOP 2; //replaces "call" (next bit is inlined)
00C7   28C8               M     goto $+1
                      00208     ws8_sendbit MOVIW INDF0++,      ORG$, NOP 1; //reserve 3 instr for loop ctl
00CA   0098               M     movwf LATA
00CB   28CC               M     goto $+1
00CC   0198               M     clrf LATA
00CD   0000               M     nop
                      00209     DECFSZ count, F; //REGLO(count), F; //WREG, F
                          M     withdest_1 decfsz count
00CE   0BF0               M     decfsz count, F;
00CF   28B7           00210     goto fill_loop
                      00211 ;    REPEAT LITERAL(UNIV_LEN * 3 - 1), call wsoff_#v(8); //NOTE: 1-2 extra bytes here @end
00D0   0008           00212     return;
                      00213 
                      00214 ;color palette:
                      00215 ;each entry is 24 bytes: colors are 24 bits, and 1 bit from each byte goes to a separate IO pin
                      00216 ;PICs with 256 bytes RAM can only hold 10 palette entries in RAM; palette indexes use <= 4 bits
                      00217     b0DCL fgcolor, :24; //8 parallel 24-bit values (1 for each IO pin)
                          M     CBLOCK NEXT_RAM0; BOOL2INT(banked))  ;continue where we left off last time
  00000020                M         fgcolor :24
                          M     ENDC  ;can't span macros
                      00218     b0DCL bgcolor, :24; //8 parallel 24-bit values (1 for each IO pin)
                          M     CBLOCK NEXT_RAM0; BOOL2INT(banked))  ;continue where we left off last time
  00000038                M         bgcolor :24
                          M     ENDC  ;can't span macros
  00FF                00219     constant I = 255; //all 8 bits on (readbility, src code alignment)
  0000                00220     constant O = 0; //BIT(4); //all 8 bits off (or tampered/excluded)
                      00221 #if 0
                      00222 palette8_rom:
                      00223 ;TODO? could compress this but would break PALINX arithmetic
                      00224     CONSTANT OFF_PALINX = ($ - palette8_rom) / 24;
                      00225     DW O,O,O,O,O,O,O,O, O,O,O,O,O,O,O,O, O,O,O,O,O,O,O,O;
                      00226     CONSTANT BLUE_PALINX = ($ - palette8_rom) / 24;
                      00227     DW O,O,O,O,O,O,O,O, O,O,O,O,O,O,O,O, O,O,O,O,O,O,I,O; //dim
                      00228 ;//    DW O,O,O,O,O,O,O,O, O,O,O,O,O,O,O,O, I,I,I,I,I,I,I,I; //bright
                      00229     CONSTANT GREEN_PALINX = ($ - palette8_rom) / 24;
                      00230     DW O,O,O,O,O,O,O,O, O,O,O,O,O,O,I,O, O,O,O,O,O,O,O,O; //dim
                      00231 ;//    DW X,X,X,X,X,X,X,X, I,I,I,I,I,I,I,I, O,O,O,O,O,O,O,O; //bright
                      00232     CONSTANT CYAN_PALINX = ($ - palette8_rom) / 24;
                      00233     DW O,O,O,O,O,O,O,O, O,O,O,O,O,O,I,O, O,O,O,O,O,O,I,O; //dim
                      00234 ;//    DW O,O,O,O,O,O,O,O, I,I,I,I,I,I,I,I, I,I,I,I,I,I,I,I; //bright
                      00235     CONSTANT RED_PALINX = ($ - palette8_rom) / 24;
                      00236     DW O,O,O,O,O,O,I,O, O,O,O,O,O,O,O,O, O,O,O,O,O,O,O,O; //dim
                      00237 ;//    DW I,I,I,I,I,I,I,I, O,O,O,O,O,O,O,O, O,O,O,O,O,O,O,O; //bright
                      00238     CONSTANT MAGENTA_PALINX = ($ - palette8_rom) / 24, PINK_PALINX = MAGENTA_PALINX; easier to spell :P
                      00239     DW O,O,O,O,O,O,I,O, O,O,O,O,O,O,O,O, O,O,O,O,O,O,I,O; //dim
                      00240 ;//    DW I,I,I,I,I,I,I,I, O,O,O,O,O,O,O,O, I,I,I,I,I,I,I,I; //bright
                      00241     CONSTANT YELLOW_PALINX = ($ - palette8_rom) / 24;
                      00242     DW O,O,O,O,O,O,I,O, O,O,O,O,O,O,I,O, O,O,O,O,O,O,O,O; //dim
                      00243 ;//    DW I,I,I,I,I,I,I,I, I,I,I,I,I,I,I,I, O,O,O,O,O,O,O,O; //bright
                      00244     CONSTANT WHITE_PALINX = ($ - palette8_rom) / 24;
                      00245     DW O,O,O,O,O,O,I,O, O,O,O,O,O,O,I,O, O,O,O,O,O,O,I,O; //dim
                      00246 ;//    DW I,I,I,I,I,I,I,I, I,I,I,I,I,I,I,I, I,I,I,I,I,I,I,I; //bright
                      00247     CONSTANT TEST_PALINX = ($ - palette8_rom) / 24; //TEST ONLY; put after END_PALINX?
                      00248     DW 0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01, 0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x8, 0xE7,0xD9,0x9D,0x7E,0x18,0x24,0x42,0x81; //test bit pattern to watch in debugger
                      00249 ;//TODO: add more as needed ...
                      00250     CONSTANT END_PALINX = ($ - palette8_rom) / 24;
                      00251 
                      00252 ;RGB color indexes are 3 lsb; controls R/G/B on/off (for easier color combinations/debug)
                      00253 ;//#define BRIGHT(rgb)  ((rgb) + 8); brighter variant
                      00254     ERRIF(YELLOW_PALINX != (RED_PALINX | GREEN_PALINX), [ERROR] yellow 0                 != red 0              + green 0                @254)
                      00255     ERRIF(CYAN_PALINX != (GREEN_PALINX | BLUE_PALINX), [ERROR] cyan 0               != green 0                + blue 0               @255)
                      00256     ERRIF(MAGENTA_PALINX != (RED_PALINX | BLUE_PALINX), [ERROR] magenta 0                  != red 0              + blue 0               @256)
                      00257     ERRIF(WHITE_PALINX != (RED_PALINX | GREEN_PALINX | BLUE_PALINX), [ERROR] white 0                != red 0              + green 0                + blue 0               @2
                      00258 ;//    CONSTANT CUSTOM_PALINX = BRIGHT(0); caller-defined palette entry
                      00259 ;    CONSTANT FB_PALINX = 8
                      00260 ;    CONSTANT BG_PALINX = 9
                      00261 
                      00262 
                      00263 ;with_arg(bgcolor + 0) macro stmt
                      00264 ;    stmt, bgcolor + 0
                      00265 ;    endm
                      00266 fsrxfr macro
                      00267     MOVIW INDF1++
                      00268     MOVWI INDF0++
                      00269 WREG_TRACKER = WREG_UNKN
                      00270     endm
                      00271 memcpy macro dest, src, count
                      00272     if dest != FSR0
                      00273         mov16 FSR0, dest
                      00274     endif
                      00275     if src != FSR1
                      00276         mov16 FSR1, src
                      00277     endif
                      00278     REPEAT count, fsrxfr
                      00279     endm
                      00280 
                      00281 ;INDF takes 1 extra instr cycle to access ROM
                      00282 ;copy from ROM to RAM to avoid this (simplifies parallel bit banging timing)
                      00283 ;CAUTION: this is EXPENSIVE (memcpy by itself is 72 instr); only use during frame setup when IO is idle
                      00284 setbg_frompalette: DROP_CONTEXT;
                      00285 ;    ANDLW 0x0F; 4 bpp
                      00286     swapf WREG, W
                      00287     ANDLW 0xF0; //x16
                      00288     MOVWF bgcolor; kludge: use as temp
                      00289     mov16 FSR1, LITERAL(0x8000 + palette8_rom); ; //ROM address: NOTE: adds 1 instr cycle overhead each access
                      00290 ;    lslf bgcolor, W
                      00291 ;    ADDWF bgcolor, W; 3x
                      00292 ;    MOVF bgcolor, W;
                      00293     lsrf bgcolor, W; //x8
                      00294     addwf bgcolor, W; //x24; CAUTION: assumes <= 10 (no 8-bit wrap)
                      00295     ADDWF REGLO(FSR1), F;
                      00296     ifbit CARRY TRUE, dest_arg(F) INCF REGHI(FSR1)
                      00297 ;    mov16 FSR#v(BG), LITERAL(bgcolor)
                      00298 ;    REPEAT LITERAL(24), with_arg(bgcolor + REPEATER) MOVIW INDF#v(BG)++
                      00299 ;//TODO: use linear addr? 0x2000  skips gaps, but requires extra MOVLW/BSF to set FSR
                      00300     memcpy LITERAL(bgcolor), FSR1, LITERAL(24);;
                      00301 ;moved    mov16 FSR#v(BG), LITERAL(bgcolor); //leave FSR pointing to palette entry in RAM; could replace with ADDFSR to save 2 instr
                      00302     return;
                      00303 #endif
                      00304 ;non-ROM version of above:
                      00305 ;lit takes up same/less prog space as above and runs faster (with opp'ty for additional optimization)
                      00306 ;var takes up 50% more prog space but also runs faster
                      00307 setbg_fromrgb macro rgb
                      00308 ;        REPEAT LITERAL(24), MOVWF bgcolor + REPEATER, LITERAL(0)
                      00309     LOCAL bit = 23;
                      00310     while bit
                      00311         if ISLIT(rgb)
                      00312 ;           if (rgb) & BIT(bit)
                      00313 ;               MOVLW 0xFF; //SET8W; set all WREG bits; redundant loads will be optimized out
                      00314 ;               MOVWF bgcolor + bit;
                      00315 ;           else
                      00316 ;               CLRF bgcolor + bit;
                      00317 ;           endif
                      00318             mov8 bgcolor + bit, LITERAL(BOOL2INT((rgb) & BIT(bit)) * 0xFF)
                      00319         else
                      00320             CLRF bgcolor + bit;
                      00321             ifbit rgb + bit / 8, bit % 8, TRUE, dest_arg(F) DECF bgcolor + bit
                      00322         endif
                      00323 bit -= 1;
                      00324     endw
                      00325     endm
                      00326 
                      00327 
                      00328     THREAD_DEF ws_player, 4
                          M     CBLOCK NEXT_RAM9999; BOOL2INT(banked))  ;continue where we left off last time
  00000071                M         stkptr_0 
                          M     ENDC  ;can't span macros
Message[301]: MESSAGE: (creating ws_player thread# 0 @209, stack size 4, host stack remaining: 12 @1913)
0021                      M     ORG ctx_addr_2
0021   28D1               M     goto init_2
00D1                      M     ORG ctx_addr_3
00D1                      M init_2:
00D1   20DB               M     call stack_alloc_0
00D2   20E1               M     call ws_player
00D3   28D7               M     goto yield_again
00D4   017F               M     banksel STKPTR
                          M     withdest_0 movf STKPTR
00D5   086D               M     movf STKPTR, W;
00D6   00F1               M     movwf stkptr_0
00DA   0008               M     return
00DB   017F               M     banksel STKPTR
                          M     withdest_0 movf STKPTR
00DC   086D               M     movf STKPTR, W;
00DD   00F1               M     movwf stkptr_0
00DE   3003               M     movlw 4 - 1
                          M     withdest_1 addwf STKPTR
00DF   07ED               M     addwf STKPTR, F;
Message[301]: MESSAGE: ([DEBUG] 8173 @2005)
                      00329 ws_player: DROP_CONTEXT;
                      00330     WAIT 1 sec; give power time to settle, set up timer1 outside player loop
Message[301]: MESSAGE: ([TODO] change this to use postscaler 1..16 instead of just powers of 2 (for more accuracy) @1750)
Message[301]: MESSAGE: ([DEBUG] fps_init 1000000 (1111111 tuned) "usec": "prescaler" 15+1, max intv 2097152, actual 1114112, rollover 136 @1766)
00E1   3001               M     movlw (((ASM_MSB | (0 | 0 | _1983POSTSCALER << T0OUTPS0))) & ~ASM_MSB)
00E2   014B               M     banksel T0CON0
00E3   009E               M     movwf T0CON0
00E4   304F               M     movlw (((ASM_MSB | (b'010' << T0CS0 | 0 | _1983PRESCALER << T0CKPS0))) & ~ASM_MSB)
00E5   009F               M     movwf T0CON1
00E6   019C               M     clrf TMR0L
00E7   3087               M     movlw (((ASM_MSB | (_1983ROLLOVER - 1))) & ~ASM_MSB)
00E8   009D               M     movwf TMR0H
                          M     withbit_7 bsf T0CON0
00E9   179E               M     bsf T0CON0, 7
00EA   014E               M     banksel PIR0
                          M     withbit_5 bcf PIR0
00EB   128C               M     bcf PIR0, 5
00EC   28ED               M     goto $+1
00EE   28ED               M     goto $-1
00ED                      M     ORG ctx_addr_6
00EF                      M     ORG ctx_addr_7
                          M     withbit_5 bcf PIR0
00EF   128C               M     bcf PIR0, 5
00F0                  00331 play_loop: ;DROP_CONTEXT
                      00332 ;    MOVLW RED_PALINX;
                      00333 ;    CALL setbg_frompalette; doing this while idle < wait
                      00334     setbg_fromrgb LITERAL(0x020000); ; dim red
00F0   0140               M     banksel bgcolor + _2155bit
00F1   01CF               M     clrf bgcolor + _2155bit
00F2   01CE               M     clrf bgcolor + _2155bit
00F3   01CD               M     clrf bgcolor + _2155bit
00F4   01CC               M     clrf bgcolor + _2155bit
00F5   01CB               M     clrf bgcolor + _2155bit
00F6   01CA               M     clrf bgcolor + _2155bit
00F7   30FF               M     movlw (((ASM_MSB | (((((ASM_MSB | (0x020000))) & (1 << (_2155bit))) != 0) * 0xFF))) & ~ASM_MSB)
00F8   00C9               M     movwf bgcolor + _2155bit
00F9   01C8               M     clrf bgcolor + _2155bit
00FA   01C7               M     clrf bgcolor + _2155bit
00FB   01C6               M     clrf bgcolor + _2155bit
00FC   01C5               M     clrf bgcolor + _2155bit
00FD   01C4               M     clrf bgcolor + _2155bit
00FE   01C3               M     clrf bgcolor + _2155bit
00FF   01C2               M     clrf bgcolor + _2155bit
0100   01C1               M     clrf bgcolor + _2155bit
0101   01C0               M     clrf bgcolor + _2155bit
0102   01BF               M     clrf bgcolor + _2155bit
0103   01BE               M     clrf bgcolor + _2155bit
0104   01BD               M     clrf bgcolor + _2155bit
0105   01BC               M     clrf bgcolor + _2155bit
0106   01BB               M     clrf bgcolor + _2155bit
0107   01BA               M     clrf bgcolor + _2155bit
0108   01B9               M     clrf bgcolor + _2155bit
                      00335     WAIT 1 sec
0109   014E               M     banksel PIR0
010B   290A               M     goto $-1
010A                      M     ORG ctx_addr_8
010C                      M     ORG ctx_addr_9
                          M     withbit_5 bcf PIR0
010C   128C               M     bcf PIR0, 5
                      00336     CALL ws_fillbg;
010D   20B1               M     call ws_fillbg
                      00337 ;    setbit LATA, LEDOUT, TRUE;
                      00338 ;    MOVLW GREEN_PALINX;
                      00339 ;    CALL setbg_frompalette; doing this while idle < wait
                      00340     setbg_fromrgb LITERAL(0x000200); ; dim green
010E   0140               M     banksel bgcolor + _2549bit
010F   01CF               M     clrf bgcolor + _2549bit
0110   01CE               M     clrf bgcolor + _2549bit
0111   01CD               M     clrf bgcolor + _2549bit
0112   01CC               M     clrf bgcolor + _2549bit
0113   01CB               M     clrf bgcolor + _2549bit
0114   01CA               M     clrf bgcolor + _2549bit
0115   01C9               M     clrf bgcolor + _2549bit
0116   01C8               M     clrf bgcolor + _2549bit
0117   01C7               M     clrf bgcolor + _2549bit
0118   01C6               M     clrf bgcolor + _2549bit
0119   01C5               M     clrf bgcolor + _2549bit
011A   01C4               M     clrf bgcolor + _2549bit
011B   01C3               M     clrf bgcolor + _2549bit
011C   01C2               M     clrf bgcolor + _2549bit
011D   30FF               M     movlw (((ASM_MSB | (((((ASM_MSB | (0x000200))) & (1 << (_2549bit))) != 0) * 0xFF))) & ~ASM_MSB)
011E   00C1               M     movwf bgcolor + _2549bit
011F   01C0               M     clrf bgcolor + _2549bit
0120   01BF               M     clrf bgcolor + _2549bit
0121   01BE               M     clrf bgcolor + _2549bit
0122   01BD               M     clrf bgcolor + _2549bit
0123   01BC               M     clrf bgcolor + _2549bit
0124   01BB               M     clrf bgcolor + _2549bit
0125   01BA               M     clrf bgcolor + _2549bit
0126   01B9               M     clrf bgcolor + _2549bit
                      00341     WAIT 1 sec
0127   014E               M     banksel PIR0
0129   2928               M     goto $-1
0128                      M     ORG ctx_addr_10
012A                      M     ORG ctx_addr_11
                          M     withbit_5 bcf PIR0
012A   128C               M     bcf PIR0, 5
                      00342     CALL ws_fillbg;
012B   20B1               M     call ws_fillbg
                      00343 ;    setbit LATA, LEDOUT, FALSE;
                      00344 ;    MOVLW BLUE_PALINX;
                      00345 ;    CALL setbg_frompalette; doing this while idle < wait
                      00346     setbg_fromrgb LITERAL(0x000002); ; dim blue
012C   0140               M     banksel bgcolor + _2943bit
012D   01CF               M     clrf bgcolor + _2943bit
012E   01CE               M     clrf bgcolor + _2943bit
012F   01CD               M     clrf bgcolor + _2943bit
0130   01CC               M     clrf bgcolor + _2943bit
0131   01CB               M     clrf bgcolor + _2943bit
0132   01CA               M     clrf bgcolor + _2943bit
0133   01C9               M     clrf bgcolor + _2943bit
0134   01C8               M     clrf bgcolor + _2943bit
0135   01C7               M     clrf bgcolor + _2943bit
0136   01C6               M     clrf bgcolor + _2943bit
0137   01C5               M     clrf bgcolor + _2943bit
0138   01C4               M     clrf bgcolor + _2943bit
0139   01C3               M     clrf bgcolor + _2943bit
013A   01C2               M     clrf bgcolor + _2943bit
013B   01C1               M     clrf bgcolor + _2943bit
013C   01C0               M     clrf bgcolor + _2943bit
013D   01BF               M     clrf bgcolor + _2943bit
013E   01BE               M     clrf bgcolor + _2943bit
013F   01BD               M     clrf bgcolor + _2943bit
0140   01BC               M     clrf bgcolor + _2943bit
0141   01BB               M     clrf bgcolor + _2943bit
0142   01BA               M     clrf bgcolor + _2943bit
0143   30FF               M     movlw (((ASM_MSB | (((((ASM_MSB | (0x000002))) & (1 << (_2943bit))) != 0) * 0xFF))) & ~ASM_MSB)
0144   00B9               M     movwf bgcolor + _2943bit
                      00347     WAIT 1 sec
0145   014E               M     banksel PIR0
0147   2946               M     goto $-1
0146                      M     ORG ctx_addr_12
0148                      M     ORG ctx_addr_13
                          M     withbit_5 bcf PIR0
0148   128C               M     bcf PIR0, 5
                      00348     CALL ws_fillbg;
0149   20B1               M     call ws_fillbg
                      00349 ;    setbit LATA, LEDOUT, TRUE;
                      00350 ;    MOVLW OFF_PALINX;
                      00351 ;    CALL setbg_frompalette; doing this while idle < wait
                      00352     setbg_fromrgb LITERAL(0); ; off
014A   0140               M     banksel bgcolor + _3337bit
014B   01CF               M     clrf bgcolor + _3337bit
014C   01CE               M     clrf bgcolor + _3337bit
014D   01CD               M     clrf bgcolor + _3337bit
014E   01CC               M     clrf bgcolor + _3337bit
014F   01CB               M     clrf bgcolor + _3337bit
0150   01CA               M     clrf bgcolor + _3337bit
0151   01C9               M     clrf bgcolor + _3337bit
0152   01C8               M     clrf bgcolor + _3337bit
0153   01C7               M     clrf bgcolor + _3337bit
0154   01C6               M     clrf bgcolor + _3337bit
0155   01C5               M     clrf bgcolor + _3337bit
0156   01C4               M     clrf bgcolor + _3337bit
0157   01C3               M     clrf bgcolor + _3337bit
0158   01C2               M     clrf bgcolor + _3337bit
0159   01C1               M     clrf bgcolor + _3337bit
015A   01C0               M     clrf bgcolor + _3337bit
015B   01BF               M     clrf bgcolor + _3337bit
015C   01BE               M     clrf bgcolor + _3337bit
015D   01BD               M     clrf bgcolor + _3337bit
015E   01BC               M     clrf bgcolor + _3337bit
015F   01BB               M     clrf bgcolor + _3337bit
0160   01BA               M     clrf bgcolor + _3337bit
0161   01B9               M     clrf bgcolor + _3337bit
                      00353     WAIT 1 sec
0162   014E               M     banksel PIR0
0164   2963               M     goto $-1
0163                      M     ORG ctx_addr_14
0165                      M     ORG ctx_addr_15
                          M     withbit_5 bcf PIR0
0165   128C               M     bcf PIR0, 5
                      00354     CALL ws_fillbg;
0166   20B1               M     call ws_fillbg
                      00355 ;    setbit LATA, LEDOUT, FALSE;
                      00356     GOTO play_loop
0167   28F0               M     goto play_loop
                      00357     THREAD_END;
                      00358 
Message[301]: MESSAGE: (end of hoist 4 @216)
Message[301]: MESSAGE: (epilog @4432)
00E0                      M     ORG ctx_addr_5
00E0   2968               M     goto init_3
0168                      M     ORG ctx_addr_16
0168                      M init_3:
0168                      M at_eof_0:
0168                      M at_eof_1:
0168                      M at_eof_2:
Message[301]: MESSAGE: ([INFO] optimization stats: @4420)
0168                      M at_eof_3:
Message[301]: MESSAGE: ([INFO] bank sel: 18 (10%), dropped: 156 (90%) @2569)
0168                      M at_eof_4:
Message[301]: MESSAGE: ([INFO] bank0 used: 48/80 (60%) @2746)
Message[301]: MESSAGE: ([INFO] non-banked used: 2/16 (13%) @2752)
0168                      M at_eof_5:
Message[301]: MESSAGE: ([INFO] page sel: 1 (9%), dropped: 10 (91%) @3788)
Message[301]: MESSAGE: ([INFO] page0 used: 360/2048 (18%) @3790)
0168                      M at_eof_6:
0168                      M at_eof_7:
Message[301]: MESSAGE: ([INFO] #threads: 1, stack alloc: 4/16 (25%) @2089)
Message[301]: MESSAGE: ([DEBUG] why is banksel needed here? -1 @2095)
                          M     withdest_0 movf stkptr_1
0168   0871               M     movf stkptr_1, W;
0169   017F               M     banksel STKPTR
016A   00ED               M     movwf STKPTR
016B   0008               M     return
00D7                      M     ORG ctx_addr_4
                          M     withdest_0 movf stkptr_1
00D7   0871               M     movf stkptr_1, W;
00D8   017F               M     banksel STKPTR
00D9   00ED               M     movwf STKPTR
016C                      M     ORG ctx_addr_17
Message[301]: MESSAGE: (end of epilog @4467)
MPASM 5.87  /HOME/DJ/MPLABXPROJECTS/WSSPLITT   12-13-2021  0:07:08         PAGE  3
WS281X-Splitter - WS281X segment splitter/breakout/debug for Microchip PIC

SYMBOL TABLE
  LABEL                             VALUE 

ABS                               IIF((x) < 0, -(x), x)
ADDLW                             addlw_tracker
ADDWF                             addwf_banksafe
ALLOC_GPR                         
ANDLW                             andlw_tracker
ASM_MSB                           80000000
BANKCHK                           
BANKLEN                           0x80
BANKOF                            IIF(ISBANKED(reg), REG2ADDR(reg) / BANKLEN, BANK_UNKN)
BANKOFS                           ((reg) % BANKLEN)
BANKSAFE                          
BANKSEL_DROP                      0000009C
BANKSEL_KEEP                      00000014
BANK_TRACKER                      00001FED
BANK_UNKN                         -1
BCF                               bcf_tracker
BG                                00000000
BIT                               (1 << (n))
BOOL2INT                          ((val) != 0)
BORROW                            STATUS, C, !
BREAKOUT                          RA0
BRKOUT_BITREV                     
BRKOUT_BYTE                       BRKOUT_BYTE_#v(byte)
BSF                               bsf_tracker
BYTEOF                            IIF(ISLIT(val), BYTEOF_LIT(val, which), BYTEOF_REG(val, which))
BYTEOF_LIT                        LITERAL(((val) >> (8 * (which))) & 0xFF)
BYTEOF_REG                        REGISTER((val) + (which))
CALL                              call_pagesafe
CALLIF                            
CARRY                             STATUS, C,
CLRF                              clrf_tracker
CLRW                              CLRF WREG
COMMON_END                        0xC
CONTEXT_RESTORE                   
CONTEXT_SAVE                      
CURRENT_FPS_usec                  000F4240
DECF                              decf_banksafe
DECFSZ                            decfsz_tracker
DISABLED                          BIT(n)
DISABLED_ALL                      0xFF
DROP_BANK                         
DROP_CONTEXT                      
DROP_WREG                         
EMIT                              
EMITL                             
ENABLED                           NOBIT(n)
ENABLED_ALL                       0
ENDOF                             (name + SIZEOF(name))
EOF_ADDR                          00000168
EOF_COUNT                         00000008
EQUALS0                           STATUS, Z,
ERRIF                             ERRIF_#v(((assert) != 0))  msg
ERRIF_0                           IGNORE_EOL
ERRIF_1                           error
EXPAND_CTL                        
EXPAND_POP                        EXPAND_CTL -1
EXPAND_PUSH                       EXPAND_CTL
EXPAND_RESTORE                    EXPAND_CTL 0xf00d
FALSE                             0
FG                                00000001
FOSC_FREQ                         (32 MHz)
FOUND_MSB                         00000000
FSR00hi                           00000005
FSR10hi                           00000007
GOTO                              goto_pagesafe
GPR_END                           0x70
GPR_START                         0x20
HIBYTE16                          BYTEOF(val, 1)
HIBYTE24                          BYTEOF(val, 2)
HOST_STKLEN                       16-0
I                                 000000FF
IGNORE_EOL                        
IIF                               IIF_#v(((TF) != 0))(tval,  fval)
IIFDEBUG                          expr_true
IIF_0                             (fval)
IIF_1                             (tval)
INCF                              incf_banksafe
INCW                              ADDLW 1
INDF0_postdec                     00020003
INDF0_postinc                     00020002
INDF0_predec                      00020001
INDF0_preinc                      00020000
INDF0_special                     00020000
INDF1_postdec                     00010003
INDF1_postinc                     00010002
INDF1_predec                      00010001
INDF1_preinc                      00010000
INDF1_special                     00010000
INIT_COUNT                        00000003
IN_THREAD                         00000000
IORLW                             iorlw_tracker
ISBANKED                          ((BANKOFS(reg) >= COMMON_END) && (BANKOFS(reg) < GPR_END))
ISLIT                             ((val) & ASM_MSB)
ISR_VECTOR                        (RESET_VECTOR + 4)
KHz                               * 1000
LAST_INIT                         000000E1
LATEST_RAM1                       00000071
LATEST_RAM2                       00000038
LATEST_RAM3                       00000050
LATEST_RAM4                       00000072
LEDOUT                            RA4
LISTCTL                           
LIST_POP                          LISTCTL -1
LIST_PUSH                         LISTCTL
LIST_RESTORE                      LISTCTL 0xfeed
LIT2VAL                           ((n) & ~ASM_MSB)
LITBIT                            LITERAL(BIT(n))
LITERAL                           (ASM_MSB | (n))
LITPAGEOF                         ((addr) / LIT_PAGELEN)
LIT_PAGELEN                       0x800
LOBYTE                            BYTEOF(val, 0)
LSTCTL_DEEPEST                    00000003
LSTCTL_DEPTH                      00000000
LSTCTL_STACK                      00000000
MAX                               IIF((x) > (y), x, y)
MAX_RAM0                          00000070
MAX_RAM1                          000000F0
MAX_RAM9999                       00000080
MAX_T0POSTSC                      00000004
MAX_T0PRESCALER                   0000000F
MEXPAND_DEEPEST                   00000004
MEXPAND_DEPTH                     00000000
MEXPAND_STACK                     00000001
MHz                               * 1000000
MIDBYTE                           BYTEOF(val, 1)
MIN                               IIF((x) < (y), x, y)
MIN_STACK                         2
MIPS                              * 4 MHz
MOVF                              movf_banksafe
MOVIW_0_0                         MOVIW ++FSR0
MOVIW_0_1                         MOVIW --FSR0
MOVIW_0_2                         MOVIW FSR0++
MOVIW_0_3                         MOVIW FSR0--
MOVIW_1_0                         MOVIW ++FSR1
MOVIW_1_1                         MOVIW --FSR1
MOVIW_1_2                         MOVIW FSR1++
MOVIW_1_3                         MOVIW FSR1--
MOVIW_opc                         MOVIW_#v((fsr) == FSR1)_#v((mode) & 3)
MOVLW                             movlw_tracker
MOVWF                             movwf_banksafe
MOVWI_0_0                         MOVWI ++FSR0
MOVWI_0_1                         MOVWI --FSR0
MOVWI_0_2                         MOVWI FSR0++
MOVWI_0_3                         MOVWI FSR0--
MOVWI_1_0                         MOVWI ++FSR1
MOVWI_1_1                         MOVWI --FSR1
MOVWI_1_2                         MOVWI FSR1++
MOVWI_1_3                         MOVWI FSR1--
MOVWI_opc                         MOVWI_#v((fsr) == FSR1)_#v((mode) & 3)
MY_BRG                            (FOSC_FREQ / (freq) / 4 - 1)
MY_CONFIG1                        0000178C
MY_CONFIG2                        00002FFE
MY_CONFIG3                        00003F9F
MY_CONFIG4                        00001FFF
MY_CONFIG5                        00003FFF
NEXT_RAM0                         00000050
NEXT_RAM1                         000000A0
NEXT_RAM9999                      00000072
NOBANK                            0000270F
NOBIT                             0
NOP                               nop_multi
NULL_STMT                         ORG $
NUM_CONTEXT                       00000012
NUM_THREADS                       00000001
O                                 00000000
OUTPPS_DT1                        0x10
OUTPPS_TX1_CK1                    0x0F
PAGESEL_DROP                      0000000A
PAGESEL_KEEP                      00000001
PAGE_TRACKER                      000000E1
PASS1_FIXUPS                      00000000
PASS2_FIXUPS                      00000000
PLL                               * 2
POP                               
PUSH                              
PXOUT                             RA0
RAM_BLOCK                         00000004
RAM_LEN0                          00000050
RAM_LEN1                          00000050
RAM_LEN9999                       00000010
RAM_START0                        00000020
RAM_START1                        000000A0
RAM_START9999                     00000070
RAM_USED0                         00000030
RAM_USED1                         00000000
RAM_USED9999                      00000002
REG2ADDR                          (a)
REGHI                             name#v(0)hi
REGISTER                          (a)
REGLO                             name
REGMID                            name#v(0)mid
REGPAGEOF                         ((addr) / REG_PAGELEN)
REG_PAGELEN                       0x100
REPEAT                            
REPEATER                          00000006
RERUN_THREADS                     TRUE
RESET_VECTOR                      0
REVBIT                            (0x80 >> (n))
RGB_ORDER                         RGB_#v(n)
RGSWAP                            0x231
SEG1OUT                           RA1
SEG2OUT                           RA2
SEG3OUT                           RA#v(3+2)
SEG4OUT                           RA4
SEND_COUNT                        000000E5
SET8W                             IORLW 0xFF
SETUP_FULL                        00000080
SETUP_ONLY                        00000010
SETUP_PART                        00000040
SIZEOF                            name#v(0)size
SP1BRG0hi                         0000011C
SPI3x_0                           SPI3x_FIRST(byte)
SPI3x_1                           SPI3x_MID(byte)
SPI3x_2                           SPI3x_LAST(byte)
SPI3x_FIRST                       BRKOUT_BYTE(b'10010010' | BOOL2INT((byte) & BIT(7)) << 6 | BOOL2INT((byte) & BIT(6)) << 3 | BOOL2I
SPI3x_LAST                        BRKOUT_BYTE(b'00100100' | BOOL2INT((byte) & BIT(2)) << 7 | BOOL2INT((byte) & BIT(1)) << 4 | BOOL2I
SPI3x_MID                         BRKOUT_BYTE(b'01001001' | BOOL2INT((byte) & BIT(4)) << 5 | BOOL2INT((byte) & BIT(3)) << 2)
STK_ALLOC                         00000004
SUBLW                             sublw_tracker
SUBLWB                            
T0SRC_FOSC4                       b'010'
T0_prescaler                      prescaler(FOSC_FREQ/4, freq)
T1GATE_LC1OUT                     b'01101'
T1GATE_LC4OUT                     b'10000'
T1SRC_HFINTOSC                    b'0011'
T1SRC_LC3OUT                      b'1100'
T1_prescale                       log2(1)
THREAD_DEF                        
THREAD_END                        
TOS                               00001FEE
TOS0hi                            00001FEF
TRUE                              1
TUNED                             ((freq) * 10/9)
UGLY_PASS12FIX                    
UNIV_LEN                          1600
UNIV_SCALE                        00000007
UNTUNED                           ((freq) * 9/10)
USE_HFFRQ                         b'110'
WAIT                              
WAIT_4PX                          00000002
WANT_BIT                          00000001
WANT_DEBUG                        
WARNIF                            WARNIF_#v(((assert) != 0))  msg
WARNIF_0                          IGNORE_EOL
WARNIF_1                          messg
WREG_TRACKER                      00000071
WREG_UNKN                         40000000
WSBIT_FREQ                        (800 KHz)
WSBIT_THRESHOLD                   (FOSC_FREQ / (2 MHz))
WSDI                              RA3
WSENC_TEMP                        FFFFFFFF
WSLATCH                           (50 -20 usec)
WS_ENV                            235
XBIT                              NOBIT(n)
XORLW                             xorlw_tracker
YESNO                             YESNO_#v(((val) != 0))
YESNO_0                           false
YESNO_1                           true
YIELD_AGAIN_inlined               
__16F15313                        00000001
__DEBUG                           
__MPLAB_DEBUGGER_SIMULATOR        1
addlw_tracker                     
addwf_banksafe                    
andlw_tracker                     
asmbit                            00000020
asmpower2                         00000000
at_eof                            
b0DCL                             ALLOC_GPR 0,
b0DCL16                           
b0DCL24                           
bcf_tracker                       
before_yield                      00000011
bgcolor                           00000038
bgcolor0size                      00000018
bitnum_arg                        withbit_#v(argg)
bitoff_0                          
bitoff_1                          
bitoff_2                          
bitoff_3                          
bitoff_4                          
bitoff_5                          
bitoff_6                          
bitoff_7                          
biton_0                           
biton_1                           
biton_2                           
biton_3                           
biton_4                           
biton_5                           
biton_6                           
biton_7                           
bsf_tracker                       
call_pagesafe                     
clrf_tracker                      
clrw                              clrf WREG
comf2s                            
count                             00000070
count0size                        00000001
decf_banksafe                     
decfsz_tracker                    
dest_arg                          withdest_#v(argg)
divup                             (((num)+(den)-1)/(den))
doing_init                        
elapsed_fps                       PIR0, TMR0IF
eof                               00000168
eof_0                             
eof_1                             
eof_2                             
eof_3                             
eof_4                             
eof_5                             
eof_6                             
eof_7                             
fgcolor                           00000020
fgcolor0size                      00000018
fill_loop                         000000B7
find_msb                          
fosc_init                         
fps_init                          
generate_brkout_bytes             
goto_pagesafe                     
ifbit                             
ifbit_const                       
incf_banksafe                     
incw                              addlw 1
iopin_init                        
iorlw_tracker                     
khz                               rdiv(freq, 1000)
log2                              LOG2_#v(n)
mhz                               rdiv(freq, 1000000)
mov16                             mov_mb 16,
mov24                             mov_mb 24,
mov8                              
mov_mb                            
movf_banksafe                     
movlw_tracker                     
movwf_banksafe                    
msec                              * 1000
nbDCL                             ALLOC_GPR NOBANK,
nbDCL16                           
nbDCL24                           
nop16                             00000004
nop32                             00000003
nop4                              00000008
nop7                              00000006
nop8                              00000005
nop_multi                         
nopif                             
pct                               rdiv(100 * (num), den)
play_loop                         000000F0
pmd_init                          
pps_lock                          
prescaler                         log2((base_freq) / (want_freq))
rdiv                              (((num)+(den)/2)/MAX(den, 1))
rewindpx                          
scale                             (BIT(prescale) KHz / khz(freq))
sec                               * 1000000
setbg_fromrgb                     
setbit                            
showarg_0                         
stkptr_00size                     00000001
sublw_tracker                     
swapreg                           
usec                              * 1
val_arg                           showarg_#v(argg)
wait2xmit                         
wait2xmit_if                      
wait4frame                        
wait4px                           
waitpx                            
whilebit                          
with_arg                          witharg_#v(argg)
witharg_0                         
withbit_0                         
withbit_1                         
withbit_2                         
withbit_3                         
withbit_4                         
withbit_5                         
withbit_6                         
withbit_7                         
withdest_0                        
withdest_1                        
ws8_resendBGpx                    0000009A
ws8_resendFGpx                    00000083
ws8_sendBG_23bits                 000000A7
ws8_sendBGbyte                    00000053
ws8_sendBGpx                      000000A1
ws8_sendFG_23bits                 00000090
ws8_sendFGbyte                    00000023
ws8_sendFGpx                      0000008A
ws8_sendbit                       
ws_breakout_setup                 
ws_decode                         
ws_encbyte                        
ws_fillbg                         000000B1
ws_player                         000000E1
ws_send_byte                      
ws_send_px                        
xmit_ready                        PIR3, TX1IF, yesno
xorlw_tracker                     
yield                             000000D4
yield_again                       000000D7


MEMORY USAGE MAP ('X' = Used,  '-' = Unused)

0000 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0040 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0080 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
00C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0100 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0140 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXX--- ----------------
8000 : -------XXXXX---- ---------------- ---------------- ----------------

All other memory blocks unused.

Program Memory Words Used:   370
Program Memory Words Free:  1678


Errors   :     0
Warnings :     0 reported,     0 suppressed
Messages :    37 reported,    32 suppressed


